# Patrones de comportamiento

Los patrones de comportamiento se enfocan en `c√≥mo interact√∫an los objetos entre s√≠`, es decir, la manera en que se
comunican, delegan responsabilidades o coordinan acciones.

Estos patrones buscan:

- `Separar responsabilidades` claramente.
- Facilitar la extensi√≥n o `variaci√≥n de comportamiento` sin modificar las clases existentes.
- Promover el principio de `abierto/cerrado` (`OCP del SOLID`).

üìå Ejemplos cl√°sicos: `Strategy`, `Template Method`, `Observer`, `Command`, `Chain of Responsibility`, etc.

---

## Strategy

El `patr√≥n Strategy` define una `familia de algoritmos` o `comportamientos`, los encapsula por separado y permite
`intercambiarlos din√°micamente` sin modificar el c√≥digo del cliente que los utiliza. El objeto que usa el algoritmo no
necesita conocer los detalles de implementaci√≥n, solo delega la tarea a la estrategia seleccionada.

- Permite que `el comportamiento de una clase cambie en tiempo de ejecuci√≥n`, deleg√°ndolo a una interfaz com√∫n que
  agrupa distintas estrategias concretas.
- `Favorece` el principio de `abierto/cerrado` y `la composici√≥n` sobre la herencia.
- Su objetivo es separar el qu√© se hace del c√≥mo se hace, dando flexibilidad.

### üß© Casos de uso reales del patr√≥n Strategy

Este patr√≥n es extremadamente com√∫n. Algunos casos en el mundo real:

#### üîß En aplicaciones Java/Spring:

- Algoritmos de validaci√≥n de datos (validar distintos tipos de documentos, estrategias de pago, etc.).
- Diferentes formas de env√≠o (email, SMS, push).
- Selecci√≥n de l√≥gica seg√∫n el tipo de usuario, tipo de archivo, estado del negocio, etc.
- Estrategias de serializaci√≥n (JSON, XML, YAML).
- Estrategias de c√°lculo de precios, descuentos, impuestos.

#### üì¶ Ejemplos en librer√≠as/frameworks:

- Spring Security utiliza Strategy para m√∫ltiples mecanismos de autenticaci√≥n.
- Spring usa ConversionService para conversi√≥n de tipos basada en estrategias.
- Comparator de Java es una forma simplificada de Strategy.

### üìê Representaci√≥n UML del patr√≥n Strategy

![01.png](assets/02-java-plano-comportamiento/01.png)

1. La clase `contexto` mantiene una referencia a una de las estrategias concretas y se comunica con este objeto
   √∫nicamente a trav√©s de la `interfaz estrategia`.
2. La `interfaz estrategia` es com√∫n a todas las estrategias concretas. Declara un m√©todo que la clase contexto utiliza
   para ejecutar una estrategia.
3. Las `estrategias concretas` implementan distintas variaciones de un algoritmo que la clase contexto utiliza.
4. La `clase contexto` invoca el m√©todo de ejecuci√≥n en el objeto de estrategia vinculado cada vez que necesita ejecutar
   el algoritmo. La `clase contexto` no sabe con qu√© tipo de estrategia funciona o c√≥mo se ejecuta el algoritmo. La
   `clase contexto` expone un modificador `set()` que permite a los clientes sustituir la estrategia asociada al
   contexto durante el tiempo de ejecuci√≥n.
5. El `cliente` crea un objeto de estrategia espec√≠fico y lo pasa a la clase contexto.

### üéØ Ejemplo 01: Estrategias de pago

`Contexto realista`: Supongamos que queremos aplicar diferentes estrategias de pago: `tarjeta de cr√©dito`, `PayPal` y
`transferencia bancaria`.

Entonces, la implementaci√≥n de nuestro patr√≥n `Strategy` estar√° basado en el siguiente diagrama de clases.

![02.png](assets/02-java-plano-comportamiento/02.png)

### `PaymentStrategy ‚Äì Interfaz de Estrategia`

Esta interfaz define el contrato com√∫n para todas las estrategias de pago. Cada clase que implemente esta interfaz
representar√° una forma distinta de procesar pagos, encapsulando su propia l√≥gica de autenticaci√≥n, validaci√≥n y
ejecuci√≥n del pago.

**Rol en el patr√≥n Strategy**

En el patr√≥n `Strategy`, esta interfaz representa el `Strategy` (la estrategia en s√≠ misma). Define el conjunto de
operaciones intercambiables que el contexto podr√° utilizar din√°micamente sin conocer los detalles internos de cada
implementaci√≥n concreta.

**M√©todos definidos**

- `collectPaymentDetails`
    - Recoge los datos necesarios del usuario seg√∫n el tipo de pago.
    - Se pasa un BufferedReader externo para mantener un solo recurso compartido desde el cliente (buen manejo de
      recursos).
- `validatePaymentDetails`
    - Valida los datos ingresados.
    - Permite que el flujo de pago contin√∫e solo si se ingresaron datos v√°lidos (por ejemplo, autenticaci√≥n exitosa,
      campos no vac√≠os, etc.).
- `pay`
    - Ejecuta el pago seg√∫n la estrategia seleccionada.
    - Devuelve true si el pago fue exitoso, false en caso contrario.

````java
public interface PaymentStrategy {
    void collectPaymentDetails(BufferedReader reader);

    boolean validatePaymentDetails();

    boolean pay(int amount);
}
````

‚úÖ **Buenas pr√°cticas aplicadas**

- `Principio de Abierto/Cerrado (OCP)`: Podemos agregar nuevas estrategias (como `BitcoinPayment`, `ApplePay`, etc.)
  sin modificar el c√≥digo existente.
- `Principio de Responsabilidad √önica (SRP)`: Cada implementaci√≥n concreta se encarga √∫nicamente de su l√≥gica de pago.
- `Desacoplamiento`: El cliente y el contexto no necesitan conocer los detalles espec√≠ficos de cada forma de pago.

### `BankTransferPayment ‚Äì Estrategia concreta`

Esta clase es una implementaci√≥n concreta de la interfaz `PaymentStrategy`. Representa la l√≥gica necesaria para realizar
un pago mediante transferencia bancaria, solicitando datos b√°sicos como titular de cuenta, banco y n√∫mero de cuenta.

**Rol en el patr√≥n Strategy**

En el patr√≥n `Strategy`, esta clase act√∫a como una `Concrete Strategy`. Define una forma espec√≠fica de realizar un pago
siguiendo el contrato com√∫n de la interfaz `PaymentStrategy`. Puede ser intercambiada f√°cilmente con otras estrategias
sin que el cliente o el contexto deban conocer su implementaci√≥n interna.

**Responsabilidades principales**

- Recoger los datos necesarios para realizar una transferencia bancaria.
- Validar que los datos ingresados no est√©n vac√≠os.
- Procesar el pago si la validaci√≥n fue exitosa.

````java

@Slf4j
public class BankTransferPayment implements PaymentStrategy {

    private String accountHolder;
    private String bankName;
    private String accountNumber;
    private boolean detailsProvided;

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Pago por Transferencia Bancaria ===");
        try {
            this.accountHolder = this.prompt(reader, "Ingrese nombre del titular de la cuenta:");
            this.bankName = this.prompt(reader, "Ingrese nombre del banco:");
            this.accountNumber = this.prompt(reader, "Ingrese n√∫mero de cuenta:");
        } catch (IOException exception) {
            log.error("Error al leer datos bancarios: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        this.detailsProvided = this.isValid();
        if (this.detailsProvided) {
            log.info("Detalles bancarios registrados correctamente");
        } else {
            log.error("Faltan datos para procesar la transferencia");
        }
        return this.detailsProvided;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (this.detailsProvided) {
            log.info("Pagando S/ {} por transferencia bancaria a nombre de {} en {}.", paymentAmount, this.accountHolder, this.bankName);
            return true;
        }
        log.warn("No se proporcionaron los datos necesarios para realizar la transferencia");
        return false;
    }

    private boolean isValid() {
        return !accountHolder.isBlank() &&
               !bankName.isBlank() &&
               !accountNumber.isBlank();
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

üß© **Otras estrategias similares**

Tambi√©n se han implementado otras dos estrategias (PayPalPayment y CreditCardPayment), las cuales siguen exactamente el
mismo contrato `PaymentStrategy`, pero adaptan su l√≥gica interna seg√∫n los requisitos de su tipo de pago (por ejemplo,
validaci√≥n con email/contrase√±a en PayPal o datos de tarjeta en CreditCard).

### `PayPalPayment ‚Äì Estrategia concreta`

````java

@Slf4j
public class PayPalPayment implements PaymentStrategy {

    private static final Map<String, String> DATA_BASE = new HashMap<>();

    private String email;
    private String password;
    private boolean signedIn;

    static {
        DATA_BASE.put("martin@gmail.com", "martin");
        DATA_BASE.put("milagros@gmail.com", "123456");
    }

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Autenticaci√≥n PayPal ===");
        try {
            this.email = this.prompt(reader, "Ingrese su email de usuario:");
            this.password = this.prompt(reader, "Ingrese su contrase√±a:");
        } catch (IOException exception) {
            log.error("Error al leer entrada del usuario: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        this.signedIn = Objects.equals(this.password, DATA_BASE.get(email));

        if (this.signedIn) {
            log.info("Inicio de sesi√≥n exitoso");
        } else {
            log.error("Email o password incorrectos");
        }
        return this.signedIn;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (this.signedIn) {
            log.info("Pagando S/ {} con PayPal (usuario: {})", paymentAmount, this.email);
            return true;
        }
        log.warn("El usuario no ha iniciado sesi√≥n correctamente. No se puede realizar el pago");
        return false;
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

### `CreditCardPayment ‚Äì Estrategia concreta`

````java

@ToString
public class CreditCard {
    @Getter
    private final String number;
    @Getter
    private final String expiry;
    @Getter
    private final String cvv;
    @Getter
    @Setter
    private int amount = 100_000; //Simula saldo de la tarjeta

    public CreditCard(String number, String expiry, String cvv) {
        this.number = number;
        this.expiry = expiry;
        this.cvv = cvv;
    }

}
````

````java

@Slf4j
public class CreditCardPayment implements PaymentStrategy {

    private CreditCard creditCard;

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Ingreso de datos de tarjeta de cr√©dito ===");
        try {
            String number = this.prompt(reader, "Ingrese n√∫mero de tarjeta:");
            String expiry = this.prompt(reader, "Ingrese fecha de expiraci√≥n (mm/yy):");
            String cvv = this.prompt(reader, "Ingrese c√≥digo cvv:");
            this.creditCard = new CreditCard(number, expiry, cvv);
        } catch (IOException exception) {
            log.error("Error al leer datos de la tarjeta: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        log.info("Validando tarjeta...");
        if (this.validateCard(this.creditCard)) {
            log.info("Tarjeta v√°lida: {}", creditCard);
            return true;
        }

        log.error("Datos de tarjeta inv√°lidos");
        this.creditCard = null;
        return false;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (!this.cardIsPresent()) {
            log.warn("No hay tarjeta registrada. No se puede procesar el pago");
            return false;
        }

        if (this.creditCard.getAmount() < paymentAmount) {
            log.warn("Fondos insuficientes en la tarjeta. Monto disponible: S/ {}", this.creditCard.getAmount());
            return false;
        }

        this.creditCard.setAmount(this.creditCard.getAmount() - paymentAmount);
        log.info("Pagando S/ {} con tarjeta de cr√©dito (Saldo restante: S/ {})", paymentAmount, this.creditCard.getAmount());
        return true;

    }

    private boolean validateCard(CreditCard card) {
        return !card.getNumber().isBlank() &&
               !card.getExpiry().isBlank() &&
               !card.getCvv().isBlank();
    }

    private boolean cardIsPresent() {
        return Objects.nonNull(this.creditCard);
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

### `PaymentContext ‚Äì Contexto del patr√≥n Strategy`

Esta clase representa el `Contexto` en el patr√≥n `Strategy`. Su principal funci√≥n es mantener una referencia a una
estrategia concreta de pago (`PaymentStrategy`) y delegar en ella la ejecuci√≥n de las operaciones correspondientes.

````java

@Slf4j
public class PaymentContext {

    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void collectPaymentDetails(BufferedReader reader) {
        this.validateStrategy();
        this.paymentStrategy.collectPaymentDetails(reader);
    }

    public boolean validatePaymentDetails() {
        this.validateStrategy();
        return this.paymentStrategy.validatePaymentDetails();
    }

    public boolean pay(int amount) {
        this.validateStrategy();
        return this.paymentStrategy.pay(amount);
    }

    private void validateStrategy() {
        if (Objects.isNull(this.paymentStrategy)) {
            throw new IllegalStateException("No se ha definido una estrategia de pago");
        }
    }
}
````

**Rol en el patr√≥n Strategy**

- Act√∫a como Contexto, que es responsable de usar una estrategia (`PaymentStrategy`) definida din√°micamente en tiempo
  de ejecuci√≥n.
- No conoce los detalles de implementaci√≥n de cada estrategia, s√≥lo interact√∫a a trav√©s de la interfaz com√∫n.
- Encapsula la variaci√≥n del algoritmo delegando el comportamiento a una instancia concreta de la estrategia.

**Responsabilidades**

- Recibir la estrategia a utilizar (`setPaymentStrategy(...)`).
- Delegar la ejecuci√≥n de los m√©todos `collectPaymentDetails()`, `validatePaymentDetails()` y `pay()` a la estrategia
  asignada.
- Validar que una estrategia haya sido definida antes de delegar cualquier operaci√≥n.

**Beneficios**

- Cumple con el principio de `abierto/cerrado (OCP)`: se pueden agregar nuevas estrategias sin modificar esta clase.
- Sigue el principio de `inversi√≥n de dependencias (DIP)`: el contexto depende de una abstracci√≥n (`PaymentStrategy`),
  no de implementaciones concretas.

**Consideraciones**

- El contexto no necesita saber cu√°l es la l√≥gica de cada estrategia concreta. Puede operar de forma gen√©rica gracias a
  la interfaz.
- Si en un futuro se agregan validaciones adicionales (como logging o auditor√≠a), podr√≠an centralizarse tambi√©n aqu√≠,
  manteniendo la estrategia limpia.

### `üßë‚Äçüíª Cliente: Main`

Este `cliente (Main`) es el punto de entrada de la aplicaci√≥n y cumple el rol de coordinador que configura el contexto
del `patr√≥n Strategy`.

Responsabilidades clave:

- ‚úÖ Solicita al usuario que elija el m√©todo de pago (PayPal, transferencia o tarjeta).
- ‚úÖ Crea la estrategia concreta correspondiente (PaymentStrategy) y la inyecta al contexto (PaymentContext).
- ‚úÖ Coordina la recolecci√≥n de datos del usuario, con hasta 3 intentos para validarlos.
- ‚úÖ Solicita el monto a pagar.
- ‚úÖ Ejecuta el m√©todo pay de la estrategia activa, a trav√©s del contexto.

El cliente no necesita conocer los detalles de implementaci√≥n de cada tipo de pago. Simplemente, selecciona una
estrategia en tiempo de ejecuci√≥n y el `PaymentContext` se encarga de delegar las operaciones de manera polim√≥rfica.

````java

@Slf4j
public class Main {
    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            PaymentContext context = new PaymentContext();

            log.info("=== Sistema de Pagos ===");
            log.info("Elija el m√©todo de pago:");
            log.info("1. PayPal");
            log.info("2. Transferencia Bancaria");
            log.info("3. Tarjeta de Cr√©dito");

            String option = reader.readLine().trim();
            switch (option) {
                case "1" -> context.setPaymentStrategy(new PayPalPayment());
                case "2" -> context.setPaymentStrategy(new BankTransferPayment());
                case "3" -> context.setPaymentStrategy(new CreditCardPayment());
                default -> {
                    log.warn("Opci√≥n inv√°lida");
                    return;
                }
            }

            final int maxAttempts = 3;
            boolean isValid = false;

            for (int attempts = 1; attempts <= maxAttempts; attempts++) {
                log.info("Intento {}/{}", attempts, maxAttempts);
                context.collectPaymentDetails(reader);

                if (context.validatePaymentDetails()) {
                    isValid = true;
                    break;
                }
            }

            if (!isValid) {
                log.warn("Se consumieron todos los intentos. Int√©ntelo m√°s tarde.");
                return;
            }

            log.info("Ingrese el monto a pagar:");
            int amount = Integer.parseInt(reader.readLine().trim());

            if (context.pay(amount)) {
                log.info("Pago realizado con √©xito");
            } else {
                log.info("El pago no se pudo procesar");
            }
        }
    }
}
````

---

## Template Method

El patr√≥n `Template Method` es un patr√≥n de comportamiento que define la `estructura de un algoritmo` en una
clase base, delegando la `implementaci√≥n de algunos pasos` a las subclases. Es ideal cuando tienes una l√≥gica que
sigue siempre un mismo flujo general, pero `algunos pasos deben ser personalizados`.

### üß© Caracter√≠sticas clave

- Utiliza una clase abstracta con un m√©todo `‚Äúplantilla‚Äù` (`templateMethod()`), que define los pasos del algoritmo.
- Algunos pasos son implementados directamente en la clase base, mientras que otros se declaran como m√©todos abstractos
  para que las subclases los definan.
- Fomenta el principio de Hollywood: "Don‚Äôt call us, we‚Äôll call you" ‚Äî es decir, la clase base controla el flujo general

### üîß ¬øCu√°ndo usar el patr√≥n Template Method?

Usa este patr√≥n cuando:

- Tienes m√∫ltiples clases que comparten una secuencia de pasos, pero cada una implementa los pasos de forma diferente.
- Deseas evitar duplicaci√≥n de c√≥digo al mantener la l√≥gica com√∫n en una clase base.
- Quieres estandarizar un proceso, pero necesitas que ciertas partes sean personalizables.

### üìå Ejemplos de la vida real

- `Proceso de carga de archivos`:
    - *Validar archivo ‚Üí Leer contenido ‚Üí Procesar datos ‚Üí Guardar resultado*. Cada tipo de archivo (CSV, XML, JSON)
      implementa su propia l√≥gica de lectura y procesamiento.


- `Juego`:
    - *Inicializar juego ‚Üí Jugar turno ‚Üí Mostrar resultados*. Cada juego tiene sus propias reglas, pero la estructura
      general del flujo es la misma.


- `Conexi√≥n a una base de datos`:
    - *Abrir conexi√≥n ‚Üí Ejecutar operaci√≥n ‚Üí Cerrar conexi√≥n*. El paso de `‚Äúejecutar operaci√≥n‚Äù` puede variar (insertar,
      actualizar, consultar).

### ‚úÖ Ventajas

- Reutilizaci√≥n de c√≥digo: l√≥gica com√∫n centralizada.
- Fomenta el principio "Open/Closed": el algoritmo base est√° cerrado a modificaciones, pero abierto a extensiones.
- Mejora la legibilidad y mantenibilidad.

### ‚ùå Desventajas

- Aumenta el acoplamiento entre la clase base y las subclases.
- Puede haber rigidez si se necesitan muchos pasos personalizados.

### üìê Representaci√≥n UML del patr√≥n Template Method

![03.png](assets/02-java-plano-comportamiento/03.png)

1. La `Clase Abstracta` declara m√©todos que act√∫an como pasos de un algoritmo, as√≠ como el propio m√©todo de plantilla
   que invoca estos m√©todos en un orden espec√≠fico. Los pasos pueden declararse `abstractos` o contar con una
   implementaci√≥n por defecto.
2. Las `Clases Concretas` pueden sobreescribir todos los pasos, pero no el propio m√©todo plantilla.
