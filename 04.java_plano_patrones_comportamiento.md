# Patrones de comportamiento

Los patrones de comportamiento se enfocan en `cómo interactúan los objetos entre sí`, es decir, la manera en que se
comunican, delegan responsabilidades o coordinan acciones.

Estos patrones buscan:

- `Separar responsabilidades` claramente.
- Facilitar la extensión o `variación de comportamiento` sin modificar las clases existentes.
- Promover el principio de `abierto/cerrado` (`OCP del SOLID`).

📌 Ejemplos clásicos: `Strategy`, `Template Method`, `Observer`, `Command`, `Chain of Responsibility`, etc.

---

## Strategy

El `patrón Strategy` define una `familia de algoritmos` o `comportamientos`, los encapsula por separado y permite
`intercambiarlos dinámicamente` sin modificar el código del cliente que los utiliza. El objeto que usa el algoritmo no
necesita conocer los detalles de implementación, solo delega la tarea a la estrategia seleccionada.

- Permite que `el comportamiento de una clase cambie en tiempo de ejecución`, delegándolo a una interfaz común que
  agrupa distintas estrategias concretas.
- `Favorece` el principio de `abierto/cerrado` y `la composición` sobre la herencia.
- Su objetivo es separar el qué se hace del cómo se hace, dando flexibilidad.

### 🧩 Casos de uso reales del patrón Strategy

Este patrón es extremadamente común. Algunos casos en el mundo real:

#### 🔧 En aplicaciones Java/Spring:

- Algoritmos de validación de datos (validar distintos tipos de documentos, estrategias de pago, etc.).
- Diferentes formas de envío (email, SMS, push).
- Selección de lógica según el tipo de usuario, tipo de archivo, estado del negocio, etc.
- Estrategias de serialización (JSON, XML, YAML).
- Estrategias de cálculo de precios, descuentos, impuestos.

#### 📦 Ejemplos en librerías/frameworks:

- Spring Security utiliza Strategy para múltiples mecanismos de autenticación.
- Spring usa ConversionService para conversión de tipos basada en estrategias.
- Comparator de Java es una forma simplificada de Strategy.

### 📐 Representación UML del patrón Strategy

![01.png](assets/02-java-plano-comportamiento/01.png)

1. La clase `contexto` mantiene una referencia a una de las estrategias concretas y se comunica con este objeto
   únicamente a través de la `interfaz estrategia`.
2. La `interfaz estrategia` es común a todas las estrategias concretas. Declara un método que la clase contexto utiliza
   para ejecutar una estrategia.
3. Las `estrategias concretas` implementan distintas variaciones de un algoritmo que la clase contexto utiliza.
4. La `clase contexto` invoca el método de ejecución en el objeto de estrategia vinculado cada vez que necesita ejecutar
   el algoritmo. La `clase contexto` no sabe con qué tipo de estrategia funciona o cómo se ejecuta el algoritmo. La
   `clase contexto` expone un modificador `set()` que permite a los clientes sustituir la estrategia asociada al
   contexto durante el tiempo de ejecución.
5. El `cliente` crea un objeto de estrategia específico y lo pasa a la clase contexto.

### 🎯 Ejemplo 01: Estrategias de pago

`Contexto realista`: Supongamos que queremos aplicar diferentes estrategias de pago: `tarjeta de crédito`, `PayPal` y
`transferencia bancaria`.

