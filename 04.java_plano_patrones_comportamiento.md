# Patrones de comportamiento

Los patrones de comportamiento se enfocan en `c√≥mo interact√∫an los objetos entre s√≠`, es decir, la manera en que se
comunican, delegan responsabilidades o coordinan acciones.

Estos patrones buscan:

- `Separar responsabilidades` claramente.
- Facilitar la extensi√≥n o `variaci√≥n de comportamiento` sin modificar las clases existentes.
- Promover el principio de `abierto/cerrado` (`OCP del SOLID`).

üìå Ejemplos cl√°sicos: `Strategy`, `Template Method`, `Observer`, `Command`, `Chain of Responsibility`, etc.

---

## Strategy

El `patr√≥n Strategy` define una `familia de algoritmos` o `comportamientos`, los encapsula por separado y permite
`intercambiarlos din√°micamente` sin modificar el c√≥digo del cliente que los utiliza. El objeto que usa el algoritmo no
necesita conocer los detalles de implementaci√≥n, solo delega la tarea a la estrategia seleccionada.

- Permite que `el comportamiento de una clase cambie en tiempo de ejecuci√≥n`, deleg√°ndolo a una interfaz com√∫n que
  agrupa distintas estrategias concretas.
- `Favorece` el principio de `abierto/cerrado` y `la composici√≥n` sobre la herencia.
- Su objetivo es separar el qu√© se hace del c√≥mo se hace, dando flexibilidad.

### üß© Casos de uso reales del patr√≥n Strategy

Este patr√≥n es extremadamente com√∫n. Algunos casos en el mundo real:

#### üîß En aplicaciones Java/Spring:

- Algoritmos de validaci√≥n de datos (validar distintos tipos de documentos, estrategias de pago, etc.).
- Diferentes formas de env√≠o (email, SMS, push).
- Selecci√≥n de l√≥gica seg√∫n el tipo de usuario, tipo de archivo, estado del negocio, etc.
- Estrategias de serializaci√≥n (JSON, XML, YAML).
- Estrategias de c√°lculo de precios, descuentos, impuestos.

#### üì¶ Ejemplos en librer√≠as/frameworks:

- Spring Security utiliza Strategy para m√∫ltiples mecanismos de autenticaci√≥n.
- Spring usa ConversionService para conversi√≥n de tipos basada en estrategias.
- Comparator de Java es una forma simplificada de Strategy.

### üìê Representaci√≥n UML del patr√≥n Strategy

![01.png](assets/02-java-plano-comportamiento/01.png)

1. La clase `contexto` mantiene una referencia a una de las estrategias concretas y se comunica con este objeto
   √∫nicamente a trav√©s de la `interfaz estrategia`.
2. La `interfaz estrategia` es com√∫n a todas las estrategias concretas. Declara un m√©todo que la clase contexto utiliza
   para ejecutar una estrategia.
3. Las `estrategias concretas` implementan distintas variaciones de un algoritmo que la clase contexto utiliza.
4. La `clase contexto` invoca el m√©todo de ejecuci√≥n en el objeto de estrategia vinculado cada vez que necesita ejecutar
   el algoritmo. La `clase contexto` no sabe con qu√© tipo de estrategia funciona o c√≥mo se ejecuta el algoritmo. La
   `clase contexto` expone un modificador `set()` que permite a los clientes sustituir la estrategia asociada al
   contexto durante el tiempo de ejecuci√≥n.
5. El `cliente` crea un objeto de estrategia espec√≠fico y lo pasa a la clase contexto.

### üéØ Ejemplo 01: Estrategias de pago

`Contexto realista`: Supongamos que queremos aplicar diferentes estrategias de pago: `tarjeta de cr√©dito`, `PayPal` y
`transferencia bancaria`.

Entonces, la implementaci√≥n de nuestro patr√≥n `Strategy` estar√° basado en el siguiente diagrama de clases.

![02.png](assets/02-java-plano-comportamiento/02.png)

### `PaymentStrategy ‚Äì Interfaz de Estrategia`

Esta interfaz define el contrato com√∫n para todas las estrategias de pago. Cada clase que implemente esta interfaz
representar√° una forma distinta de procesar pagos, encapsulando su propia l√≥gica de autenticaci√≥n, validaci√≥n y
ejecuci√≥n del pago.

**Rol en el patr√≥n Strategy**

En el patr√≥n `Strategy`, esta interfaz representa el `Strategy` (la estrategia en s√≠ misma). Define el conjunto de
operaciones intercambiables que el contexto podr√° utilizar din√°micamente sin conocer los detalles internos de cada
implementaci√≥n concreta.

**M√©todos definidos**

- `collectPaymentDetails`
    - Recoge los datos necesarios del usuario seg√∫n el tipo de pago.
    - Se pasa un BufferedReader externo para mantener un solo recurso compartido desde el cliente (buen manejo de
      recursos).
- `validatePaymentDetails`
    - Valida los datos ingresados.
    - Permite que el flujo de pago contin√∫e solo si se ingresaron datos v√°lidos (por ejemplo, autenticaci√≥n exitosa,
      campos no vac√≠os, etc.).
- `pay`
    - Ejecuta el pago seg√∫n la estrategia seleccionada.
    - Devuelve true si el pago fue exitoso, false en caso contrario.

````java
public interface PaymentStrategy {
    void collectPaymentDetails(BufferedReader reader);

    boolean validatePaymentDetails();

    boolean pay(int amount);
}
````

‚úÖ **Buenas pr√°cticas aplicadas**

- `Principio de Abierto/Cerrado (OCP)`: Podemos agregar nuevas estrategias (como `BitcoinPayment`, `ApplePay`, etc.)
  sin modificar el c√≥digo existente.
- `Principio de Responsabilidad √önica (SRP)`: Cada implementaci√≥n concreta se encarga √∫nicamente de su l√≥gica de pago.
- `Desacoplamiento`: El cliente y el contexto no necesitan conocer los detalles espec√≠ficos de cada forma de pago.

### `BankTransferPayment ‚Äì Estrategia concreta`

Esta clase es una implementaci√≥n concreta de la interfaz `PaymentStrategy`. Representa la l√≥gica necesaria para realizar
un pago mediante transferencia bancaria, solicitando datos b√°sicos como titular de cuenta, banco y n√∫mero de cuenta.

**Rol en el patr√≥n Strategy**

En el patr√≥n `Strategy`, esta clase act√∫a como una `Concrete Strategy`. Define una forma espec√≠fica de realizar un pago
siguiendo el contrato com√∫n de la interfaz `PaymentStrategy`. Puede ser intercambiada f√°cilmente con otras estrategias
sin que el cliente o el contexto deban conocer su implementaci√≥n interna.

**Responsabilidades principales**

- Recoger los datos necesarios para realizar una transferencia bancaria.
- Validar que los datos ingresados no est√©n vac√≠os.
- Procesar el pago si la validaci√≥n fue exitosa.

````java

@Slf4j
public class BankTransferPayment implements PaymentStrategy {

    private String accountHolder;
    private String bankName;
    private String accountNumber;
    private boolean detailsProvided;

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Pago por Transferencia Bancaria ===");
        try {
            this.accountHolder = this.prompt(reader, "Ingrese nombre del titular de la cuenta:");
            this.bankName = this.prompt(reader, "Ingrese nombre del banco:");
            this.accountNumber = this.prompt(reader, "Ingrese n√∫mero de cuenta:");
        } catch (IOException exception) {
            log.error("Error al leer datos bancarios: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        this.detailsProvided = this.isValid();
        if (this.detailsProvided) {
            log.info("Detalles bancarios registrados correctamente");
        } else {
            log.error("Faltan datos para procesar la transferencia");
        }
        return this.detailsProvided;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (this.detailsProvided) {
            log.info("Pagando S/ {} por transferencia bancaria a nombre de {} en {}.", paymentAmount, this.accountHolder, this.bankName);
            return true;
        }
        log.warn("No se proporcionaron los datos necesarios para realizar la transferencia");
        return false;
    }

    private boolean isValid() {
        return !accountHolder.isBlank() &&
               !bankName.isBlank() &&
               !accountNumber.isBlank();
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

üß© **Otras estrategias similares**

Tambi√©n se han implementado otras dos estrategias (PayPalPayment y CreditCardPayment), las cuales siguen exactamente el
mismo contrato `PaymentStrategy`, pero adaptan su l√≥gica interna seg√∫n los requisitos de su tipo de pago (por ejemplo,
validaci√≥n con email/contrase√±a en PayPal o datos de tarjeta en CreditCard).

### `PayPalPayment ‚Äì Estrategia concreta`

````java

@Slf4j
public class PayPalPayment implements PaymentStrategy {

    private static final Map<String, String> DATA_BASE = new HashMap<>();

    private String email;
    private String password;
    private boolean signedIn;

    static {
        DATA_BASE.put("martin@gmail.com", "martin");
        DATA_BASE.put("milagros@gmail.com", "123456");
    }

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Autenticaci√≥n PayPal ===");
        try {
            this.email = this.prompt(reader, "Ingrese su email de usuario:");
            this.password = this.prompt(reader, "Ingrese su contrase√±a:");
        } catch (IOException exception) {
            log.error("Error al leer entrada del usuario: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        this.signedIn = Objects.equals(this.password, DATA_BASE.get(email));

        if (this.signedIn) {
            log.info("Inicio de sesi√≥n exitoso");
        } else {
            log.error("Email o password incorrectos");
        }
        return this.signedIn;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (this.signedIn) {
            log.info("Pagando S/ {} con PayPal (usuario: {})", paymentAmount, this.email);
            return true;
        }
        log.warn("El usuario no ha iniciado sesi√≥n correctamente. No se puede realizar el pago");
        return false;
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

### `CreditCardPayment ‚Äì Estrategia concreta`

````java

@ToString
public class CreditCard {
    @Getter
    private final String number;
    @Getter
    private final String expiry;
    @Getter
    private final String cvv;
    @Getter
    @Setter
    private int amount = 100_000; //Simula saldo de la tarjeta

    public CreditCard(String number, String expiry, String cvv) {
        this.number = number;
        this.expiry = expiry;
        this.cvv = cvv;
    }

}
````

````java

@Slf4j
public class CreditCardPayment implements PaymentStrategy {

    private CreditCard creditCard;

    @Override
    public void collectPaymentDetails(BufferedReader reader) {
        log.info("=== Ingreso de datos de tarjeta de cr√©dito ===");
        try {
            String number = this.prompt(reader, "Ingrese n√∫mero de tarjeta:");
            String expiry = this.prompt(reader, "Ingrese fecha de expiraci√≥n (mm/yy):");
            String cvv = this.prompt(reader, "Ingrese c√≥digo cvv:");
            this.creditCard = new CreditCard(number, expiry, cvv);
        } catch (IOException exception) {
            log.error("Error al leer datos de la tarjeta: {}", exception.getMessage());
        }
    }

    @Override
    public boolean validatePaymentDetails() {
        log.info("Validando tarjeta...");
        if (this.validateCard(this.creditCard)) {
            log.info("Tarjeta v√°lida: {}", creditCard);
            return true;
        }

        log.error("Datos de tarjeta inv√°lidos");
        this.creditCard = null;
        return false;
    }

    @Override
    public boolean pay(int paymentAmount) {
        if (!this.cardIsPresent()) {
            log.warn("No hay tarjeta registrada. No se puede procesar el pago");
            return false;
        }

        if (this.creditCard.getAmount() < paymentAmount) {
            log.warn("Fondos insuficientes en la tarjeta. Monto disponible: S/ {}", this.creditCard.getAmount());
            return false;
        }

        this.creditCard.setAmount(this.creditCard.getAmount() - paymentAmount);
        log.info("Pagando S/ {} con tarjeta de cr√©dito (Saldo restante: S/ {})", paymentAmount, this.creditCard.getAmount());
        return true;

    }

    private boolean validateCard(CreditCard card) {
        return !card.getNumber().isBlank() &&
               !card.getExpiry().isBlank() &&
               !card.getCvv().isBlank();
    }

    private boolean cardIsPresent() {
        return Objects.nonNull(this.creditCard);
    }

    private String prompt(BufferedReader reader, String message) throws IOException {
        log.info(message);
        return reader.readLine().trim();
    }
}
````

### `PaymentContext ‚Äì Contexto del patr√≥n Strategy`

Esta clase representa el `Contexto` en el patr√≥n `Strategy`. Su principal funci√≥n es mantener una referencia a una
estrategia concreta de pago (`PaymentStrategy`) y delegar en ella la ejecuci√≥n de las operaciones correspondientes.

````java

@Slf4j
public class PaymentContext {

    private PaymentStrategy paymentStrategy;

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void collectPaymentDetails(BufferedReader reader) {
        this.validateStrategy();
        this.paymentStrategy.collectPaymentDetails(reader);
    }

    public boolean validatePaymentDetails() {
        this.validateStrategy();
        return this.paymentStrategy.validatePaymentDetails();
    }

    public boolean pay(int amount) {
        this.validateStrategy();
        return this.paymentStrategy.pay(amount);
    }

    private void validateStrategy() {
        if (Objects.isNull(this.paymentStrategy)) {
            throw new IllegalStateException("No se ha definido una estrategia de pago");
        }
    }
}
````

**Rol en el patr√≥n Strategy**

- Act√∫a como Contexto, que es responsable de usar una estrategia (`PaymentStrategy`) definida din√°micamente en tiempo
  de ejecuci√≥n.
- No conoce los detalles de implementaci√≥n de cada estrategia, s√≥lo interact√∫a a trav√©s de la interfaz com√∫n.
- Encapsula la variaci√≥n del algoritmo delegando el comportamiento a una instancia concreta de la estrategia.

**Responsabilidades**

- Recibir la estrategia a utilizar (`setPaymentStrategy(...)`).
- Delegar la ejecuci√≥n de los m√©todos `collectPaymentDetails()`, `validatePaymentDetails()` y `pay()` a la estrategia
  asignada.
- Validar que una estrategia haya sido definida antes de delegar cualquier operaci√≥n.

**Beneficios**

- Cumple con el principio de `abierto/cerrado (OCP)`: se pueden agregar nuevas estrategias sin modificar esta clase.
- Sigue el principio de `inversi√≥n de dependencias (DIP)`: el contexto depende de una abstracci√≥n (`PaymentStrategy`),
  no de implementaciones concretas.

**Consideraciones**

- El contexto no necesita saber cu√°l es la l√≥gica de cada estrategia concreta. Puede operar de forma gen√©rica gracias a
  la interfaz.
- Si en un futuro se agregan validaciones adicionales (como logging o auditor√≠a), podr√≠an centralizarse tambi√©n aqu√≠,
  manteniendo la estrategia limpia.

### `üßë‚Äçüíª Cliente: Main`

Este `cliente (Main`) es el punto de entrada de la aplicaci√≥n y cumple el rol de coordinador que configura el contexto
del `patr√≥n Strategy`.

Responsabilidades clave:

- ‚úÖ Solicita al usuario que elija el m√©todo de pago (PayPal, transferencia o tarjeta).
- ‚úÖ Crea la estrategia concreta correspondiente (PaymentStrategy) y la inyecta al contexto (PaymentContext).
- ‚úÖ Coordina la recolecci√≥n de datos del usuario, con hasta 3 intentos para validarlos.
- ‚úÖ Solicita el monto a pagar.
- ‚úÖ Ejecuta el m√©todo pay de la estrategia activa, a trav√©s del contexto.

El cliente no necesita conocer los detalles de implementaci√≥n de cada tipo de pago. Simplemente, selecciona una
estrategia en tiempo de ejecuci√≥n y el `PaymentContext` se encarga de delegar las operaciones de manera polim√≥rfica.

````java

@Slf4j
public class Main {
    public static void main(String[] args) throws IOException {
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(System.in))) {
            PaymentContext context = new PaymentContext();

            log.info("=== Sistema de Pagos ===");
            log.info("Elija el m√©todo de pago:");
            log.info("1. PayPal");
            log.info("2. Transferencia Bancaria");
            log.info("3. Tarjeta de Cr√©dito");

            String option = reader.readLine().trim();
            switch (option) {
                case "1" -> context.setPaymentStrategy(new PayPalPayment());
                case "2" -> context.setPaymentStrategy(new BankTransferPayment());
                case "3" -> context.setPaymentStrategy(new CreditCardPayment());
                default -> {
                    log.warn("Opci√≥n inv√°lida");
                    return;
                }
            }

            final int maxAttempts = 3;
            boolean isValid = false;

            for (int attempts = 1; attempts <= maxAttempts; attempts++) {
                log.info("Intento {}/{}", attempts, maxAttempts);
                context.collectPaymentDetails(reader);

                if (context.validatePaymentDetails()) {
                    isValid = true;
                    break;
                }
            }

            if (!isValid) {
                log.warn("Se consumieron todos los intentos. Int√©ntelo m√°s tarde.");
                return;
            }

            log.info("Ingrese el monto a pagar:");
            int amount = Integer.parseInt(reader.readLine().trim());

            if (context.pay(amount)) {
                log.info("Pago realizado con √©xito");
            } else {
                log.info("El pago no se pudo procesar");
            }
        }
    }
}
````

---

## Template Method

El patr√≥n `Template Method` es un patr√≥n de comportamiento que define la `estructura de un algoritmo` en una
clase base, delegando la `implementaci√≥n de algunos pasos` a las subclases. Es ideal cuando tienes una l√≥gica que
sigue siempre un mismo flujo general, pero `algunos pasos deben ser personalizados`.

### üß© Caracter√≠sticas clave

- Utiliza una clase abstracta con un m√©todo `‚Äúplantilla‚Äù` (`templateMethod()`), que define los pasos del algoritmo.
- Algunos pasos son implementados directamente en la clase base, mientras que otros se declaran como m√©todos abstractos
  para que las subclases los definan.
- Fomenta el principio de Hollywood: "Don‚Äôt call us, we‚Äôll call you" ‚Äî es decir, la clase base controla el flujo general

### üîß ¬øCu√°ndo usar el patr√≥n Template Method?

Usa este patr√≥n cuando:

- Tienes m√∫ltiples clases que comparten una secuencia de pasos, pero cada una implementa los pasos de forma diferente.
- Deseas evitar duplicaci√≥n de c√≥digo al mantener la l√≥gica com√∫n en una clase base.
- Quieres estandarizar un proceso, pero necesitas que ciertas partes sean personalizables.

### üìå Ejemplos de la vida real

- `Proceso de carga de archivos`:
    - *Validar archivo ‚Üí Leer contenido ‚Üí Procesar datos ‚Üí Guardar resultado*. Cada tipo de archivo (CSV, XML, JSON)
      implementa su propia l√≥gica de lectura y procesamiento.


- `Juego`:
    - *Inicializar juego ‚Üí Jugar turno ‚Üí Mostrar resultados*. Cada juego tiene sus propias reglas, pero la estructura
      general del flujo es la misma.


- `Conexi√≥n a una base de datos`:
    - *Abrir conexi√≥n ‚Üí Ejecutar operaci√≥n ‚Üí Cerrar conexi√≥n*. El paso de `‚Äúejecutar operaci√≥n‚Äù` puede variar (insertar,
      actualizar, consultar).

### ‚úÖ Ventajas

- Reutilizaci√≥n de c√≥digo: l√≥gica com√∫n centralizada.
- Fomenta el principio "Open/Closed": el algoritmo base est√° cerrado a modificaciones, pero abierto a extensiones.
- Mejora la legibilidad y mantenibilidad.

### ‚ùå Desventajas

- Aumenta el acoplamiento entre la clase base y las subclases.
- Puede haber rigidez si se necesitan muchos pasos personalizados.

### üìê Representaci√≥n UML del patr√≥n Template Method

![03.png](assets/02-java-plano-comportamiento/03.png)

1. La `Clase Abstracta` declara m√©todos que act√∫an como pasos de un algoritmo.
    - Define el m√©todo plantilla (`templateMethod`) que contiene el flujo general del algoritmo.
    - Puede incluir m√©todos:
        - `abstractos` (obligan a la subclase a implementar).
        - `concretos` (implementados en la clase abstracta).
        - `hooks` (m√©todos opcionales que las subclases pueden sobreescribir si lo desean).
2. Las `Clases Concretas`:
    - Implementan los pasos abstractos definidos por la clase abstracta.
    - Pueden redefinir m√©todos hook si necesitan cambiar parte del comportamiento.

### Sobre los Hooks

Los `hooks` son efectivamente m√©todos concretos, pero tienen una caracter√≠stica especial:
`est√°n dise√±ados espec√≠ficamente para ser sobrescritos opcionalmente`.
La diferencia clave es la `intenci√≥n y el dise√±o`:

- `M√©todos concretos normales`
    - Implementan l√≥gica de negocio real
    - No est√°n pensados para ser sobrescritos
    - Si los sobrescribes, pierdes funcionalidad importante

- `Hooks`
    - Tienen implementaci√≥n vac√≠a o muy b√°sica por defecto
    - Su prop√≥sito es ser "puntos de extensi√≥n opcionales"
    - Permiten a las subclases "engancharse" en momentos espec√≠ficos del algoritmo

`Ejemplo pr√°ctico`. Los hooks te dan flexibilidad sin forzar a todas las subclases a implementarlos.

````java
public abstract class DataProcessor {

    // Template method
    public final void processData() {
        loadData();
        beforeValidation(); // <- HOOK
        validateData();
        afterValidation();  // <- HOOK
        logProcessingResult(); // <- M√âTODO CONCRETO NORMAL
        saveData();
    }

    // M√©todos abstractos (obligatorios)
    protected abstract void loadData();

    protected abstract void validateData();

    protected abstract void saveData();

    // M√âTODOS CONCRETOS NORMALES (no pensados para sobrescribir)
    protected void logProcessingResult() {
        System.out.println("Processing completed at: " + new Date());
    }

    protected boolean isDataValid() {
        // L√≥gica com√∫n de validaci√≥n b√°sica
        return true;
    }

    // HOOKS (opcionales - implementaci√≥n vac√≠a/b√°sica por defecto)
    protected void beforeValidation() {
        // Implementaci√≥n vac√≠a - punto de extensi√≥n opcional
    }

    protected void afterValidation() {
        // Implementaci√≥n vac√≠a - punto de extensi√≥n opcional
    }
}
````

En resumen, los m√©todos:

- `Abstractos`: deben implementarse.
- `Concretos normales`: l√≥gica com√∫n, no pensados para sobrescribir.
- `Hooks`: puntos de extensi√≥n opcionales.

### üéØ Ejemplo 01: Sistema de Procesamiento de Archivos Empresarial

üìå`Contexto empresarial`

En entornos corporativos, es habitual recibir archivos de entrada con informaci√≥n estructurada para ser procesada e
integrada en sistemas internos. Estos archivos pueden variar ampliamente en cuanto a formato y estructura (por ejemplo,
.txt, .csv, .xml), pero comparten una secuencia de pasos com√∫n para su procesamiento:

### üõ†Ô∏è Flujo t√≠pico de procesamiento

1. `Carga del archivo` desde una fuente (sistema local, red, FTP, etc.).
2. `Validaci√≥n` del archivo: verificar estructura, encabezados, formato de columnas, etc.
3. `Lectura` del contenido (l√≠nea por l√≠nea, por nodo, etc.).
4. `Conversi√≥n` a estructuras de datos manejables dentro del sistema.
5. `Persistencia` o simulaci√≥n del guardado en una base de datos.
6. `Notificaci√≥n` del resultado (√©xito, errores, estad√≠sticas).

A pesar de la diversidad de formatos y reglas, el flujo general es invariable. Este escenario encaja perfectamente con
el patr√≥n `Template Method`, ya que:

> üîÅ Permite definir un algoritmo esquel√©tico com√∫n en una clase abstracta y delegar en las subclases los pasos
> espec√≠ficos que pueden variar seg√∫n el tipo de archivo.

Entonces, la implementaci√≥n de nuestro patr√≥n `Template Method` estar√° basado en el siguiente diagrama de clases.

![04.png](assets/02-java-plano-comportamiento/04.png)

### üì¶ Clases de apoyo

````java
public interface ParsedRecord {
}
````

- `Prop√≥sito`: interfaz de marcador para representar un registro procesado en memoria.
- `Uso`: cada tipo de archivo tendr√° su propia clase que implemente esta interfaz (`TxtRecord`, `CsvRecord`, etc.).

````java
public record ProcessResult(String batchId,
                            boolean success,
                            String errorMessage,
                            int totalRecords,
                            int processedRecords,
                            int invalidRecords) {

    public static ProcessResult success(String batchId, int total, int processed, int invalid) {
        return new ProcessResult(batchId, true, null, total, processed, invalid);
    }

    public static ProcessResult failure(String batchId, String errorMessage) {
        return new ProcessResult(batchId, false, errorMessage, 0, 0, 0);
    }
}
````

- `Prop√≥sito`: encapsula el resultado del procesamiento de un lote de archivos.

````java
public record ValidationResult(boolean valid,
                               String errorMessage) {

    public static ValidationResult success() {
        return new ValidationResult(true, null);
    }

    public static ValidationResult failure(String errorMessage) {
        return new ValidationResult(false, errorMessage);
    }
}
````

- `Prop√≥sito`: representa el resultado de la validaci√≥n estructural del archivo.
- `Permite`: distinguir entre archivos v√°lidos e inv√°lidos antes de iniciar el procesamiento detallado.

````java
public record BusinessValidationResult<T extends ParsedRecord>(List<T> validRecords,
                                                               int invalidCount) {
}
````

- `Prop√≥sito`: encapsula el resultado de la validaci√≥n de reglas de negocio aplicadas a los registros.
- Incluye:
    - Registros v√°lidos que se pueden procesar.
    - Conteo de registros inv√°lidos por fallas en reglas internas (por ejemplo, campos obligatorios faltantes).

### üß± Clase Abstracta: `FileProcessor<T extends ParsedRecord>`

Esta clase define el algoritmo base para procesar archivos de distintos formatos, representando fielmente el patr√≥n
`Template Method`.

### üß© Rol en el patr√≥n Template Method

- `Clase abstracta base (Template)`: Define el esqueleto del algoritmo con un m√©todo `final`, `processFile(...)`, que
  orquesta el proceso completo. Se declara como `final` para preservar la integridad del algoritmo, evitando que las
  subclases alteren el flujo principal y asegurando un comportamiento consistente.
- `Subclases concretas`: Deber√°n implementar √∫nicamente las partes variables (m√©todos abstractos), manteniendo intacto
  el flujo general.
- `Ventaja`: Evita duplicaci√≥n de l√≥gica com√∫n entre procesadores de archivos distintos, y facilita la extensi√≥n
  mediante herencia.

### üîÅ M√©todo plantilla: `processFile(String filePath, String batchId)`

Este es el `template method`. Define la secuencia exacta de pasos a seguir para procesar cualquier archivo. Los pasos
son:

1. Obtener el archivo con `obtainFile(...)` (concreto y reutilizable).
2. Validar la estructura del archivo, mediante `validateFileStructure(...)` (abstracto).
3. Parsear el contenido, l√≠nea por l√≠nea o seg√∫n el formato, con `parseFileContent(...)` (abstracto).
4. Aplicar validaciones de negocio a los registros parseados: `validateBusinessRules(...)` (abstracto).
5. Almacenar los registros v√°lidos: `storeRecords(...)` (abstracto).
6. Generar un reporte final del procesamiento: `generateProcessingReport(...)` (concreto).

El m√©todo `processFile(...)` tambi√©n maneja errores, logs y encapsula el resultado en un `ProcessResult`, cumpliendo as√≠
un flujo robusto y controlado.

````java

@Slf4j
public abstract class FileProcessor<T extends ParsedRecord> {

    public final ProcessResult processFile(String filePath, String batchId) {
        try {
            log.info("=== Iniciando procesamiento de archivo ===");
            log.info("Archivo: {} - Batch ID: {}", filePath, batchId);

            // Paso 1: Obtener y validar archivo
            Optional<Path> optionalPath = this.obtainFile(filePath);
            if (optionalPath.isEmpty()) {
                return ProcessResult.failure(batchId, "Archivo no encontrado o inaccesible");
            }

            // Paso 2: Validar estructura del archivo
            Path path = optionalPath.get();
            ValidationResult validation = this.validateFileStructure(path);
            if (!validation.valid()) {
                return ProcessResult.failure(batchId, "Validaci√≥n fallida: ".concat(validation.errorMessage()));
            }

            // Paso 3: Procesar el contenido l√≠nea por l√≠nea
            List<T> parsedRecords = this.parseFileContent(path);
            if (parsedRecords.isEmpty()) {
                return ProcessResult.failure(batchId, "El archivo est√° vac√≠o o no contiene registros procesables");
            }
            int totalRecords = parsedRecords.size();

            // Paso 4: Validar datos de negocio
            BusinessValidationResult<T> businessValidationResult = this.validateBusinessRules(parsedRecords);
            List<T> validRecords = businessValidationResult.validRecords();
            int invalidCount = businessValidationResult.invalidCount();
            int processedRecords = 0;

            // Paso 5: Persistir en base de datos
            ProcessResult result;
            if (!validRecords.isEmpty()) {
                processedRecords = this.storeRecords(validRecords, batchId);
                result = ProcessResult.success(batchId, totalRecords, processedRecords, invalidCount);
            } else {
                result = ProcessResult.failure(batchId, "No se encontraron registros v√°lidos para almacenar.");
            }

            // Paso 6: Generar notificaci√≥n final
            this.generateProcessingReport(result, path);

            if (result.success()) {
                log.info("Procesamiento finalizado exitosamente. Registros procesados: {}", result.processedRecords());
            } else {
                log.warn("Procesamiento finalizado con errores. Motivo: {}", result.errorMessage());
            }
            return result;
        } catch (Exception e) {
            log.error("Error durante procesamiento: {}", e.getMessage(), e);
            return ProcessResult.failure(batchId, "Error t√©cnico: " + e.getMessage());
        }
    }

    // ============== M√âTODOS CONCRETOS (comunes a todos los tipos) ==============
    protected Optional<Path> obtainFile(String filePath) {
        try {
            Path path = Path.of(filePath);

            if (Files.notExists(path) || !Files.isReadable(path)) {
                log.warn("El archivo no existe o no es legible: {}", filePath);
                return Optional.empty();
            }

            log.info("Archivo obtenido exitosamente. Tama√±o: {} bytes", Files.size(path));
            return Optional.of(path);
        } catch (Exception e) {
            log.warn("Error obtenido en archivo: {}", e.getMessage());
            return Optional.empty();
        }
    }

    protected void generateProcessingReport(ProcessResult result, Path path) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String format = LocalDateTime.now().format(formatter);

        String fileName = path.getFileName().toString();
        int index = fileName.lastIndexOf(".");
        String extension = fileName.substring(index + 1).toUpperCase();

        String state;
        if (!result.success()) {
            state = "Error";
        } else if (result.invalidRecords() > 0) {
            state = "Exitoso con advertencias";
        } else {
            state = "Exitoso";
        }

        StringBuilder sb = new StringBuilder("=== REPORTE DE PROCESAMIENTO %s ===".formatted(extension));
        sb.append("\n");
        sb.append("Archivo: ").append(path.toAbsolutePath()).append("\n");
        sb.append("Batch Id: ").append(result.batchId()).append("\n");
        sb.append("Fecha/Hora: ").append(format).append("\n");
        sb.append("Total registros: ").append(result.totalRecords()).append("\n");
        sb.append("Registros procesados: ").append(result.processedRecords()).append("\n");
        sb.append("Registros inv√°lidos: ").append(result.invalidRecords()).append("\n");
        sb.append("Estado: ").append(state);

        log.info("REPORTE {}:\n{}", extension, sb);
    }

    // ============== M√âTODOS ABSTRACTOS (espec√≠ficos por tipo de archivo) ==============
    protected abstract ValidationResult validateFileStructure(Path path);

    protected abstract List<T> parseFileContent(Path path) throws IOException;

    protected abstract BusinessValidationResult<T> validateBusinessRules(List<T> parsedRecords);

    protected abstract int storeRecords(List<T> validRecords, String batchId) throws SQLException;
}
````

### üìå Conclusi√≥n

La clase `FileProcessor<T>` aplica correctamente el patr√≥n `Template Method` al:

- Establecer un flujo fijo de procesamiento de archivos.
- Permitir la personalizaci√≥n de pasos espec√≠ficos mediante m√©todos abstractos.
- Reutilizar l√≥gica com√∫n que no debe duplicarse en cada subclase.

Este dise√±o garantiza coherencia, extensibilidad y bajo acoplamiento entre las diferentes estrategias de procesamiento
de archivos.

### üß™ Clase Concreta: `TxtDelimitedProcessor`

### üß© Rol en el patr√≥n Template Method

- Esta clase representa una implementaci√≥n concreta del algoritmo definido en la clase abstracta `FileProcessor<T>`.
- Hereda el flujo de procesamiento general definido por `processFile(...)` y especializa los pasos que dependen del
  formato TXT delimitado.
- Utiliza un DTO propio (`TxtRecord`) que implementa la interfaz com√∫n `ParsedRecord`.

````java
public record TxtRecord(String id,
                        String accountNumber,
                        double amount,
                        LocalDateTime transactionDate,
                        String description) implements ParsedRecord {
}
````

- Define la estructura de un registro TXT con 5 campos.
- Sirve como tipo gen√©rico `T` para la clase base `FileProcessor<T>`.
- Los campos son representativos de una transacci√≥n financiera, lo cual contextualiza bien su uso empresarial.

### ‚öôÔ∏è Especializaci√≥n de pasos en `TxtDelimitedProcessor`

1. `validateFileStructure(Path path)`, este paso permite adaptar el procesamiento a diferentes configuraciones de TXT
   sin modificar el flujo principal.
2. `parseFileContent(Path path)`, este m√©todo transforma los datos crudos del archivo en registros estructurados que
   ser√°n validados y persistidos.
3. `validateBusinessRules(List<TxtRecord>)`, este paso demuestra c√≥mo las reglas pueden variar por tipo de archivo o
   dominio, pero seguir encajando en el flujo com√∫n.
4. `storeRecords(List<TxtRecord>, String batchId)`, aunque no se persiste en una base de datos real, este paso es √∫til
   para pruebas y demuestra c√≥mo podr√≠a extenderse f√°cilmente.

````java

@Slf4j
@RequiredArgsConstructor
public class TxtDelimitedProcessor extends FileProcessor<TxtRecord> {

    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    private final String delimiter;
    private final boolean hasHeader;
    private final int expectedColumns;

    @Override
    protected ValidationResult validateFileStructure(Path path) {
        try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(path))) {
            String firstLine = reader.readLine();

            if (Objects.isNull(firstLine) || firstLine.isBlank()) {
                return ValidationResult.failure("Archivo vac√≠o");
            }

            // Si el archivo tiene encabezado, validamos que al menos tenga expectedColumns,
            // pero no validamos el contenido de datos a√∫n.
            String[] columns = firstLine.split(Pattern.quote(this.delimiter));
            if (this.hasHeader) {
                if (columns.length < this.expectedColumns) {
                    return ValidationResult.failure("La cabecera debe tener al menos %d columnas separadas por '%s'"
                            .formatted(this.expectedColumns, this.delimiter));
                }
                log.info("Cabecera detectada. Columnas encontradas: {}", columns.length);
            } else {
                // Si no hay cabecera, consideramos que la primera l√≠nea ya es un registro
                if (columns.length != this.expectedColumns) {
                    return ValidationResult.failure("La primera l√≠nea debe tener exactamente %d columnas separadas por '%s'"
                            .formatted(this.expectedColumns, this.delimiter));
                }
                log.info("No se detect√≥ cabecera. Validando estructura de la primera l√≠nea de datos: {} columnas", columns.length);
            }

            return ValidationResult.success();
        } catch (IOException e) {
            return ValidationResult.failure("Error al leer el archivo: %s".formatted(e.getMessage()));
        }
    }

    @Override
    protected List<TxtRecord> parseFileContent(Path path) throws IOException {
        List<TxtRecord> records = new ArrayList<>();

        try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(path))) {
            int lineNumber = 0;

            if (this.hasHeader) {
                String headers = reader.readLine();
                log.info("headers: {}", headers);
                lineNumber++;
            }

            String line;
            while ((line = reader.readLine()) != null) {
                lineNumber++;

                if (line.trim().isEmpty()) {
                    log.warn("L√≠nea {} vac√≠a e ignorada", lineNumber);
                    continue;
                }

                try {
                    String[] fields = line.split(Pattern.quote(this.delimiter));
                    if (fields.length == this.expectedColumns) {
                        TxtRecord txtRecord = new TxtRecord(
                                "TXT_" + lineNumber,
                                fields[0].trim(),
                                Double.parseDouble(fields[1].trim()),
                                LocalDateTime.parse(fields[2].trim(), DATE_TIME_FORMATTER),
                                fields[3].trim()
                        );
                        records.add(txtRecord);
                    } else {
                        log.warn("L√≠nea {} ignorada: se esperaban {} columnas pero se encontraron {}", lineNumber, expectedColumns, fields.length);
                    }
                } catch (Exception e) {
                    log.warn("Error procesando l√≠nea {}: {}", lineNumber, e.getMessage());
                }
            }
        }

        log.info("Parsing TXT completado: {} registros extra√≠dos", records.size());
        return records;
    }

    @Override
    protected BusinessValidationResult<TxtRecord> validateBusinessRules(List<TxtRecord> parsedRecords) {
        List<TxtRecord> validRecords = parsedRecords.stream()
                .filter(txtRecord -> {
                    boolean isValid = true;

                    if (txtRecord.accountNumber() == null || txtRecord.accountNumber().isBlank()) {
                        log.warn("Registro inv√°lido {}: accountNumber vac√≠o", txtRecord.id());
                        isValid = false;
                    }

                    if (txtRecord.amount() <= 0) {
                        log.warn("Registro inv√°lido {}: amount debe ser mayor que 0", txtRecord.id());
                        isValid = false;
                    }

                    return isValid;
                })
                .toList();
        int invalidCount = parsedRecords.size() - validRecords.size();
        return new BusinessValidationResult<>(validRecords, invalidCount);
    }

    @Override
    protected int storeRecords(List<TxtRecord> validRecords, String batchId) throws SQLException {
        validRecords.forEach(txtRecord -> {
            String sql = """
                        INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
                        VALUES ('%s', '%s', %.2f, '%s', '%s', '%s')
                    """.formatted(
                    txtRecord.id(),
                    txtRecord.accountNumber(),
                    txtRecord.amount(),
                    txtRecord.transactionDate(),
                    txtRecord.description(),
                    batchId
            );

            log.info("SQL simulada: {}", sql);
        });


        log.info("Se simularon {} inserciones en la tabla transactions_txt.", validRecords.size());
        return validRecords.size();
    }
}
````

### üß† Consideraciones clave

- Esta clase permite procesar archivos `.txt` con estructura delimitada sin modificar el algoritmo principal.
- Los par√°metros de configuraci√≥n (delimiter, hasHeader, expectedColumns) ofrecen flexibilidad sin sacrificar el orden
  del proceso.
- Gracias al patr√≥n `Template Method`, podr√≠as a√±adir nuevos formatos (como CSV, XML, JSON) simplemente creando nuevas
  subclases como esta.

### üß™ Clase Concreta: `CsvDelimitedProcessor`

### üß© Rol en el patr√≥n Template Method

- Esta clase representa otra implementaci√≥n concreta de la plantilla `FileProcessor<T>`, especializada en archivos
  `.csv`.
- A diferencia del procesador TXT, aqu√≠ se asume que todos los CSV tienen cabecera, lo cual afecta principalmente la
  validaci√≥n y el parseo.

````java
public record CsvRecord(String id,
                        String firstName,
                        String lastName,
                        String email,
                        LocalDate registrationDate) implements ParsedRecord {
}
````

üîé Este DTO implementa la interfaz com√∫n `ParsedRecord`, asegurando compatibilidad con el algoritmo base en
`FileProcessor<T>`.

### üõ†Ô∏è Consideraciones

| M√©todo a implementar         | Comportamiento esperado                                                        |
|------------------------------|--------------------------------------------------------------------------------|
| `validateFileStructure(...)` | Verificar que exista una cabecera con al menos 5 columnas separadas por comas. |
| `parseFileContent(...)`      | Leer el archivo omitiendo la cabecera y mapear cada l√≠nea a `CsvRecord`.       |
| `validateBusinessRules(...)` | Validar campos como: email no vac√≠o, fecha v√°lida, nombres no nulos.           |
| `storeRecords(...)`          | Simular la inserci√≥n en una tabla `users_csv`, generando SQL de prueba.        |

````java
//Asumimos que todos los .csv que vamos a procesar tienen cabecera

@Slf4j
@RequiredArgsConstructor
public class CsvDelimitedProcessor extends FileProcessor<CsvRecord> {

    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    private static final int EXPECTED_COLUMNS = 5;
    private static final String DELIMITER = ",";

    @Override
    protected ValidationResult validateFileStructure(Path path) {
        try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(path))) {
            String firstLine = reader.readLine();

            if (Objects.isNull(firstLine) || firstLine.isBlank()) {
                return ValidationResult.failure("Archivo vac√≠o");
            }

            String[] columns = firstLine.split(Pattern.quote(DELIMITER));
            if (columns.length != EXPECTED_COLUMNS) {
                return ValidationResult.failure("El encabezado debe tener exactamente 5 columnas separadas por coma");
            }

            log.info("Encabezado CSV detectado correctamente: {} columnas", columns.length);
            return ValidationResult.success();
        } catch (IOException e) {
            return ValidationResult.failure("Error al leer el archivo: %s".formatted(e.getMessage()));
        }
    }

    @Override
    protected List<CsvRecord> parseFileContent(Path path) throws IOException {
        List<CsvRecord> records = new ArrayList<>();

        try (BufferedReader reader = new BufferedReader(Files.newBufferedReader(path))) {
            int lineNumber = 0;

            // Saltamos la cabecera
            String headers = reader.readLine();
            log.info("headers: {}", headers);

            String line;
            while ((line = reader.readLine()) != null) {
                lineNumber++;

                if (line.trim().isEmpty()) {
                    log.warn("L√≠nea {} vac√≠a e ignorada", lineNumber);
                    continue;
                }

                try {
                    String[] fields = line.split(Pattern.quote(DELIMITER));
                    if (fields.length == EXPECTED_COLUMNS) {
                        CsvRecord csvRecord = new CsvRecord(
                                fields[0].trim(),
                                fields[1].trim(),
                                fields[2].trim(),
                                fields[3].trim(),
                                LocalDateTime.parse(fields[4].trim(), DATE_TIME_FORMATTER).toLocalDate()
                        );
                        records.add(csvRecord);
                    } else {
                        log.warn("L√≠nea {} ignorada: se esperaban {} columnas pero se encontraron {}", lineNumber, EXPECTED_COLUMNS, fields.length);
                    }
                } catch (Exception e) {
                    log.warn("Error procesando l√≠nea {}: {}", lineNumber, e.getMessage());
                }
            }
        }

        log.info("Parsing CSV completado: {} registros extra√≠dos", records.size());
        return records;
    }

    @Override
    protected BusinessValidationResult<CsvRecord> validateBusinessRules(List<CsvRecord> parsedRecords) {
        List<CsvRecord> validRecords = parsedRecords.stream()
                .filter(csvRecord -> {
                    boolean isValid = true;

                    if (Objects.isNull(csvRecord.firstName()) || csvRecord.firstName().isBlank()) {
                        log.warn("Registro inv√°lido ID {}: firstName vac√≠o", csvRecord.id());
                        isValid = false;
                    }

                    if (Objects.isNull(csvRecord.lastName()) || csvRecord.lastName().isBlank()) {
                        log.warn("Registro inv√°lido ID {}: lastName vac√≠o", csvRecord.id());
                        isValid = false;
                    }

                    if (Objects.isNull(csvRecord.email()) || !csvRecord.email().contains("@")) {
                        log.warn("Registro inv√°lido ID {}: email inv√°lido ({})", csvRecord.id(), csvRecord.email());
                        isValid = false;
                    }

                    if (Objects.nonNull(csvRecord.registrationDate()) && csvRecord.registrationDate().isAfter(LocalDate.now())) {
                        log.warn("Registro inv√°lido ID {}: fecha de registro futura ({})", csvRecord.id(), csvRecord.registrationDate());
                        isValid = false;
                    }

                    return isValid;
                })
                .toList();
        int invalidCount = parsedRecords.size() - validRecords.size();
        return new BusinessValidationResult<>(validRecords, invalidCount);
    }

    @Override
    protected int storeRecords(List<CsvRecord> validRecords, String batchId) throws SQLException {
        validRecords.forEach(csvRecord -> {
            String sql = """
                        INSERT INTO users_csv (id, first_name, last_name, email, registration_date, batch_id)
                        VALUES ('%s', '%s', '%s', '%s', '%s', '%s')
                    """.formatted(
                    csvRecord.id(),
                    csvRecord.firstName(),
                    csvRecord.lastName(),
                    csvRecord.email(),
                    csvRecord.registrationDate(),
                    batchId
            );
            log.info("SQL simulada: {}", sql);
        });


        log.info("Se simularon {} inserciones en la tabla users_csv.", validRecords.size());
        return validRecords.size();
    }
}
````

### üß† Observaciones

- Al implementar esta clase, se ve claramente c√≥mo el patr√≥n `Template Method` permite adaptar la l√≥gica a un nuevo tipo
  de archivo sin duplicar el flujo principal.
- Cada subclase concreta se encarga de sus detalles de validaci√≥n, parseo y persistencia, manteniendo cohesi√≥n.

### üöÄ Clase Cliente: Main

### üß© Rol en el patr√≥n Template Method

- Esta clase es el cliente que utiliza el patr√≥n `Template Method`, delegando el procesamiento de archivos a las
  subclases concretas de `FileProcessor<T>`.
- No necesita conocer el detalle de c√≥mo se procesan internamente los archivos, solo ejecuta el m√©todo
  `processFile(...)`, demostrando el principio de inversi√≥n de dependencias.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        FileProcessor<TxtRecord> txtProcessor = new TxtDelimitedProcessor("|", false, 4);
        String txtFilePath = "src/main/resources/sample-files/sample_transactions.txt";
        String txtBatchId = "BATCH_" + System.currentTimeMillis();
        ProcessResult txtResult = txtProcessor.processFile(txtFilePath, txtBatchId);
        printResult(txtResult);

        log.info("\n\n");

        FileProcessor<CsvRecord> csvProcessor = new CsvDelimitedProcessor();
        String csvFilePath = "src/main/resources/sample-files/sample_users.csv";
        String csvBatchId = "BATCH_" + System.currentTimeMillis();
        ProcessResult csvResult = csvProcessor.processFile(csvFilePath, csvBatchId);
        printResult(csvResult);
    }

    private static void printResult(ProcessResult result) {
        log.info(result.toString());
    }
}
````

### üìå Conclusi√≥n

Esta clase demuestra uno de los beneficios clave del patr√≥n `Template Method`:

> ‚úÖ El cliente puede invocar el mismo m√©todo (`processFile(...)`) sin importar las diferencias internas entre formatos
> de archivo.

Adem√°s, permite probar f√°cilmente nuevas subclases (como un futuro `JsonProcessor` o `XmlProcessor`) sin cambiar nada
en el cliente, lo que promueve la extensibilidad y el bajo acoplamiento.

### ‚úÖ Resultado de ejecuci√≥n: `TxtDelimitedProcessor`

Este resultado muestra la traza completa del procesamiento de un archivo `.txt` con registros de transacciones
financieras, utilizando el flujo definido en la clase abstracta `FileProcessor<T>` y especializado en la subclase
`TxtDelimitedProcessor`.

````bash
17:41:08.681 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.FileProcessor -- === Iniciando procesamiento de archivo ===
17:41:08.685 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.FileProcessor -- Archivo: src/main/resources/sample-files/sample_transactions.txt - Batch ID: BATCH_1753310468675
17:41:08.692 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.FileProcessor -- Archivo obtenido exitosamente. Tama√±o: 219 bytes
17:41:08.696 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- No se detect√≥ cabecera. Validando estructura de la primera l√≠nea de datos: 4 columnas
17:41:08.708 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- Parsing TXT completado: 4 registros extra√≠dos
17:41:08.712 [main] WARN dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- Registro inv√°lido TXT_4: amount debe ser mayor que 0
17:41:08.748 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- SQL simulada:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_1', 'ACC001', 150.75, '2024-01-15T10:30', 'Transferencia entrante', 'BATCH_1753310468675')

17:41:08.748 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- SQL simulada:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_2', 'ACC002', 89.50, '2024-01-15T11:45', 'Pago servicios', 'BATCH_1753310468675')

17:41:08.748 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- SQL simulada:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_3', 'ACC003', 200.00, '2024-01-15T14:20', 'Dep√≥sito efectivo', 'BATCH_1753310468675')

17:41:08.748 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.TxtDelimitedProcessor -- Se simularon 3 inserciones en la tabla transactions_txt.
17:41:08.749 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.FileProcessor -- REPORTE TXT:
=== REPORTE DE PROCESAMIENTO TXT ===
Archivo: D:\programming\spring\15.martin_diaz\design-patterns\src\main\resources\sample-files\sample_transactions.txt
Batch Id: BATCH_1753310468675
Fecha/Hora: 2025-07-23 17:41:08
Total registros: 4
Registros procesados: 3
Registros inv√°lidos: 1
Estado: Exitoso con advertencias
17:41:08.749 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.processor.FileProcessor -- Procesamiento finalizado exitosamente. Registros procesados: 3
17:41:08.799 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.templatemethod.fileprocessor.client.Main -- ProcessResult[batchId=BATCH_1753310468675, success=true, errorMessage=null, totalRecords=4, processedRecords=3, invalidRecords=1]
````

---

## Chain of Responsibility

El patr√≥n `Chain of Responsibility` (`Cadena de Responsabilidad`) es un patr√≥n de dise√±o de comportamiento que permite
pasar una solicitud a lo largo de una cadena de manejadores (`handlers`). Cada manejador decide si procesa la solicitud
o si debe pasarla al siguiente manejador en la cadena.

> üí° `Prop√≥sito`: Evitar el acoplamiento entre el emisor de la solicitud y su receptor, permitiendo que m√∫ltiples
> objetos tengan la oportunidad de manejarla.

### ‚úÖ Cu√°ndo usarlo

Este patr√≥n es muy √∫til cuando:

- Se necesita ejecutar una `serie de validaciones o pasos condicionales`.
- La l√≥gica debe ser `flexible y extensible` (agregar/quitar reglas sin modificar otras).
- Hay m√∫ltiples objetos que pueden procesar una solicitud y `no se quiere acoplar` el cliente a uno espec√≠fico.

### üß© Ventajas

- `Abierto/Cerrado`: puedes agregar nuevos manejadores sin modificar los existentes.
- `Desacoplamiento`: el cliente no necesita saber qu√© objeto manejar√° la solicitud.
- `Reutilizaci√≥n`: puedes usar los mismos manejadores en otras cadenas.
- `Flexibilidad`: F√°cil adici√≥n/eliminaci√≥n de manejadores en tiempo de ejecuci√≥n.
- `Responsabilidad √önica`: Cada manejador tiene una responsabilidad espec√≠fica.
- `Orden Din√°mico`: Se puede cambiar el orden de los manejadores.

### ‚ö†Ô∏è Desventajas

- Puede ser dif√≠cil de depurar si la cadena es larga o din√°mica.
- Si nadie maneja la solicitud, podr√≠a perderse (es buena pr√°ctica terminar con un manejador por defecto).

### üìê Representaci√≥n UML del patr√≥n Chain of Responsibility

![05.png](assets/02-java-plano-comportamiento/05.png)

1. `Handler` declara la interfaz com√∫n a todos los manejadores concretos. Normalmente, contiene un √∫nico
   m√©todo para manejar solicitudes `handle(request)` (el nombre puede variar), pero en ocasiones tambi√©n puede contar
   con otro m√©todo `setNext(Handler)` para establecer el siguiente manejador de la cadena.


2. La clase `BaseHandler` es opcional y es donde puedes colocar el c√≥digo boilerplate (segmentos de c√≥digo que suelen
   no alterarse) com√∫n para todas las clases manejadoras. Normalmente, esta clase define un campo para almacenar una
   referencia al siguiente manejador. Los clientes pueden crear una cadena pasando un manejador al constructor o
   modificador (`setter`) del manejador previo. La clase tambi√©n puede implementar el comportamiento de gesti√≥n por
   defecto: puede pasar la ejecuci√≥n al siguiente manejador despu√©s de comprobar su existencia.


3. Los `ConcreteHandlers` contienen el c√≥digo para procesar solicitudes. Al recibir una solicitud, cada manejador debe
   decidir si procesarla o si la pasa a la siguiente. Habitualmente, los manejadores son aut√≥nomos e
   inmutables, y aceptan toda la informaci√≥n necesaria √∫nicamente a trav√©s del constructor.


4. El `Client` puede componer cadenas una sola vez o componerlas din√°micamente, dependiendo de la l√≥gica de la
   aplicaci√≥n.

## üß¨ Variaciones del patr√≥n Chain of Responsibility

En la pr√°ctica, el patr√≥n `Chain of Responsibility` puede aplicarse de diferentes maneras, dependiendo del flujo de
procesamiento deseado. Estas son las principales variantes que pueden encontrarse en proyectos reales:

1. `Cadena Pura (Pure Chain)`
    - Solo un handler procesa la solicitud.
    - Una vez que uno la atiende, la cadena termina.
    - No retorna un valor significativo (`void`).
    - Responsabilidad individual y excluyente.
    - üß† Ejemplo t√≠pico: ‚Äú¬øQui√©n resuelve este ticket?‚Äù ‚Üí Lo toma solo el primer handler capaz.


2. `Cadena Impura (Impure Chain)`
    - Todos los handlers procesan la solicitud, uno tras otro.
    - Si uno falla, ya sea lanzando una excepci√≥n o retornando un error, la cadena se detiene inmediatamente.
    - No retorna un resultado acumulado (generalmente es `void`), aunque pueden lanzarse excepciones o realizar efectos
      secundarios.
    - La responsabilidad es compartida entre todos los handlers.
    - üß† Ejemplo t√≠pico: ‚Äú¬øTodos aprueban esta orden?‚Äù
        - Cada aprobador (handler) verifica la orden.
        - Si uno la rechaza, se cancela todo el proceso.


3. `Cadena con Retorno (Return-based Chain)`
    - Cada handler devuelve un resultado (puede ser boolean, un objeto de resultado, un enum, etc.).
    - La `decisi√≥n de continuar o detener la cadena` se basa `expl√≠citamente en el valor retornado` por cada `handler`.
    - √ötil para escenarios con l√≥gica condicional compleja, donde `el flujo se adapta seg√∫n lo que retorne cada paso`.
    - Puede haber acumulaci√≥n de resultados o una evaluaci√≥n secuencial basada en estados intermedios.
    - üß† Ejemplo t√≠pico: ‚Äú¬øEs v√°lida esta orden?‚Äù
        - Cada validador ejecuta su l√≥gica y retorna un resultado parcial.
        - La cadena analiza ese resultado y `decide si continuar con el siguiente handler o detenerse`.

üîé Diferencia clave:
> Mientras que en la `Cadena Impura` el flujo se detiene solo por fallo (impl√≠citamente), en la `Cadena con Retorno` la
> `l√≥gica de continuidad es expl√≠cita` y controlada por el `valor devuelto por cada handler`, lo que permite mayor
> flexibilidad en el control del flujo.

### üéØ Ejemplo 01: Validar una solicitud de orden antes de procesarla

Sup√≥n que tienes una API para crear √≥rdenes de compra. Antes de registrar la orden en base de datos, debes verificar:

1. Que el cliente exista.
2. Que el producto est√© en stock.
3. Que la direcci√≥n de env√≠o sea v√°lida.
4. Que la orden se procese en un horario v√°lido.

Cada uno de estos pasos es una validaci√≥n espec√≠fica, pero todas deben ser aplicadas en orden, y si alguna falla, debe
cortarse el flujo.

> üëâ Este caso se resuelve perfectamente con `Chain of Responsibility`.

![06.png](assets/02-java-plano-comportamiento/06.png)

### üß© Modelos utilizados en la l√≥gica de negocio

Estos modelos representan los datos que fluyen a trav√©s de la cadena de responsabilidad. No son parte directa del
patr√≥n (no implementan interfaces del patr√≥n), pero **son esenciales porque son el objeto que ser√° validado o procesado
por los distintos handlers.**

üì¶ `PurchaseOrder`

````java
public record PurchaseOrder(Long customerId,
                            List<OrderItem> items,
                            ShippingAddress shippingAddress) {

    public double getTotalAmount() {
        return this.items.stream().mapToDouble(OrderItem::getSubTotal).sum();
    }
}
````

- Rol: Representa la orden de compra que se est√° procesando.
- Importancia en el patr√≥n: Ser√° el objeto central que viajar√° a trav√©s de los handlers de la cadena.
- Contiene una lista de productos (`OrderItem`) y datos de env√≠o (`ShippingAddress`).

üì¶ `OrderItem`

````java
public record OrderItem(Long productId,
                        int quantity,
                        double unitPrice) {
    public double getSubTotal() {
        return this.quantity * this.unitPrice;
    }
}
````

- Rol: Representa un √≠tem individual dentro de una orden de compra.
- Puede ser usado por un handler que valide si hay stock suficiente por producto.

üì¶ `ShippingAddress`

````java
public record ShippingAddress(String street,
                              String city,
                              String postalCode,
                              String country) {
}
````

- Rol: Representa la direcci√≥n de env√≠o.
- Un handler puede validar si la direcci√≥n est√° completa o si el pa√≠s es elegible para env√≠o.

üì¶ `Product`

````java
public record Product(Long id,
                      String name,
                      double price,
                      int availableStock) {
}
````

- Rol: Representa un producto disponible en el sistema.
- Aunque no ser√° directamente parte del patr√≥n, los handlers de stock o validaci√≥n de productos pueden requerir esta
  informaci√≥n para validar pedidos.

üì¶ `Customer`

````java
public record Customer(Long id,
                       String name,
                       String email,
                       boolean active) {
}
````

- Rol: Representa al cliente que est√° realizando la compra.
- Un handler puede usar esta informaci√≥n para validar si el cliente est√° activo o habilitado para realizar pedidos.

### ‚úÖ DTO de Resultado de Validaci√≥n

Este record representa el resultado de una validaci√≥n dentro del proceso de manejo de la solicitud. Se utiliza como
respuesta est√°ndar para comunicar si un paso de validaci√≥n fue exitoso o no.

````java
public record ValidationResult(boolean isValid,
                               String errorMessage,
                               String errorCode) {

    public static ValidationResult success() {
        return new ValidationResult(true, null, null);
    }

    public static ValidationResult failure(String errorMessage, String errorCode) {
        return new ValidationResult(false, errorMessage, errorCode);
    }
}
````

üß© Descripci√≥n

- `isValid`: Indica si la validaci√≥n fue exitosa (true) o fallida (false).
- `errorMessage`: Mensaje descriptivo del error (solo en caso de fallo).
- `errorCode`: C√≥digo asociado al tipo de error.

üõ†Ô∏è Utilidad

- Este DTO ser√° utilizado por los diferentes manejadores (handlers) de la cadena de validaci√≥n para:
    - Establecer un contrato uniforme en la comunicaci√≥n de errores o √©xitos.
    - Propagar el resultado al componente que inici√≥ la solicitud.
    - Detener o continuar el flujo, seg√∫n corresponda (esto se determinar√° en la implementaci√≥n final).

> M√°s adelante, cuando se concluya el flujo completo, se precisar√° si este DTO forma parte de una cadena con retorno o
> si cumple √∫nicamente un rol de comunicaci√≥n.

### üß∞ Servicios simulados

En este ejemplo pr√°ctico, simulamos el acceso a una base de datos o a servicios externos mediante clases sencillas que
encapsulan l√≥gica inmutable. Estos servicios proporcionan los datos necesarios para que los validadores (handlers de la
cadena) puedan realizar sus verificaciones sobre una orden de compra (`PurchaseOrder`).

> ‚ö†Ô∏è Nota importante: Aunque estos servicios no forman parte directa del patr√≥n `Chain of Responsibility`, son
> dependencias necesarias para que cada handler pueda ejecutar su l√≥gica de validaci√≥n. En una aplicaci√≥n real,
> estar√≠an implementados como servicios inyectables (`@Service`) o repositorios (`@Repository`) con acceso a base de
> datos.

üì¶ `ProductService`

````java
// Simula acceso a base de datos
public class ProductService {
    private static final Map<Long, Product> products = Map.of(
            101L, new Product(101L, "Dell Laptop", 1200.00, 5),
            102L, new Product(102L, "Wireless Mouse", 25.50, 0), // No hay stock (agotado)
            103L, new Product(103L, "Mechanical Keyboard", 89.99, 10)
    );

    public Product findById(Long id) {
        return products.get(id);
    }
}
````

- Simula una tabla de productos con ID, nombre, precio y stock disponible.
- Proporciona un m√©todo de consulta por ID (findById), que retorna el producto correspondiente o null si no existe.
- Se utilizar√° para validar si los productos solicitados existen y tienen stock suficiente.

üë§ `CustomerService`

````java
// Simula acceso a base de datos
public class CustomerService {

    private static final Map<Long, Customer> customers = Map.of(
            1L, new Customer(1L, "John Doe", "john@email.com", true),
            2L, new Customer(2L, "Jane Smith", "jane@email.com", false),
            3L, new Customer(3L, "Mike Johnson", "mike@email.com", true)
    );

    public Customer findById(Long id) {
        return customers.get(id);
    }
}
````

- Simula una tabla de clientes registrados, con su informaci√≥n b√°sica y un campo active que indica si el cliente est√°
  habilitado.
- Se utilizar√° para validar si el cliente que realiza la orden existe y est√° activo.

üè† `AddressService`

````java
// Simula acceso a base de datos
public class AddressService {
    private static final Set<String> validCountries = Set.of("USA", "CANADA", "MEXICO", "PERU", "COLOMBIA");

    public boolean isValidAddress(ShippingAddress address) {
        return Objects.nonNull(address.street()) && !address.street().isBlank() &&
               Objects.nonNull(address.city()) && !address.city().isBlank() &&
               Objects.nonNull(address.postalCode()) && !address.postalCode().isBlank() &&
               validCountries.contains(address.country().toUpperCase());
    }
}
````

- Simula una validaci√≥n b√°sica de direcciones de env√≠o.
- Verifica que los campos de direcci√≥n est√©n completos y que el pa√≠s est√© en la lista de pa√≠ses admitidos.
- Se usar√° para validar la direcci√≥n proporcionada en la orden.

Cuando implementemos los handlers concretos, ver√°s c√≥mo cada uno utiliza uno de estos servicios para aplicar una
validaci√≥n espec√≠fica. Esto ejemplifica c√≥mo cada eslab√≥n de la cadena puede tener su propia responsabilidad, con
dependencias encapsuladas.

### üîó Componentes del patr√≥n Chain of Responsibility: Handler y BaseHandler

En el patr√≥n `Chain of Responsibility`, cada objeto en la cadena (conocido como `handler`) tiene la capacidad de
manejar una solicitud o delegarla al siguiente objeto de la cadena. Esta secci√≥n define:

- Una `interfaz base` que representa el contrato com√∫n para todos los validadores.
- Una `clase abstracta` que implementa la l√≥gica de encadenamiento y delegaci√≥n.

üß© `OrderValidationHandler (Interfaz)`

````java
public interface OrderValidationHandler {
    // Method para establecer el siguiente handler en la cadena
    OrderValidationHandler setNext(OrderValidationHandler handler);

    // Method principal para manejar solicitudes
    ValidationResult handle(PurchaseOrder order);
}
````

- `setNext(...)`: establece el siguiente `handler` en la cadena. Permite construir la cadena de forma fluida con
  encadenamiento: `handler1.setNext(handler2).setNext(handler3);`.
- `handle(...)`: m√©todo principal que procesa la solicitud (`PurchaseOrder`). La implementaci√≥n concreta definir√° c√≥mo
  manejarla o si debe delegarla.

üß± `BaseOrderValidationHandler (Clase abstracta)`

````java

public abstract class BaseOrderValidationHandler implements OrderValidationHandler {

    protected OrderValidationHandler nextHandler;

    @Override
    public OrderValidationHandler setNext(OrderValidationHandler handler) {
        this.nextHandler = handler;
        return handler; // Permite el encadenamiento: handler1.setNext(handler2).setNext(handler3)
    }

    @Override
    public final ValidationResult handle(PurchaseOrder order) {
        // Ejecuta la validaci√≥n espec√≠fica del ConcreteHandler
        ValidationResult result = this.doHandle(order);

        // Terminaci√≥n anticipada: si falla, cortar la cadena inmediatamente
        if (!result.isValid()) {
            return result;
        }

        // Si hay un siguiente handler y la validaci√≥n actual fue exitosa, contin√∫e la cadena
        if (Objects.nonNull(this.nextHandler)) {
            return this.nextHandler.handle(order);
        }

        // Si no hay m√°s handlers y llegamos hasta aqu√≠, everything es v√°lido
        return ValidationResult.success();
    }

    /**
     * Method abstracto que los ConcreteHandlers deben implementar
     * Aqu√≠ es donde se aplica la l√≥gica espec√≠fica de cada validaci√≥n
     */
    protected abstract ValidationResult doHandle(PurchaseOrder order);
}
````

Esta clase ofrece una implementaci√≥n com√∫n reutilizable para la mayor√≠a de los handlers. Destacamos su comportamiento:

üîÑ Flujo de ejecuci√≥n del m√©todo `handle(...)`

1. `Validaci√≥n local`: llama al m√©todo `doHandle(order)` (`abstracto`), que debe ser implementado por cada handler
   concreto.
2. `Corte anticipado`: si la validaci√≥n falla, se retorna inmediatamente el `ValidationResult` y la cadena se detiene.
3. `Delegaci√≥n`: si todo va bien y hay otro handler en la cadena, delega la validaci√≥n al siguiente.
4. `Finalizaci√≥n exitosa`: si no hay m√°s handlers y nadie ha fallado, se retorna una validaci√≥n exitosa.

‚öôÔ∏è M√©todo `doHandle(...)`

````bash
protected abstract ValidationResult doHandle(PurchaseOrder order);
````

- M√©todo abstracto que define la l√≥gica espec√≠fica de validaci√≥n que debe implementar cada subclase concreta.
- Aqu√≠ es donde cada handler hace su trabajo especializado (por ejemplo, validar cliente, stock, direcci√≥n, etc.).

Esta estructura permite construir cadenas din√°micas, desacoplar responsabilidades y extender f√°cilmente nuevas
validaciones sin modificar las existentes.

> üß† `Patr√≥n aplicado`: Este dise√±o es un ejemplo claro de `Cadena con Retorno (Return-based Chain)`.
> Cada handler devuelve un resultado (`ValidationResult`) que permite decidir si continuar o interrumpir la cadena.
>
> No se trata de una `cadena impura`, ya que no se lanza ninguna excepci√≥n para cortar el flujo;
> tampoco es una `cadena pura`, porque el resultado s√≠ influye directamente en la continuidad del procesamiento.

### üß± Handlers concretos de validaci√≥n (ConcreteHandlers)

Estos son los validadores individuales que extienden la clase base `BaseOrderValidationHandler`.
Cada uno encapsula una regla de negocio espec√≠fica del proceso de validaci√≥n de pedidos, como:

- Validaci√≥n de cliente (existencia y estado activo).
- Verificaci√≥n de stock disponible para los productos.
- Validaci√≥n de direcci√≥n de env√≠o.
- Restricciones por horario de operaci√≥n.

Cada handler puede cortar la cadena si su validaci√≥n falla, retornando un `ValidationResult` con un c√≥digo de error
y un mensaje descriptivo.

````java

@Slf4j
@RequiredArgsConstructor
public class CustomerValidationHandler extends BaseOrderValidationHandler {

    private final CustomerService customerService;

    @Override
    protected ValidationResult doHandle(PurchaseOrder order) {
        log.info("[Validador de clientes] Verificando cliente con ID: {}", order.customerId());

        Customer customer = this.customerService.findById(order.customerId());

        if (Objects.isNull(customer)) {
            return ValidationResult.failure(
                    "Cliente no encontrado con ID: " + order.customerId(),
                    "CUSTOMER_NOT_FOUND"
            );
        }

        if (!customer.active()) {
            return ValidationResult.failure("Cliente inactivo", "CUSTOMER_INACTIVE");
        }

        log.info("Cliente v√°lido: {}", customer.name());
        return ValidationResult.success();
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class StockValidationHandler extends BaseOrderValidationHandler {

    private final ProductService productService;

    @Override
    protected ValidationResult doHandle(PurchaseOrder order) {
        log.info("[Validador de stock] Verificando disponibilidad de producto");

        for (OrderItem orderItem : order.items()) {
            Product product = this.productService.findById(orderItem.productId());

            if (Objects.isNull(product)) {
                return ValidationResult.failure("Producto no encontrado con id: " + orderItem.productId(), "PRODUCT_NOT_FOUND");
            }

            if (orderItem.quantity() > product.availableStock()) {
                return ValidationResult.failure(
                        "Stock insuficiente para %s. Disponible: %d, Solicitado: %d"
                                .formatted(product.name(), product.availableStock(), orderItem.quantity()),
                        "INSUFFICIENT_STOCK");
            }
            log.info("Stock OK para {} (Disponible {}, solicitado {})", product.name(), product.availableStock(), orderItem.quantity());
        }

        return ValidationResult.success();
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class AddressValidationHandler extends BaseOrderValidationHandler {

    private final AddressService addressService;

    @Override
    protected ValidationResult doHandle(PurchaseOrder order) {
        ShippingAddress address = order.shippingAddress();
        log.info("[Validador de direcci√≥n] verificando: {}, {}", address.city(), address.country());

        if (!this.addressService.isValidAddress(address)) {
            return ValidationResult.failure(
                    "Direcci√≥n de env√≠o no v√°lida. Verifique el formato de los campos y el pa√≠s de destino.",
                    "INVALID_ADDRESS");
        }
        log.info("Direcci√≥n v√°lido para el env√≠o");
        return ValidationResult.success();
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class BusinessHoursValidatorHandler extends BaseOrderValidationHandler {
    @Override
    protected ValidationResult doHandle(PurchaseOrder order) {
        log.info("[Validador de horario comercial] Verificando horario de procesamiento...");
        int hour = LocalTime.now().getHour();

        // Bloqueamos pedidos entre la 1:00 AM (inclusive) y 7:00 AM (exclusive)
        if (hour < 7 && hour >= 1) {
            return ValidationResult.failure(
                    "Sistema en mantenimiento. No se procesan pedidos desde la 1:00 am hasta las 06:59 am",
                    "SYSTEM_MAINTENANCE");
        }

        log.info("Horario v√°lido para el procesamiento");
        return ValidationResult.success();
    }
}
````

### üß© Conclusi√≥n:

Esta implementaci√≥n demuestra c√≥mo el patr√≥n `Chain of Responsibility` permite encapsular y desacoplar validaciones
individuales, facilitando la extensibilidad y el mantenimiento del proceso de validaci√≥n de pedidos.

### üìç Componente del patr√≥n Chain of Responsibility: Cliente

El `cliente` es el `punto de entrada para procesar las √≥rdenes`. Su rol principal es `iniciar la cadena de validaci√≥n`
al construir y disparar la secuencia de handlers.

````java

@Slf4j
public class OrderProcessingClient {

    // Method principal que inicia el procesamiento del pedido
    public ValidationResult processOrder(PurchaseOrder order) {
        log.info("==== Procesando orden ====");
        log.info("Customer ID: {}", order.customerId());
        log.info("Items: {}", order.items().size());
        log.info("Total amount: S/ {}", String.format("%.2f", order.getTotalAmount()));
        log.info("Destination: {}", order.shippingAddress().city());
        log.info("===========================");

        // Construcci√≥n e invocaci√≥n de la cadena
        OrderValidationHandler handlerChain = this.buildValidationChain();
        ValidationResult result = handlerChain.handle(order);

        if (result.isValid()) {
            log.info("Orden procesada correctamente.");
            log.info("El pedido ha sido registrado y est√° listo para su preparaci√≥n.");
            //Aqu√≠ ir√≠a la l√≥gica para persistir en BD, enviar notificaciones, etc.
        } else {
            log.error("Error procesando la orden.");
            log.error("C√≥digo de error: {}", result.errorCode());
            log.error("Detalle: {}", result.errorMessage());
            //Aqu√≠ ir√≠an los registros, m√©tricas, notificaciones de errores, etc.
        }
        return result;
    }

    /**
     * Configura la cadena de validaci√≥n: Aqu√≠ es donde el cliente construye la cadena de validaci√≥n
     * Nota: El orden es fundamental en las validaciones empresariales.
     */
    private OrderValidationHandler buildValidationChain() {
        // Instancia de handlers concretos
        OrderValidationHandler customerValidator = new CustomerValidationHandler(new CustomerService());
        OrderValidationHandler stockValidator = new StockValidationHandler(new ProductService());
        OrderValidationHandler addressValidator = new AddressValidationHandler(new AddressService());
        OrderValidationHandler hoursValidator = new BusinessHoursValidatorHandler();

        // Encadenamiento de responsabilidades
        customerValidator
                .setNext(stockValidator)
                .setNext(addressValidator)
                .setNext(hoursValidator);

        return customerValidator; // Primer eslab√≥n de la cadena
    }

}
````

- Responsabilidad: Inicia el proceso de validaci√≥n construyendo la cadena y pasando la orden.
- Encapsula el orden de validaci√≥n, lo que permite centralizar la l√≥gica de flujo y facilita su modificaci√≥n futura.
- No conoce la l√≥gica interna de cada handler, cumpliendo con el principio de bajo acoplamiento.

### üöÄ Clase Main: punto de entrada

Esta clase simula el env√≠o de una orden de compra y ejecuta la validaci√≥n a trav√©s de la cadena de responsabilidades
previamente configurada.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        // CASO 1: Pedido completamente v√°lido
        // Creaci√≥n de elementos de la orden
        List<OrderItem> items = List.of(new OrderItem(101L, 1, 1200.00), new OrderItem(103L, 1, 89.90));
        ShippingAddress address = new ShippingAddress("Av. universitaria", "Nuevo Chimbote", "10001", "USA");
        PurchaseOrder order = new PurchaseOrder(1L, items, address);

        // Cliente que inicia la validaci√≥n
        OrderProcessingClient client = new OrderProcessingClient();
        ValidationResult result = client.processOrder(order);

        // Resultado global de la validaci√≥n
        log.info("Resultado final: {}", result.isValid());
    }
}
````

- Representa el entry point de la aplicaci√≥n.
- Construye una orden con datos de prueba y la env√≠a al cliente (OrderProcessingClient).
- Muestra el resultado final de la validaci√≥n.

### Ejecuci√≥n exitosa

Todos los validadores ejecutaron su l√≥gica sin interrupciones. El sistema determin√≥ que la orden es v√°lida y puede ser
procesada. Esto refleja una cadena de responsabilidad exitosa, donde cada handler se encarga de una validaci√≥n
espec√≠fica y permite continuar solo si no encuentra errores.

````bash
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- ==== Procesando orden ====
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Customer ID: 1
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Items: 2
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Total amount: S/ 1289.90
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Destination: Nuevo Chimbote
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- ===========================
chainofresponsibility.ordervalidation.validation.impl.CustomerValidationHandler -- [Validador de clientes] Verificando cliente con ID: 1
chainofresponsibility.ordervalidation.validation.impl.CustomerValidationHandler -- Cliente v√°lido: John Doe
chainofresponsibility.ordervalidation.validation.impl.StockValidationHandler -- [Validador de stock] Verificando disponibilidad de producto
chainofresponsibility.ordervalidation.validation.impl.StockValidationHandler -- Stock OK para Dell Laptop (Disponible 5, solicitado 1)
chainofresponsibility.ordervalidation.validation.impl.StockValidationHandler -- Stock OK para Mechanical Keyboard (Disponible 10, solicitado 1)
chainofresponsibility.ordervalidation.validation.impl.AddressValidationHandler -- [Validador de direcci√≥n] verificando: Nuevo Chimbote, USA
chainofresponsibility.ordervalidation.validation.impl.AddressValidationHandler -- Direcci√≥n v√°lido para el env√≠o
chainofresponsibility.ordervalidation.validation.impl.BusinessHoursValidatorHandler -- [Validador de horario comercial] Verificando horario de procesamiento...
chainofresponsibility.ordervalidation.validation.impl.BusinessHoursValidatorHandler -- Horario v√°lido para el procesamiento
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Orden procesada correctamente.
chainofresponsibility.ordervalidation.client.OrderProcessingClient -- El pedido ha sido registrado y est√° listo para su preparaci√≥n.
chainofresponsibility.ordervalidation.Main -- Resultado final: true 
````

### Ejecuci√≥n con fallo

Para realizar esta ejecuci√≥n, agregaremos un nuevo caso a nuestra clase Main.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        // CASO 2: Stock insuficiente (falla en la segunda validaci√≥n)
        List<OrderItem> items2 = List.of(new OrderItem(102L, 5, 25.50));
        ShippingAddress address2 = new ShippingAddress("Av. universitaria", "Nuevo Chimbote", "10001", "USA");
        PurchaseOrder order2 = new PurchaseOrder(1L, items2, address2);
        OrderProcessingClient client2 = new OrderProcessingClient();
        ValidationResult result2 = client2.processOrder(order2);
        log.info("Resultado final 2: {}", result2.isValid());
    }
}

````

La ejecuci√≥n demuestra c√≥mo el patr√≥n `Chain of Responsibility` interrumpe el flujo en cuanto uno de los validadores
(en este caso, el de stock) encuentra un problema. Las validaciones posteriores (direcci√≥n, horario comercial) no se
ejecutan, ya que no tiene sentido continuar si la orden no puede ser completada.

````bash
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- ==== Procesando orden ====
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Customer ID: 1
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Items: 1
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Total amount: S/ 127.50
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Destination: Nuevo Chimbote
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- ===========================
.chainofresponsibility.ordervalidation.validation.impl.CustomerValidationHandler -- [Validador de clientes] Verificando cliente con ID: 1
.chainofresponsibility.ordervalidation.validation.impl.CustomerValidationHandler -- Cliente v√°lido: John Doe
.chainofresponsibility.ordervalidation.validation.impl.StockValidationHandler -- [Validador de stock] Verificando disponibilidad de producto
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Error procesando la orden.
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- C√≥digo de error: INSUFFICIENT_STOCK
.chainofresponsibility.ordervalidation.client.OrderProcessingClient -- Detalle: Stock insuficiente para Wireless Mouse. Disponible: 0, Solicitado: 5
.chainofresponsibility.ordervalidation.Main -- Resultado final 2: false 
````

### ‚ö° Flujo de ejecuci√≥n del patr√≥n

El procesamiento de la orden sigue una cadena de validadores, donde cada uno ejecuta su l√≥gica y decide si delega al
siguiente:

1. `customerValidator.handle(order)` ejecuta su validaci√≥n.
2. Si es v√°lida ‚Üí delega a `stockValidator.handle(order)`
3. `stockValidator.handle(order)` ejecuta su validaci√≥n.
4. Si es v√°lida ‚Üí delega a `addressValidator.handle(order)`
5. Y as√≠ sucesivamente con los dem√°s validadores...

La clave del patr√≥n est√° en esta l√≠nea:

````bash
if (Objects.nonNull(this.nextHandler)) {
    return this.nextHandler.handle(order); // <- delegaci√≥n condicional
}
````

Esto implementa la delegaci√≥n progresiva, donde cada handler decide si la cadena contin√∫a o se detiene, sin que el
cliente conozca la l√≥gica completa del flujo.

### üéØ Ejemplo 02: Soporte t√©cnico con escalamiento jer√°rquico

Este ejemplo ilustra la implementaci√≥n del patr√≥n `Chain of Responsibility` en un escenario realista de atenci√≥n de
solicitudes en un sistema de `soporte t√©cnico escalonado por niveles`. El objetivo es mostrar c√≥mo una solicitud
(como un problema de contrase√±a, red o hardware) puede ser pasada a trav√©s de una cadena de handlers, donde cada uno
decide si puede procesarla o la delega al siguiente.

La cadena est√° compuesta por distintos niveles de soporte:

- `Nivel 1`: Problemas b√°sicos como contrase√±as.
- `Nivel 2`: Problemas intermedios como conectividad de red.
- `Nivel 3`: Problemas m√°s complejos como hardware.
- `Handler por defecto`: Captura todo lo que no pudo ser resuelto en la cadena y lanza una excepci√≥n controlada.

Cada handler implementa su propia l√≥gica de validaci√≥n mediante el m√©todo `canProcess(...)`, lo que permite aplicar la
regla de responsabilidad √∫nica y delegaci√≥n progresiva.

Este enfoque promueve el principio de `abierto/cerrado` al permitir agregar nuevos niveles de soporte sin modificar los
existentes, y refleja el esp√≠ritu del patr√≥n: desacoplar el emisor de una solicitud de su receptor.

### Variaci√≥n del Chain of Responsibility: Pure Chain (Cadena Pura)

Esta implementaci√≥n es una variaci√≥n del patr√≥n `Chain of Responsibility` del tipo `Pure Chain`, donde
`la solicitud es procesada por un √∫nico handler` en toda la cadena. Una vez que un handler determina que puede
procesar la solicitud (`canProcess()` retorna `true`), se ejecuta la l√≥gica de procesamiento y la cadena termina
inmediatamente, sin pasar la solicitud a los siguientes handlers.

Caracter√≠sticas clave:

- `Exclusividad`: Solo un handler procesa la solicitud.
- `Terminaci√≥n temprana`: La cadena se detiene tan pronto como encuentra el handler apropiado
- `Eficiencia`: No hay procesamiento redundante.
- `Responsabilidad √∫nica`: Cada handler tiene una responsabilidad espec√≠fica y bien definida.

`Flujo`:

- Si `canProcess()` es `true` ‚Üí `Procesa` y termina.
- Si es `false` ‚Üí Pasa al siguiente handler.

Esta variaci√≥n es ideal para sistemas donde existe una jerarqu√≠a clara de responsabilidades y solo un handler debe
manejar cada tipo de solicitud espec√≠fica.

### üß© Modelos utilizados en la l√≥gica de negocio

Antes de construir la cadena de responsabilidades, definimos los modelos que encapsulan la informaci√≥n del problema a
resolver:

#### üìå IssueType (enumeraci√≥n)

Representa los distintos tipos de problemas que pueden presentarse en una mesa de soporte t√©cnico.

````java
public enum IssueType {
    PASSWORD,
    NETWORK,
    HARDWARE,
    SOFTWARE,
}
````

#### üìå SupportRequest (record)

Modela una solicitud de soporte realizada por un empleado. Incluye su nombre, el tipo de problema y una breve
descripci√≥n.

````java

public record SupportRequest(String employeeName,
                             IssueType issueType,
                             String description) {
}
````

Estos modelos ser√°n utilizados por los distintos niveles de soporte (handlers) para decidir si pueden o no manejar la
solicitud.

### üß© Handler base ‚Äî SupportHandler

Esta clase abstracta define la estructura com√∫n de todos los manejadores de soporte (niveles de atenci√≥n), actuando
como base para implementar el patr√≥n `Chain of Responsibility`.

````java
public abstract class SupportHandler {

    protected SupportHandler nextHandler;

    public SupportHandler setNextHandler(SupportHandler nextHandler) {
        this.nextHandler = nextHandler;
        return nextHandler;
    }

    public void handle(SupportRequest request) {
        if (!this.canProcess(request) && Objects.nonNull(this.nextHandler)) {
            this.nextHandler.handle(request);
        }
    }

    protected abstract boolean canProcess(SupportRequest request);
}
````

- `nextHandler`. Guarda una referencia al siguiente manejador en la cadena. Si el actual no puede procesar la solicitud,
  se delega al siguiente.
- `setNextHandler(...)`. M√©todo encadenable que permite construir la cadena de responsabilidades de forma fluida.
- `handle(...)`. Define la l√≥gica para manejar la solicitud:
    - Si el handler actual no puede procesarla (`!canProcess(...)`) y hay un siguiente `handler`, delega la solicitud.
    - Si no hay un siguiente handler, simplemente termina la ejecuci√≥n sin hacer nada (esto se complementar√° con un
      manejador por defecto m√°s adelante).
- `canProcess(...)`. M√©todo abstracto que cada subclase concreta debe implementar para decidir si puede o no manejar el
  tipo de solicitud.

### üß± Handlers concretos

Cada clase concreta extiende la clase base `SupportHandler` y se encarga de procesar un tipo espec√≠fico de solicitud.
Si no puede manejarla, delega al siguiente handler en la cadena.

`Nivel 1 ‚Äî Level1SupportHandler`

````java

@Slf4j
public class Level1SupportHandler extends SupportHandler {
    @Override
    protected boolean canProcess(SupportRequest request) {
        if (IssueType.PASSWORD.equals(request.issueType())) {
            log.info("Nivel 1 resolvi√≥ el problema de contrase√±a para: {}", request.employeeName());
            return true;
        }
        return false;
    }
}
````

- Procesa solicitudes relacionadas con reseteo o recuperaci√≥n de contrase√±a (`IssueType.PASSWORD`).
- Si no puede manejar la solicitud, la pasa al siguiente handler.

`Nivel 2 ‚Äî Level2SupportHandler`

````java

@Slf4j
public class Level2SupportHandler extends SupportHandler {
    @Override
    protected boolean canProcess(SupportRequest request) {
        if (IssueType.NETWORK.equals(request.issueType())) {
            log.info("Nivel 2 resolvi√≥ el problema de red para: {}", request.employeeName());
            return true;
        }
        return false;
    }
}
````

- Se encarga de resolver problemas de conectividad o red (`IssueType.NETWORK`).
- Si no corresponde, la solicitud contin√∫a por la cadena.

`Nivel 3 ‚Äî Level3SupportHandler`

````java

@Slf4j
public class Level3SupportHandler extends SupportHandler {
    @Override
    protected boolean canProcess(SupportRequest request) {
        if (IssueType.HARDWARE.equals(request.issueType())) {
            log.info("Nivel 3 resolvi√≥ el problema de hardware para: {}", request.employeeName());
            return true;
        }
        return false;
    }
}
````

- Maneja solicitudes de tipo hardware (equipos, perif√©ricos, etc.).
- Si tampoco puede resolverlo, se delega al siguiente handler (que podr√≠a ser un default).

### üö® Handler por defecto ‚Äî Terminal de la cadena

En esta implementaci√≥n, definimos una clase base `TerminalSupportHandler` cuya √∫nica responsabilidad es ejecutar una
acci√≥n final cuando ning√∫n otro manejador puede procesar la solicitud. Para ello, delega el comportamiento a un m√©todo
abstracto `handleUnsupported(...)`, que deber√° ser implementado por la subclase concreta.

Adem√°s, anulamos el m√©todo `canProcess(...)` y lo marcamos como final para impedir que sea sobrescrito, ya que este
m√©todo no tiene ninguna funci√≥n √∫til en este punto de la cadena y nunca ser√° invocado. De esta forma, evitamos ruido
visual y aseguramos que la sem√°ntica del handler por defecto sea clara e inequ√≠voca: no procesa, solo responde como
√∫ltimo recurso.

Esta soluci√≥n es √∫til cuando deseas tener un manejador terminal (el √∫ltimo de la cadena) que nunca delega, sino que
`siempre lanza una excepci√≥n` cuando ninguna otra instancia pudo manejar la solicitud.

`Clase base terminal ‚Äî TerminalSupportHandler`

````java
public abstract class TerminalSupportHandler extends SupportHandler {

    @Override
    public void handle(SupportRequest request) {
        // Nunca delega, solo ejecuta l√≥gica definida por la subclase
        this.handleUnsupported(request);
    }

    @Override
    protected final boolean canProcess(SupportRequest request) {
        // Nunca se llama. Lo hacemos final para bloquear la sobre-escritura
        return false;
    }

    protected abstract void handleUnsupported(SupportRequest request);
}
````

- Esta clase anula por completo la l√≥gica de delegaci√≥n heredada de `SupportHandler`.
- El m√©todo `handle(...)` ejecuta directamente el m√©todo `handleUnsupported(...)`, definido por la subclase concreta.
- El m√©todo `canProcess(...)` es `marcado como final` para evitar confusi√≥n y garantizar que nunca se sobreescriba.

> üí° Esta clase existe para aislar claramente la intenci√≥n de que este handler es terminal y no delegar√°.
> As√≠, el `DefaultSupportHandler` no parecer√° que puede participar como los dem√°s en la l√≥gica de decisi√≥n con
> `canProcess(...)`.

`Handler concreto ‚Äî DefaultSupportHandler`

````java

@Slf4j
public class DefaultSupportHandler extends TerminalSupportHandler {
    @Override
    protected void handleUnsupported(SupportRequest request) {
        log.warn("No hay soporte para el tipo de problema [{}] de [{}]", request.issueType(), request.employeeName());
        throw new UnsupportedOperationException("Solicitud de %s con tipo de problema [%s] no puede ser procesada".formatted(request.employeeName(), request.issueType()));
    }
}
````

- Este handler lanza una excepci√≥n cuando ninguno de los niveles anteriores pudo resolver la solicitud.
- Sirve como mecanismo de `fallback` controlado, evitando que solicitudes no reconocidas se pierdan silenciosamente.
- Deja un log de advertencia antes de fallar, lo que ayuda a identificar qu√© solicitudes no est√°n siendo cubiertas.

### üë§ Cliente

La clase `SupportClient` act√∫a como el cliente que inicia el procesamiento de solicitudes de soporte.
Aqu√≠ es donde se construye la cadena de responsabilidad encadenando los diferentes `SupportHandler` concretos seg√∫n su
nivel de atenci√≥n.

El √∫ltimo eslab√≥n de la cadena debe ser siempre el `DefaultSupportHandler`, que representa el manejador terminal que
lanza una excepci√≥n si ninguno de los niveles anteriores pudo procesar la solicitud.

````java
public class SupportClient {

    private final SupportHandler firstHandler;

    public SupportClient() {
        SupportHandler level1 = new Level1SupportHandler();
        SupportHandler level2 = new Level2SupportHandler();
        SupportHandler level3 = new Level3SupportHandler();
        SupportHandler byDefault = new DefaultSupportHandler(); // Terminal handler

        level1.setNextHandler(level2)
                .setNextHandler(level3)
                .setNextHandler(byDefault);

        this.firstHandler = level1;
    }

    public void processRequest(SupportRequest request) {
        this.firstHandler.handle(request);
    }
}
````

üß† Importante:

- El orden de encadenamiento define la prioridad de evaluaci√≥n. En este ejemplo:
    - `Nivel 1` intenta resolver problemas de tipo PASSWORD.
    - `Nivel 2`, problemas de tipo NETWORK.
    - `Nivel 3`, problemas de tipo HARDWARE.
    - Por defecto, se lanza una excepci√≥n para tipos no soportados como `SOFTWARE`.
- Si se desea extender la cadena con nuevos tipos de problemas, basta con crear un nuevo `SupportHandler` y a√±adirlo en
  la posici√≥n deseada.

### üöÄ Clase principal (Main)

En esta clase se crean instancias de `SupportRequest` representando diferentes tipos de problemas reportados por
empleados.

Luego, se instancia el cliente `SupportClient`, el cual contiene la cadena de soporte, y se procesan las solicitudes
una a una.

````java
public class Main {
    public static void main(String[] args) {
        SupportRequest req1 = new SupportRequest("Carlos", IssueType.PASSWORD, "No puedo acceder al sistema");
        SupportRequest req2 = new SupportRequest("Luisa", IssueType.NETWORK, "Internet lento");
        SupportRequest req3 = new SupportRequest("Andr√©s", IssueType.HARDWARE, "Mi laptop no enciende");
        // Aplicar√° el DefaultSupportHandler, ya que ninguno de los definidos en la cadena la podr√° procesar
        SupportRequest req4 = new SupportRequest("Milagros", IssueType.SOFTWARE, "Caduc√≥ la licencia de Office");

        SupportClient client = new SupportClient();
        client.processRequest(req1);
        client.processRequest(req2);
        client.processRequest(req3);
        client.processRequest(req4);
    }
}
````

üß™ Comportamiento esperado en consola (logs):

- Para req1, req2 y req3, se imprimir√°n mensajes indicando qu√© nivel resolvi√≥ el problema.
- Para req4, se imprimir√° una advertencia (WARN) y se lanzar√° una excepci√≥n `UnsupportedOperationException`, ya que el
  tipo `SOFTWARE` no es soportado por ning√∫n handler de la cadena.

````bash
17:11:35.680 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.chainofresponsibility.support.handler.Level1SupportHandler -- Nivel 1 resolvi√≥ el problema de contrase√±a para: Carlos
17:11:35.688 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.chainofresponsibility.support.handler.Level2SupportHandler -- Nivel 2 resolvi√≥ el problema de red para: Luisa
17:11:35.689 [main] INFO dev.magadiflo.patterns.plainjava.behavioral.chainofresponsibility.support.handler.Level3SupportHandler -- Nivel 3 resolvi√≥ el problema de hardware para: Andr√©s
17:11:35.689 [main] WARN dev.magadiflo.patterns.plainjava.behavioral.chainofresponsibility.support.handler.DefaultSupportHandler -- No hay soporte para el tipo de problema [SOFTWARE] de [Milagros]
Exception in thread "main" java.lang.UnsupportedOperationException: Solicitud de Milagros con tipo de problema [SOFTWARE] no puede ser procesada
	at dev.magadiflo.patterns.plainjava.behavioral.chainofresponsibility.support.handler.DefaultSupportHandler.handleUnsupported(DefaultSupportHandler.java:11)
````
