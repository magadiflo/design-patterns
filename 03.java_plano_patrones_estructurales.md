# Patrones estructurales

Los `patrones estructurales` se centran en la composici√≥n de clases y objetos para formar estructuras m√°s grandes y
flexibles. Su objetivo es definir `c√≥mo las entidades (clases u objetos) se relacionan entre s√≠` sin perder simplicidad
ni flexibilidad.

En pocas palabras:` nos ayudan a organizar el ‚Äúesqueleto‚Äù del sistema`.

üìå Ejemplos cl√°sicos: `Adapter`, `Decorator`, `Proxy`, `Facade`, etc.

### Caracter√≠sticas comunes

- Se enfocan en las relaciones: herencia, composici√≥n y delegaci√≥n.
- Favorecen la reutilizaci√≥n de c√≥digo, evitando duplicar l√≥gica.
- Permiten abstraer implementaciones y ocultar detalles complejos.
- Promueven la desacoplaci√≥n entre los componentes.
- Se aplican mucho en proyectos grandes donde hay que `integrar sistemas`, `librer√≠as` o `APIs externas`.

---

## Adapter

El `Adapter` es un `patr√≥n estructural` que `permite que dos clases con interfaces incompatibles trabajen juntas`.
Funciona como un traductor entre dos mundos: convierte la interfaz de una clase en otra interfaz que un cliente espera.

üëâ Idea clave: ‚Äúadaptar lo que ya existe para que encaje sin modificarlo‚Äù.

### üìê Representaci√≥n UML del patr√≥n Adapter

![01.png](assets/04-java-plano-estructural/01.png)

1. `Client`: contiene la l√≥gica de negocio existente del programa. No conoce directamente al `Adapter` ni al `Adaptee`,
   sino que interact√∫a a trav√©s de la interfaz `Target`.
2. `Target`: define el protocolo que el `Client` espera usar. Es una interfaz que otras clases deben implementar para
   colaborar con el cliente.
3. `Adaptee`: representa una clase √∫til (normalmente de una biblioteca externa o heredada) cuya interfaz es
   incompatible con `Target`. El cliente no puede utilizarla directamente.
4. `Adapter`: implementa la interfaz `Target` y envuelve una instancia de `Adaptee`. Traduce las llamadas del cliente
   en invocaciones compatibles con `Adaptee`, permitiendo que el cliente use su funcionalidad sin conocer su interfaz
   real.
5. Gracias a que el `Client` depende solo de `Target`, se puede introducir nuevos `Adapter` sin modificar el c√≥digo
   cliente. Esto es √∫til cuando cambia la interfaz de `Adaptee` o se reemplaza por otra clase: basta con crear un nuevo
   `Adapter` que implemente `Target`.

### üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

En la mayor√≠a de aplicaciones modernas necesitamos consumir APIs externas para obtener informaci√≥n que no est√° dentro
de nuestro sistema. Un caso muy com√∫n es la integraci√≥n con proveedores de clima, donde cada servicio ofrece su propia
API con distintos formatos de respuesta y par√°metros.

#### Situaci√≥n

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

#### Soluci√≥n con Adapter

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

- Definiremos una interfaz com√∫n (WeatherService) que la aplicaci√≥n utilizar√°.
- Crearemos un Adapter para cada API externa que traduzca las peticiones y respuestas al formato esperado.
- De esta forma, podremos cambiar o agregar proveedores f√°cilmente sin modificar el resto del sistema.

#### Proveedores de clima a usar

1. `OpenWeatherMap` ‚Üí https://home.openweathermap.org
    - Devolver√° informaci√≥n del clima en un formato JSON propio.
    - Estructura JSON: Campos como `main.temp`, `weather[0].description`, `wind.speed`.
    - Trabajaremos con la estructura `JSON`.


2. `WeatherAPI` ‚Üí https://www.weatherapi.com
    - Tambi√©n ofrece datos de clima, pero con una estructura de respuesta diferente.
    - Estructura JSON o XML: Campos como `current.temp_c`, `current.condition.text`, `current.wind_kph`.
    - Trabajaremos con la estructura `XML`.

### üå§Ô∏è Patr√≥n Adapter con WeatherAPI (XML)

### Verificando modelo XML del proveedor

En esta primera parte vamos a ver que la API `WeatherAPI` nos retorna la siguiente estructura `XML` con la que
estaremos trabajando:

````xml

<?xml version="1.0" encoding="utf-8"?>
<root>
    <location>
        <name>Lima</name>
        <region>Lima</region>
        <country>Peru</country>
        <lat>-12.05</lat>
        <lon>-77.05</lon>
        <tz_id>America/Lima</tz_id>
        <localtime_epoch>1758498001</localtime_epoch>
        <localtime>2025-09-21 18:40</localtime>
    </location>
    <current>
        <last_updated_epoch>1758497400</last_updated_epoch>
        <last_updated>2025-09-21 18:30</last_updated>
        <temp_c>16.6</temp_c>
        <temp_f>61.8</temp_f>
        <is_day>0</is_day>
        <condition>
            <text>Sunny</text>
            <icon>//cdn.weatherapi.com/weather/64x64/night/113.png</icon>
            <code>1000</code>
        </condition>
        <wind_mph>8.9</wind_mph>
        ...
        <gti>0</gti>
    </current>
</root>
````

A partir de esta estructura, necesitamos extraer solo algunos datos relevantes para nuestro modelo `WeatherInfo`:

- `location.name` ‚Üí Ciudad.
- `current.temp_c` ‚Üí Temperatura en Celsius.
- `current.condition.text` ‚Üí Descripci√≥n del clima.

### Justificaci√≥n del uso de Jackson-XML

Por defecto, `Jackson` trabaja con `JSON`, pero para `XML` necesitamos un m√≥dulo adicional: `jackson-dataformat-xml`.

Este m√≥dulo provee la clase `XmlMapper`, que nos permite deserializar directamente un `XML` en clases `Java`
intermedias (`WeatherResponse`, `Location`, `Current`, etc.).

Posteriormente, dentro del `Adapter`, convertiremos esas clases intermedias al modelo est√°ndar de nuestra aplicaci√≥n:
`WeatherInfo`.

### Dependencia necesaria

En nuestro proyecto Maven debemos agregar la siguiente dependencia:

````xml

<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
````

### üìò Modelando la estructura XML del servicio externo en objetos Java

1. `@JsonIgnoreProperties(ignoreUnknown = true)`. Se usa en todas las clases (`Condition`, `Current`, `Location`) para
   ignorar campos del `XML` que no estamos modelando.
   > Esto es √∫til porque el `XML` de `WeatherAPI` trae muchos datos (latitud, longitud, humedad, presi√≥n, etc.),
   > pero en nuestro caso solo nos interesa una parte (ej. ciudad, pa√≠s, temperatura, descripci√≥n del clima).

    - Sin esta anotaci√≥n, `Jackson` lanzar√≠a un error si encuentra propiedades no mapeadas.
    - Con esta anotaci√≥n, `Jackson` simplemente las ignora.
    - Ejemplo aplicado en tu Condition:
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Condition(String text) {
    }
    ````
   Aqu√≠ `Condition` solo mapea `<text>Sunny</text>` y se despreocupa de `<icon>` y `<code>` que tambi√©n vienen en el
   `XML`.


2. `@JacksonXmlProperty(localName = "temp_c")`. Se utiliza en el record `Current` para indicar que el campo
   `temperature` corresponde al nodo `<temp_c>`.
   > `Jackson` por defecto mapear√≠a temperature con `<temperature>`, pero como en el `XML` el campo es `<temp_c>`,
   > necesitamos especificarlo.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Current(@JacksonXmlProperty(localName = "temp_c") double temperature,
                          Condition condition) {
    }
    ````


3. Otra campo a mapear es el `Location`.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Location(String name,
                           String country) {
    }
    ````


4. `@JacksonXmlRootElement(localName = "root")`. Esta anotaci√≥n le dice a `Jackson` cu√°l es el `elemento ra√≠z` del
   `XML`.
    - En nuestro `XML`, todo est√° envuelto en `<root>...</root>`.
    - Por eso, necesitamos marcar el record `WeatherResponse` como la representaci√≥n del `documento ra√≠z`:
    ````java
    
    @JacksonXmlRootElement(localName = "root")
    public record WeatherResponse(Location location,
                                  Current current) {
    }
    ````
   Si no la pones, Jackson intentar√° adivinar el root element y podr√≠as obtener errores al deserializar.

### ‚öôÔ∏è Implementando el Adaptee WeatherApi

En el patr√≥n Adapter, el `Adaptee` representa el componente externo con el que necesitamos interactuar. En este caso,
es la API de `WeatherAPI`, que nos devuelve informaci√≥n del clima en formato XML.

La clase `WeatherApi` cumple ese rol: se conecta al servicio externo, obtiene el XML y lo convierte a nuestro modelo
intermedio `WeatherResponse`.

````java

@Slf4j
public class WeatherApi {

    private static final String API_KEY = "678b1e8441044e6db3054310252109";
    private static final HttpClient httpClient = HttpClient.newHttpClient();
    private static final XmlMapper xmlMapper = new XmlMapper();

    public Optional<WeatherResponse> fetchWeather(String city) {
        try {
            String url = this.buildUrl(city);
            log.info("Consultando clima en XML: {}", url);

            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                log.warn("Respuesta no exitosa: {}", response.statusCode());
                return Optional.empty();
            }

            String xml = response.body();
            WeatherResponse weather = xmlMapper.readValue(xml.getBytes(StandardCharsets.UTF_8), WeatherResponse.class);
            return Optional.of(weather);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // ‚úÖ preserva la se√±al de interrupci√≥n
            log.error("Consulta interrumpida para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        } catch (Exception e) {
            log.error("Error al consultar clima para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        }
    }

    private String buildUrl(String city) {
        return "http://api.weatherapi.com/v1/current.xml?key=%s&q=%s&aqi=yes".formatted(API_KEY, city);
    }
}
````

1. Uso de `HttpClient`
    - Desde `Java 11`, `HttpClient` es la API est√°ndar para realizar peticiones HTTP.
    - Aqu√≠ se configura un cliente b√°sico y reutilizable (patr√≥n singleton con static final).
2. Uso de `XmlMapper` de Jackson
    - Permite deserializar directamente el `XML` en nuestras clases modelo (`WeatherResponse`, `Location`, `Current`,
      `Condition`).
    - Gracias a las anotaciones vistas antes (`@JacksonXmlProperty`, `@JacksonXmlRootElement`, etc.), el mapeo es
      autom√°tico.
3. Manejo de errores y logging
    - Si la API responde distinto de 200 OK, se devuelve `Optional.empty()`.
    - Se manejan dos tipos de excepciones:
        - `InterruptedException`: se restaura la interrupci√≥n del hilo (`Thread.currentThread().interrupt()`) para no
          perder la se√±al.
        - Cualquier otra excepci√≥n ‚Üí log de error y `Optional.empty()`.
    - Esto asegura que nuestro Adaptee nunca rompa la aplicaci√≥n principal, sino que reporte la falla y deje al Adapter
      decidir c√≥mo actuar.

### üéØ Definiendo la Interfaz Target

En el patr√≥n `Adapter`, el `Target` representa la interfaz que la aplicaci√≥n cliente conoce y espera usar.
Toda interacci√≥n con servicios externos debe adaptarse a este contrato com√∫n.

1. Modelo est√°ndar de negocio: `WeatherInfo`

````java
public record WeatherInfo(String city,
                          String country,
                          double temperature,
                          String description) {
}
````

- `Prop√≥sito`: encapsular solo los datos relevantes para el negocio.
- Aqu√≠ se abstrae toda la complejidad del servicio externo (XML, JSON, nombres de campos distintos).
- Contiene:
    - `city`: nombre de la ciudad.
    - `country`: pa√≠s de la ciudad.
    - `temperature`: temperatura en Celsius.
    - `description`: descripci√≥n breve del clima actual.

Este es el modelo can√≥nico que la aplicaci√≥n va a usar, independientemente del proveedor de clima.

2. Interfaz Target: `WeatherService`

````java
public interface WeatherService {
    WeatherInfo getWeather(String city);
}
````

- Define el contrato unificado que la aplicaci√≥n consumir√°.
- Cualquier implementaci√≥n (adapter de `OpenWeatherMap`, adapter de `WeatherAPI`) debe ajustarse a esta firma.
- De esta forma, la l√≥gica de negocio no depende del proveedor de clima, solo de la interfaz com√∫n.

### üîÑ Implementando el Adapter: `WeatherApiAdapter`

El `Adapter` es el coraz√≥n de este patr√≥n. Su objetivo es traducir la interfaz de un servicio externo (`Adaptee`) al
contrato com√∫n que espera la aplicaci√≥n (`Target`).

En este caso, `WeatherApiAdapter` implementa la interfaz `WeatherService` y se apoya en el `Adaptee` (`WeatherApi`)
para realizar la consulta real al proveedor de clima.

````java

@Slf4j
@RequiredArgsConstructor
public class WeatherApiAdapter implements WeatherService {

    private final WeatherApi api;

    @Override
    public WeatherInfo getWeather(String city) {
        return this.api.fetchWeather(city)
                .map(this::toWeatherInfo)
                .orElseThrow(() -> new RuntimeException("No se pudo obtener el clima para " + city));
    }

    private WeatherInfo toWeatherInfo(WeatherResponse response) {
        return new WeatherInfo(
                response.location().name(),
                response.location().country(),
                response.current().temperature(),
                response.current().condition().text()
        );
    }
}
````

### üßë‚Äçüíª Implementando el Client

El `Client` es la pieza final del patr√≥n `Adapter`. Representa al c√≥digo consumidor que necesita trabajar con un
servicio de clima, pero no sabe ni le interesa c√≥mo se conectan los proveedores externos ni en qu√© formato devuelven
la informaci√≥n.

````java

@Slf4j
public class Client {
    public static void main(String[] args) {
        WeatherService weatherService = new WeatherApiAdapter(new WeatherApi());
        WeatherInfo weatherInfo = weatherService.getWeather("Chimbote");
        log.info("{}", weatherInfo);
    }
}
````

Al ejecutar el main, se obtiene:

````bash
00:36:16.291 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.adaptee.WeatherApi -- Consultando clima en XML: http://api.weatherapi.com/v1/current.xml?key=678b1e8441044e6db3054310252109&q=Chimbote&aqi=yes
00:36:17.198 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.Client -- WeatherInfo[city=Chimbote, country=Peru, temperature=16.1, description=Patchy rain nearby] 
````

### üå§Ô∏è Patr√≥n Adapter con OpenWeatherMap (JSON)

### Verificando modelo JSON del proveedor

En esta primera parte vamos a ver que la API `OpenWeatherMap` nos retorna la siguiente estructura `JSON` con la que
estaremos trabajando:

````JSON
{
  "coord": {
    "lon": -78.5783,
    "lat": -9.0853
  },
  "weather": [
    {
      "id": 801,
      "main": "Clouds",
      "description": "few clouds",
      "icon": "02n"
    }
  ],
  "base": "stations",
  "main": {
    "temp": 17.66,
    "feels_like": 17.62,
    "temp_min": 17.66,
    "temp_max": 17.66,
    "pressure": 1013,
    "humidity": 82,
    "sea_level": 1013,
    "grnd_level": 1012
  },
  "visibility": 10000,
  "wind": {
    "speed": 3.99,
    "deg": 175,
    "gust": 5.07
  },
  "clouds": {
    "all": 11
  },
  "dt": 1759019096,
  "sys": {
    "country": "PE",
    "sunrise": 1758970840,
    "sunset": 1759014581
  },
  "timezone": -18000,
  "id": 3698304,
  "name": "Chimbote",
  "cod": 200
}
````

A partir de esta estructura, necesitamos extraer solo algunos datos relevantes para nuestro modelo `WeatherInfo`:

- `name` ‚Üí Ciudad.
- `sys.country` ‚Üí Pa√≠s.
- `main.temp` ‚Üí Temperatura en Celsius.
- `weather[0].description` ‚Üí Descripci√≥n del clima.

### üìò Modelando la estructura JSON del servicio externo en objetos Java

1. `@JsonIgnoreProperties(ignoreUnknown = true)`
    - Se usa en todos los records (`OpenWeatherResponse`, `Main`, `Sys` y `Weather`) para ignorar campos extra en el
      `JSON` que no estamos modelando en nuestras clases.
    - Sin esta anotaci√≥n, `Jackson` lanzar√≠a una excepci√≥n (`UnrecognizedPropertyException`) al encontrar propiedades
      desconocidas.
    - Con esta anotaci√≥n, `Jackson` simplemente las ignora y solo mapea las que hemos definido.

2. `@JsonProperty("weather")`
    - Se utiliza en el record `OpenWeatherResponse` para mapear el campo `weathers` de la clase al atributo `weather`
      del JSON.
    - Esto es necesario porque el nombre en el JSON es `weather` (singular), mientras que en nuestra clase preferimos
      usar weathers (plural) para reflejar que es una lista.
    - En `XML` us√°bamos `@JacksonXmlProperty(localName = "...")`. En `JSON` se usa `@JsonProperty("...")`.

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record OpenWeatherResponse(String name,
                                  Sys sys,
                                  Main main,
                                  @JsonProperty(value = "weather")
                                  List<Weather> weathers) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Sys(String country) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Main(double temp) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Weather(String description) {
}
````

‚úÖ Con esta estructura, Jackson podr√° deserializar directamente la respuesta `JSON` de `OpenWeatherMap` y nosotros
tendremos los campos listos para transformarlos en nuestro modelo de negocio (`WeatherInfo`) dentro del `Adapter`.

### ‚öôÔ∏è Implementando el Adaptee OpenWeatherApi

En el patr√≥n `Adapter`, el `Adaptee` representa el componente externo con el que necesitamos interactuar. En este caso,
es la API de `OpenWeatherMap`, que nos devuelve informaci√≥n del clima en formato `JSON`.

La clase `OpenWeatherApi` cumple ese rol: se conecta al servicio externo, obtiene el JSON y lo convierte a nuestro
modelo intermedio `OpenWeatherResponse`.

````java

@Slf4j
public class OpenWeatherApi {
    private static final String API_KEY = "1e795276e48658194d444a8b37e77bfc";
    private static final HttpClient httpClient = HttpClient.newHttpClient();
    private static final ObjectMapper objectMapper = new ObjectMapper();


    public Optional<OpenWeatherResponse> fetchWeather(String city) {
        try {
            String url = this.buildUrl(city);
            log.info("Consultando clima en JSON: {}", url);

            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                log.warn("Respuesta no exitosa: {}", response.statusCode());
                return Optional.empty();
            }

            String json = response.body();
            OpenWeatherResponse weather = objectMapper.readValue(json, OpenWeatherResponse.class);
            return Optional.of(weather);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // ‚úÖ preserva la se√±al de interrupci√≥n
            log.error("Consulta interrumpida para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        } catch (Exception e) {
            log.error("Error al consultar clima para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        }
    }


    private String buildUrl(String city) {
        return "https://api.openweathermap.org/data/2.5/weather?q=%s&appid=%s&units=metric".formatted(city, API_KEY);
    }
}
````

### üîë Diferencias principales con el Adaptee WeatherApi (XML)

- En lugar de `XmlMapper`, ahora usamos `ObjectMapper` porque trabajamos con `JSON`.
- La URL apunta al endpoint `data/2.5/weather` de `OpenWeatherMap`, usando el par√°metro `units=metric` para trabajar en
  grados Celsius.
- El modelo intermedio es `OpenWeatherResponse`, mapeado con anotaciones de `Jackson`.

### üîÑ Implementando el Adapter: `OpenWeatherApiAdapter`

El `Adapter` es el coraz√≥n de este patr√≥n. Su objetivo es traducir la interfaz de un servicio externo (`Adaptee`) al
contrato com√∫n que espera la aplicaci√≥n (`Target`).

En este caso, `WeatherApiAdapter` implementa la interfaz `WeatherService` y se apoya en el `Adaptee` (`OpenWeatherApi`)
para realizar la consulta real al proveedor de clima.

````java

@Slf4j
@RequiredArgsConstructor
public class OpenWeatherApiAdapter implements WeatherService {

    private final OpenWeatherApi api;

    @Override
    public WeatherInfo getWeather(String city) {
        return this.api.fetchWeather(city)
                .map(this::toWeatherInfo)
                .orElseThrow(() -> new RuntimeException("No se pudo obtener el clima para " + city));
    }

    private WeatherInfo toWeatherInfo(OpenWeatherResponse response) {
        return new WeatherInfo(
                response.name(),
                response.sys().country(),
                response.main().temp(),
                response.weathers().getFirst().description()
        );
    }
}
````

### üßë‚Äçüíª Implementando el Client

El `Client` representa la parte de la aplicaci√≥n que necesita consumir informaci√≥n del clima. Gracias al patr√≥n
`Adapter`:

- El `Client` no necesita saber si los datos provienen de `WeatherAPI (XML)` o `OpenWeather (JSON)`.
- Solo interact√∫a con la interfaz com√∫n `WeatherService`.
- El cambio de proveedor es transparente: basta con inyectar un adapter distinto.

üìå Puntos clave

1. Independencia del formato: `JSON` o `XML`, el `Client` nunca lo ve.
2. Polimorfismo real: `WeatherApiAdapter` y `OpenWeatherApiAdapter` implementan la misma interfaz `WeatherService`.
3. Flexibilidad: agregar un nuevo proveedor no afecta el c√≥digo del `Client`.

````java

@Slf4j
public class Client {
    public static void main(String[] args) {
        WeatherService weatherService = new WeatherApiAdapter(new WeatherApi());
        WeatherInfo weatherInfo = weatherService.getWeather("Chimbote");
        log.info("{}", weatherInfo);

        WeatherService openWeatherService = new OpenWeatherApiAdapter(new OpenWeatherApi());
        WeatherInfo openWeatherInfo = openWeatherService.getWeather("Chimbote");
        log.info("{}", openWeatherInfo);
    }
}
````

‚úÖ Resultado esperado en logs

````bash
20:21:43.300 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.adaptee.WeatherApi -- Consultando clima en XML: http://api.weatherapi.com/v1/current.xml?key=678b1e8441044e6db3054310252109&q=Chimbote&aqi=yes
20:21:43.912 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.Client -- WeatherInfo[city=Chimbote, country=Peru, temperature=17.2, description=Partly Cloudy]
20:21:43.925 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.adaptee.OpenWeatherApi -- Consultando clima en JSON: https://api.openweathermap.org/data/2.5/weather?q=Chimbote&appid=1e795276e48658194d444a8b37e77bfc&units=metric
20:21:44.586 [main] INFO dev.magadiflo.patterns.plainjava.structural.adapter.weather.Client -- WeatherInfo[city=Chimbote, country=PE, temperature=17.35, description=scattered clouds]
````

---

## Proxy

El `patr√≥n Proxy` proporciona un sustituto o intermediario de otro objeto con el fin de controlar el acceso
al objeto original. Act√∫a como intermediario entre el cliente y el objeto real, permitiendo realizar operaciones
adicionales antes, durante o despu√©s de acceder al objeto real.

En otras palabras:

- Tienes un objeto real que hace el trabajo.
- Pones un proxy delante que decide cu√°ndo, c√≥mo o si se llama al objeto real.

Se usa mucho cuando:

- Quieres agregar l√≥gica adicional antes/despu√©s de la ejecuci√≥n.
- Necesitas aplazar (lazy) la creaci√≥n de objetos pesados.
- Quieres controlar el acceso (seguridad, permisos).
- Necesitas manejar acceso remoto (un proxy local representa un objeto en otro servidor).

### üìê Representaci√≥n UML del patr√≥n Proxy

![02.png](assets/04-java-plano-estructural/02.png)

1. `Subject`: Define la interfaz com√∫n para el `RealSubject` y `Proxy`.
    - El `Proxy` debe seguir esta interfaz para poder camuflarse como objeto del `RealSubject`.
    - Establece el contrato que tanto el objeto real como el proxy deben cumplir.
    - Es una interfaz o clase abstracta que declara las operaciones que pueden ser realizadas.
2. `RealSubject`: La implementaci√≥n real del `Subject` que hace el trabajo real.
    - Contiene la l√≥gica de negocio principal y realiza las operaciones reales.
    - Hace el ‚Äútrabajo pesado‚Äù o la acci√≥n final.
3. `Proxy`: Mantiene una referencia al `RealSubject` y controla el acceso a √©l.
    - Implementa la misma interfaz que `RealSubject`.
    - Contiene una referencia al `RealSubject`.
    - Controla el acceso, a√±ade l√≥gica adicional, decide cu√°ndo invocar el real.
    - Crear y eliminar el `RealSubject` cuando sea necesario.
    - Normalmente, los proxies gestionan el ciclo de vida completo de sus objetos `RealSubject`.
4. `Client`: Usa el `Subject` a trav√©s del `Proxy`.
    - Trabaja con objetos `Subject` sin saber si est√° trabajando con el `Proxy` o `RealSubject`.
    - No distingue entre `Proxy` y `RealSubject` ya que ambos implementan la misma interfaz.

### üéØ Ejemplo 01: Proxy + Cache-Aside para Cat√°logo de Productos

En un sistema de `e-commerce`, el cat√°logo de productos es una de las partes m√°s consultadas por los clientes:

- Buscar productos por categor√≠a (ej. ‚Äúzapatos deportivos‚Äù).
- Consultar productos relacionados (ej. ‚Äúquien compr√≥ este producto tambi√©n vio‚Ä¶‚Äù).
- Buscar con filtros avanzados (precio m√≠nimo y m√°ximo, categor√≠a, etc.).

Estas operaciones suelen ser costosas porque:

- Requieren m√∫ltiples consultas a la base de datos.
- Pueden involucrar c√°lculos adicionales (ej. recomendaciones, descuentos, disponibilidad).
- Escalan r√°pidamente si miles de usuarios hacen b√∫squedas al mismo tiempo.

Para mejorar la performance y la experiencia del usuario, muchas empresas aplican cach√©s intermedias (como `Redis` o
`Guava`). En este ejemplo simularemos ese comportamiento implementando el `patr√≥n Proxy` con la estrategia
`Cache-Aside`.

### Modelo de Dominio: `Product`

El record `Product` representa la entidad principal utilizada a lo largo de nuestro ejemplo del `patr√≥n Proxy`.
Simula los datos almacenados en el cat√°logo de productos y es el tipo de objeto que retornan las consultas del
servicio y que es almacenado en cach√© por la capa proxy.

El uso de un record en Java permite mantener el modelo inmutable y conciso, evitando c√≥digo repetitivo
(getters, toString, equals, etc.), pero conservando todos los atributos necesarios para reflejar datos realistas de
un producto en un escenario empresarial.

````java
public record Product(Long id,
                      String name,
                      String category,
                      BigDecimal price,
                      Double rating,
                      String brand,
                      boolean available) {
}
````

En el contexto del `Patr√≥n Proxy` con cach√©:

- `Product` es la entidad de datos que fluye entre el `RealSubject` (`ProductServiceImpl`), el
  `Proxy` (`ProductServiceCacheProxy`) y el `Client`.
- Mientras el `Proxy` controla el acceso y la estrategia de almacenamiento en cach√©, el `Product` permanece como un
  contenedor de informaci√≥n simple, sin verse afectado por la l√≥gica de caching.

### Clases Complementarias

Para hacer m√°s realista el ejemplo del `Patr√≥n Proxy` con `cach√©`, incluimos dos clases auxiliares: una que simula el
origen de datos y otra que representa las entradas en la memoria cach√©.

### `MockProductDatabase`

Esta clase act√∫a como una base de datos simulada en memoria, proporcionando un conjunto inicial de productos de
distintas categor√≠as. Su prop√≥sito es servir como fuente de informaci√≥n para el `RealSubject` (`ProductServiceImpl`),
evitando dependencias externas a bases de datos reales.

- Est√° implementada como `@UtilityClass` para exponer un √∫nico m√©todo est√°tico `initializeDatabase()`.
- Los datos est√°n organizados en categor√≠as (`Electronics`, `Clothing`, `Home`) para permitir consultas m√°s realistas.
- El cat√°logo de productos incluye informaci√≥n variada (precio, calificaci√≥n, marca, disponibilidad), lo que facilita
  la simulaci√≥n de consultas costosas con filtros.

````java

@UtilityClass
public class MockProductDatabase {
    public static List<Product> initializeDatabase() {
        List<Product> products = new ArrayList<>();

        // Electronics
        products.add(new Product(1L, "iPhone 15", "Electronics", new BigDecimal("1200.00"), 4.5, "Apple", true));
        products.add(new Product(2L, "Samsung Galaxy S24", "Electronics", new BigDecimal("1100.00"), 4.3, "Samsung", true));
        products.add(new Product(3L, "MacBook Pro", "Electronics", new BigDecimal("2500.00"), 4.7, "Apple", true));
        products.add(new Product(4L, "Dell XPS 13", "Electronics", new BigDecimal("1800.00"), 4.4, "Dell", true));
        products.add(new Product(5L, "AirPods Pro", "Electronics", new BigDecimal("250.00"), 4.6, "Apple", true));

        // Clothing
        products.add(new Product(6L, "Nike T-Shirt", "Clothing", new BigDecimal("45.00"), 4.2, "Nike", true));
        products.add(new Product(7L, "Levi's Jeans", "Clothing", new BigDecimal("80.00"), 4.4, "Levi's", true));
        products.add(new Product(8L, "Adidas Sneakers", "Clothing", new BigDecimal("120.00"), 4.3, "Adidas", true));
        products.add(new Product(9L, "North Face Jacket", "Clothing", new BigDecimal("200.00"), 4.5, "North Face", true));
        products.add(new Product(10L, "Casio Watch", "Clothing", new BigDecimal("150.00"), 4.1, "Casio", true));

        // Home
        products.add(new Product(11L, "Dyson Vacuum", "Home", new BigDecimal("400.00"), 4.6, "Dyson", true));
        products.add(new Product(12L, "Nespresso Coffee Machine", "Home", new BigDecimal("180.00"), 4.4, "Nespresso", true));
        products.add(new Product(13L, "Ergonomic Chair", "Home", new BigDecimal("300.00"), 4.2, "Herman Miller", true));
        products.add(new Product(14L, "Dining Table", "Home", new BigDecimal("500.00"), 4.3, "IKEA", true));
        products.add(new Product(15L, "LED Lamp", "Home", new BigDecimal("75.00"), 4.0, "Philips", true));

        return products;
    }
}
````

Rol dentro del `Proxy Pattern`:

- Simula el backend real o la base de datos costosa a la que el `RealSubject` accede.
- El `Proxy` cachea los resultados de las consultas a esta base simulada para mejorar tiempos de respuesta.

### `CacheEntry<T>`

Esta clase representa una `entrada en la memoria cach√©`. Encapsula el dato cacheado (`data`), la fecha de
almacenamiento (`timestamp`) y un TTL (`Time-To-Live`) expresado en minutos.

Responsabilidades:

- Asociar un resultado con su momento de almacenamiento.
- Determinar si el dato cacheado ha expirado mediante el m√©todo `isExpired()`.

Detalles t√©cnicos:

- Es gen√©rica (`<T>`), lo que permite reutilizar la l√≥gica de cach√© para distintos tipos de datos, no solo productos.
- El TTL configurable permite simular escenarios comunes de cache-aside donde los datos deben refrescarse cada cierto
  tiempo.

````java
public class CacheEntry<T> {
    @Getter
    private final T data;
    @Getter
    private final LocalDateTime timestamp;
    private final int ttlMinutes;

    public CacheEntry(T data, int ttlMinutes) {
        this.timestamp = LocalDateTime.now();
        this.data = data;
        this.ttlMinutes = ttlMinutes;
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(this.timestamp.plusMinutes(this.ttlMinutes));
    }

}
````

Rol dentro del Proxy Pattern:

- Es el contenedor intermedio que el Proxy utiliza para decidir si devuelve un dato cacheado (cache hit) o si consulta
  nuevamente al RealSubject (cache miss).

### Subject: `ProductService`

La interfaz `ProductService` define el contrato com√∫n que deben implementar tanto el `RealSubject`
(`ProductServiceImpl`) como el `Proxy` (`ProductServiceCacheProxy`). Gracias a este contrato, el cliente puede trabajar
de forma transparente con cualquiera de las implementaciones, sin conocer los detalles internos de acceso a datos ni de
almacenamiento en cach√©.

````java
public interface ProductService {
    List<Product> findByCategory(String category, int page);

    List<Product> getRelatedProducts(Long productId);

    List<Product> searchWithFilters(String category, BigDecimal minPrice, BigDecimal maxPrice);
}
````

Rol dentro del Patr√≥n Proxy

- Define la interfaz com√∫n (`Subject`) entre `cliente`, `Proxy` y `RealSubject`.
- El cliente interact√∫a √∫nicamente con `ProductService`, sin saber si est√° hablando con el servicio real o con un proxy.
- Garantiza que el `Proxy` pueda sustituir al `RealSubject` sin alterar el c√≥digo del cliente (principio de sustituci√≥n
  de Liskov).
