# Patrones estructurales

Los `patrones estructurales` se centran en la composici√≥n de clases y objetos para formar estructuras m√°s grandes y
flexibles. Su objetivo es definir `c√≥mo las entidades (clases u objetos) se relacionan entre s√≠` sin perder simplicidad
ni flexibilidad.

En pocas palabras:` nos ayudan a organizar el ‚Äúesqueleto‚Äù del sistema`.

üìå Ejemplos cl√°sicos: `Adapter`, `Decorator`, `Proxy`, `Facade`, etc.

### Caracter√≠sticas comunes

- Se enfocan en las relaciones: herencia, composici√≥n y delegaci√≥n.
- Favorecen la reutilizaci√≥n de c√≥digo, evitando duplicar l√≥gica.
- Permiten abstraer implementaciones y ocultar detalles complejos.
- Promueven la desacoplaci√≥n entre los componentes.
- Se aplican mucho en proyectos grandes donde hay que `integrar sistemas`, `librer√≠as` o `APIs externas`.

---

## Adapter

El `Adapter` es un `patr√≥n estructural` que `permite que dos clases con interfaces incompatibles trabajen juntas`.
Funciona como un traductor entre dos mundos: convierte la interfaz de una clase en otra interfaz que un cliente espera.

üëâ Idea clave: ‚Äúadaptar lo que ya existe para que encaje sin modificarlo‚Äù.

### üìê Representaci√≥n UML del patr√≥n Adapter

![01.png](assets/04-java-plano-estructural/01.png)

1. `Client`: contiene la l√≥gica de negocio existente del programa. No conoce directamente al `Adapter` ni al `Adaptee`,
   sino que interact√∫a a trav√©s de la interfaz `Target`.
2. `Target`: define el protocolo que el `Client` espera usar. Es una interfaz que otras clases deben implementar para
   colaborar con el cliente.
3. `Adaptee`: representa una clase √∫til (normalmente de una biblioteca externa o heredada) cuya interfaz es
   incompatible con `Target`. El cliente no puede utilizarla directamente.
4. `Adapter`: implementa la interfaz `Target` y envuelve una instancia de `Adaptee`. Traduce las llamadas del cliente
   en invocaciones compatibles con `Adaptee`, permitiendo que el cliente use su funcionalidad sin conocer su interfaz
   real.
5. Gracias a que el `Client` depende solo de `Target`, se puede introducir nuevos `Adapter` sin modificar el c√≥digo
   cliente. Esto es √∫til cuando cambia la interfaz de `Adaptee` o se reemplaza por otra clase: basta con crear un nuevo
   `Adapter` que implemente `Target`.

### üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

En la mayor√≠a de aplicaciones modernas necesitamos consumir APIs externas para obtener informaci√≥n que no est√° dentro
de nuestro sistema. Un caso muy com√∫n es la integraci√≥n con proveedores de clima, donde cada servicio ofrece su propia
API con distintos formatos de respuesta y par√°metros.

#### Situaci√≥n

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

#### Soluci√≥n con Adapter

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

- Definiremos una interfaz com√∫n (WeatherService) que la aplicaci√≥n utilizar√°.
- Crearemos un Adapter para cada API externa que traduzca las peticiones y respuestas al formato esperado.
- De esta forma, podremos cambiar o agregar proveedores f√°cilmente sin modificar el resto del sistema.

#### Proveedores de clima a usar

1. `OpenWeatherMap` ‚Üí https://home.openweathermap.org
    - Devolver√° informaci√≥n del clima en un formato JSON propio.
    - Estructura JSON: Campos como `main.temp`, `weather[0].description`, `wind.speed`.


2. `WeatherAPI` ‚Üí https://www.weatherapi.com
    - Tambi√©n ofrece datos de clima, pero con una estructura de respuesta diferente.
    - Estructura JSON: Campos como `current.temp_c`, `current.condition.text`, `current.wind_kph`.

