# Patrones estructurales

Los `patrones estructurales` se centran en la composici√≥n de clases y objetos para formar estructuras m√°s grandes y
flexibles. Su objetivo es definir `c√≥mo las entidades (clases u objetos) se relacionan entre s√≠` sin perder simplicidad
ni flexibilidad.

En pocas palabras:` nos ayudan a organizar el ‚Äúesqueleto‚Äù del sistema`.

üìå Ejemplos cl√°sicos: `Adapter`, `Decorator`, `Proxy`, `Facade`, etc.

### Caracter√≠sticas comunes

- Se enfocan en las relaciones: herencia, composici√≥n y delegaci√≥n.
- Favorecen la reutilizaci√≥n de c√≥digo, evitando duplicar l√≥gica.
- Permiten abstraer implementaciones y ocultar detalles complejos.
- Promueven la desacoplaci√≥n entre los componentes.
- Se aplican mucho en proyectos grandes donde hay que `integrar sistemas`, `librer√≠as` o `APIs externas`.

---

## Adapter

El `Adapter` es un `patr√≥n estructural` que `permite que dos clases con interfaces incompatibles trabajen juntas`.
Funciona como un traductor entre dos mundos: convierte la interfaz de una clase en otra interfaz que un cliente espera.

üëâ Idea clave: ‚Äúadaptar lo que ya existe para que encaje sin modificarlo‚Äù.

### üìê Representaci√≥n UML del patr√≥n Adapter

![01.png](assets/04-java-plano-estructural/01.png)

1. `Client`, contiene la l√≥gica de negocio existente del programa.
2. `Client interface` describe un protocolo que otras clases deben seguir para poder colaborar con el c√≥digo cliente.
3. `Service` es alguna clase √∫til (normalmente de una tercera parte o heredada). El `client` no puede utilizar
   directamente esta clase porque tiene una interfaz incompatible.
4. `Adapter` es una clase capaz de trabajar tanto con la clase `client` como con la clase `service`: implementa el
   `client interface` mientras envuelve el objeto de la clase `service`. La clase adaptadora recibe llamadas del
   cliente a trav√©s de la interfaz adaptadora y las traduce en llamadas al objeto envuelto de la clase de servicio,
   pero en un formato que pueda comprender.
5. El c√≥digo cliente no se acopla a la clase adaptadora concreta siempre y cuando funcione con la clase adaptadora a
   trav√©s del `client interface`. Gracias a esto, puedes introducir nuevos tipos de adaptadores en el programa sin
   descomponer el c√≥digo cliente existente. Esto puede resultar √∫til cuando la interfaz de la clase de servicio se
   cambia o se sustituye, ya que puedes crear una nueva clase adaptadora sin cambiar el c√≥digo cliente.

