# Patrones estructurales

Los `patrones estructurales` se centran en la composici√≥n de clases y objetos para formar estructuras m√°s grandes y
flexibles. Su objetivo es definir `c√≥mo las entidades (clases u objetos) se relacionan entre s√≠` sin perder simplicidad
ni flexibilidad.

En pocas palabras:` nos ayudan a organizar el ‚Äúesqueleto‚Äù del sistema`.

üìå Ejemplos cl√°sicos: `Adapter`, `Decorator`, `Proxy`, `Facade`, etc.

### Caracter√≠sticas comunes

- Se enfocan en las relaciones: herencia, composici√≥n y delegaci√≥n.
- Favorecen la reutilizaci√≥n de c√≥digo, evitando duplicar l√≥gica.
- Permiten abstraer implementaciones y ocultar detalles complejos.
- Promueven la desacoplaci√≥n entre los componentes.
- Se aplican mucho en proyectos grandes donde hay que `integrar sistemas`, `librer√≠as` o `APIs externas`.

---

## Adapter

El `Adapter` es un `patr√≥n estructural` que `permite que dos clases con interfaces incompatibles trabajen juntas`.
Funciona como un traductor entre dos mundos: convierte la interfaz de una clase en otra interfaz que un cliente espera.

üëâ Idea clave: ‚Äúadaptar lo que ya existe para que encaje sin modificarlo‚Äù.

### üìê Representaci√≥n UML del patr√≥n Adapter

![01.png](assets/04-java-plano-estructural/01.png)

1. `Client`: contiene la l√≥gica de negocio existente del programa. No conoce directamente al `Adapter` ni al `Adaptee`,
   sino que interact√∫a a trav√©s de la interfaz `Target`.
2. `Target`: define el protocolo que el `Client` espera usar. Es una interfaz que otras clases deben implementar para
   colaborar con el cliente.
3. `Adaptee`: representa una clase √∫til (normalmente de una biblioteca externa o heredada) cuya interfaz es
   incompatible con `Target`. El cliente no puede utilizarla directamente.
4. `Adapter`: implementa la interfaz `Target` y envuelve una instancia de `Adaptee`. Traduce las llamadas del cliente
   en invocaciones compatibles con `Adaptee`, permitiendo que el cliente use su funcionalidad sin conocer su interfaz
   real.
5. Gracias a que el `Client` depende solo de `Target`, se puede introducir nuevos `Adapter` sin modificar el c√≥digo
   cliente. Esto es √∫til cuando cambia la interfaz de `Adaptee` o se reemplaza por otra clase: basta con crear un nuevo
   `Adapter` que implemente `Target`.

### üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

En la mayor√≠a de aplicaciones modernas necesitamos consumir APIs externas para obtener informaci√≥n que no est√° dentro
de nuestro sistema. Un caso muy com√∫n es la integraci√≥n con proveedores de clima, donde cada servicio ofrece su propia
API con distintos formatos de respuesta y par√°metros.

#### Situaci√≥n

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

#### Soluci√≥n con Adapter

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

- Definiremos una interfaz com√∫n (WeatherService) que la aplicaci√≥n utilizar√°.
- Crearemos un Adapter para cada API externa que traduzca las peticiones y respuestas al formato esperado.
- De esta forma, podremos cambiar o agregar proveedores f√°cilmente sin modificar el resto del sistema.

#### Proveedores de clima a usar

1. `OpenWeatherMap` ‚Üí https://home.openweathermap.org
    - Devolver√° informaci√≥n del clima en un formato JSON propio.
    - Estructura JSON: Campos como `main.temp`, `weather[0].description`, `wind.speed`.
    - Trabajaremos con la estructura `JSON`.


2. `WeatherAPI` ‚Üí https://www.weatherapi.com
    - Tambi√©n ofrece datos de clima, pero con una estructura de respuesta diferente.
    - Estructura JSON o XML: Campos como `current.temp_c`, `current.condition.text`, `current.wind_kph`.
    - Trabajaremos con la estructura `XML`.

### üå§Ô∏è Patr√≥n Adapter con WeatherAPI (XML)

### Verificando modelo XML del proveedor

En esta primera parte vamos a ver que la API `WeatherAPI` nos retorna la siguiente estructura `XML` con la que
estaremos trabajando:

````xml

<?xml version="1.0" encoding="utf-8"?>
<root>
    <location>
        <name>Lima</name>
        <region>Lima</region>
        <country>Peru</country>
        <lat>-12.05</lat>
        <lon>-77.05</lon>
        <tz_id>America/Lima</tz_id>
        <localtime_epoch>1758498001</localtime_epoch>
        <localtime>2025-09-21 18:40</localtime>
    </location>
    <current>
        <last_updated_epoch>1758497400</last_updated_epoch>
        <last_updated>2025-09-21 18:30</last_updated>
        <temp_c>16.6</temp_c>
        <temp_f>61.8</temp_f>
        <is_day>0</is_day>
        <condition>
            <text>Sunny</text>
            <icon>//cdn.weatherapi.com/weather/64x64/night/113.png</icon>
            <code>1000</code>
        </condition>
        <wind_mph>8.9</wind_mph>
        ...
        <gti>0</gti>
    </current>
</root>
````

A partir de esta estructura, necesitamos extraer solo algunos datos relevantes para nuestro modelo `WeatherInfo`:

- `location.name` ‚Üí Ciudad.
- `current.temp_c` ‚Üí Temperatura en Celsius.
- `current.condition.text` ‚Üí Descripci√≥n del clima.

### Justificaci√≥n del uso de Jackson-XML

Por defecto, `Jackson` trabaja con `JSON`, pero para `XML` necesitamos un m√≥dulo adicional: `jackson-dataformat-xml`.

Este m√≥dulo provee la clase `XmlMapper`, que nos permite deserializar directamente un `XML` en clases `Java`
intermedias (`WeatherResponse`, `Location`, `Current`, etc.).

Posteriormente, dentro del `Adapter`, convertiremos esas clases intermedias al modelo est√°ndar de nuestra aplicaci√≥n:
`WeatherInfo`.

### Dependencia necesaria

En nuestro proyecto Maven debemos agregar la siguiente dependencia:

````xml

<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
````

### üìò Modelando la estructura XML del servicio externo en objetos Java

1. `@JsonIgnoreProperties(ignoreUnknown = true)`. Se usa en todas las clases (`Condition`, `Current`, `Location`) para
   ignorar campos del `XML` que no estamos modelando.
   > Esto es √∫til porque el `XML` de `WeatherAPI` trae muchos datos (latitud, longitud, humedad, presi√≥n, etc.),
   > pero en nuestro caso solo nos interesa una parte (ej. ciudad, pa√≠s, temperatura, descripci√≥n del clima).

    - Sin esta anotaci√≥n, `Jackson` lanzar√≠a un error si encuentra propiedades no mapeadas.
    - Con esta anotaci√≥n, `Jackson` simplemente las ignora.
    - Ejemplo aplicado en tu Condition:
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Condition(String text) {
    }
    ````
   Aqu√≠ `Condition` solo mapea `<text>Sunny</text>` y se despreocupa de `<icon>` y `<code>` que tambi√©n vienen en el
   `XML`.


2. `@JacksonXmlProperty(localName = "temp_c")`. Se utiliza en el record `Current` para indicar que el campo
   `temperature` corresponde al nodo `<temp_c>`.
   > `Jackson` por defecto mapear√≠a temperature con `<temperature>`, pero como en el `XML` el campo es `<temp_c>`,
   > necesitamos especificarlo.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Current(@JacksonXmlProperty(localName = "temp_c") double temperature,
                          Condition condition) {
    }
    ````


3. Otra campo a mapear es el `Location`.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Location(String name,
                           String country) {
    }
    ````


4. `@JacksonXmlRootElement(localName = "root")`. Esta anotaci√≥n le dice a `Jackson` cu√°l es el `elemento ra√≠z` del
   `XML`.
    - En nuestro `XML`, todo est√° envuelto en `<root>...</root>`.
    - Por eso, necesitamos marcar el record `WeatherResponse` como la representaci√≥n del `documento ra√≠z`:
    ````java
    
    @JacksonXmlRootElement(localName = "root")
    public record WeatherResponse(Location location,
                                  Current current) {
    }
    ````
   Si no la pones, Jackson intentar√° adivinar el root element y podr√≠as obtener errores al deserializar.

## ‚öôÔ∏è Implementando el Adaptee WeatherApi

En el patr√≥n Adapter, el `Adaptee` representa el componente externo con el que necesitamos interactuar. En este caso,
es la API de `WeatherAPI`, que nos devuelve informaci√≥n del clima en formato XML.

La clase `WeatherApi` cumple ese rol: se conecta al servicio externo, obtiene el XML y lo convierte a nuestro modelo
intermedio `WeatherResponse`.

````java

@Slf4j
public class WeatherApi {

    private static final String API_KEY = "678b1e8441044e6db3054310252109";
    private static final HttpClient httpClient = HttpClient.newHttpClient();
    private static final XmlMapper xmlMapper = new XmlMapper();

    public Optional<WeatherResponse> fetchWeather(String city) {
        try {
            String url = this.buildUrl(city);
            log.info("Consultando clima en XML: {}", url);

            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .GET()
                    .build();

            HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                log.warn("Respuesta no exitosa: {}", response.statusCode());
                return Optional.empty();
            }

            String xml = response.body();
            WeatherResponse weather = xmlMapper.readValue(xml.getBytes(StandardCharsets.UTF_8), WeatherResponse.class);
            return Optional.of(weather);

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // ‚úÖ preserva la se√±al de interrupci√≥n
            log.error("Consulta interrumpida para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        } catch (Exception e) {
            log.error("Error al consultar clima para {}: {}", city, e.getMessage(), e);
            return Optional.empty();
        }
    }

    private String buildUrl(String city) {
        return "http://api.weatherapi.com/v1/current.xml?key=%s&q=%s&aqi=yes".formatted(API_KEY, city);
    }
}
````

1. Uso de `HttpClient`
    - Desde `Java 11`, `HttpClient` es la API est√°ndar para realizar peticiones HTTP.
    - Aqu√≠ se configura un cliente b√°sico y reutilizable (patr√≥n singleton con static final).
2. Uso de `XmlMapper` de Jackson
    - Permite deserializar directamente el `XML` en nuestras clases modelo (`WeatherResponse`, `Location`, `Current`,
      `Condition`).
    - Gracias a las anotaciones vistas antes (`@JacksonXmlProperty`, `@JacksonXmlRootElement`, etc.), el mapeo es
      autom√°tico.
3. Manejo de errores y logging
    - Si la API responde distinto de 200 OK, se devuelve `Optional.empty()`.
    - Se manejan dos tipos de excepciones:
        - `InterruptedException`: se restaura la interrupci√≥n del hilo (`Thread.currentThread().interrupt()`) para no
          perder la se√±al.
        - Cualquier otra excepci√≥n ‚Üí log de error y `Optional.empty()`.
    - Esto asegura que nuestro Adaptee nunca rompa la aplicaci√≥n principal, sino que reporte la falla y deje al Adapter
      decidir c√≥mo actuar.

### üéØ Definiendo la Interfaz Target

En el patr√≥n `Adapter`, el `Target` representa la interfaz que la aplicaci√≥n cliente conoce y espera usar.
Toda interacci√≥n con servicios externos debe adaptarse a este contrato com√∫n.

1. Modelo est√°ndar de negocio: `WeatherInfo`

````java
public record WeatherInfo(String city,
                          String country,
                          double temperature,
                          String description) {
}
````

- `Prop√≥sito`: encapsular solo los datos relevantes para el negocio.
- Aqu√≠ se abstrae toda la complejidad del servicio externo (XML, JSON, nombres de campos distintos).
- Contiene:
    - `city`: nombre de la ciudad.
    - `country`: pa√≠s de la ciudad.
    - `temperature`: temperatura en Celsius.
    - `description`: descripci√≥n breve del clima actual.

Este es el modelo can√≥nico que la aplicaci√≥n va a usar, independientemente del proveedor de clima.

2. Interfaz Target: `WeatherService`

````java
public interface WeatherService {
    WeatherInfo getWeather(String city);
}
````

- Define el contrato unificado que la aplicaci√≥n consumir√°.
- Cualquier implementaci√≥n (adapter de `OpenWeatherMap`, adapter de `WeatherAPI`) debe ajustarse a esta firma.
- De esta forma, la l√≥gica de negocio no depende del proveedor de clima, solo de la interfaz com√∫n.
