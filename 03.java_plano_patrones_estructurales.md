# Patrones estructurales

Los `patrones estructurales` se centran en la composici√≥n de clases y objetos para formar estructuras m√°s grandes y
flexibles. Su objetivo es definir `c√≥mo las entidades (clases u objetos) se relacionan entre s√≠` sin perder simplicidad
ni flexibilidad.

En pocas palabras:` nos ayudan a organizar el ‚Äúesqueleto‚Äù del sistema`.

üìå Ejemplos cl√°sicos: `Adapter`, `Decorator`, `Proxy`, `Facade`, etc.

### Caracter√≠sticas comunes

- Se enfocan en las relaciones: herencia, composici√≥n y delegaci√≥n.
- Favorecen la reutilizaci√≥n de c√≥digo, evitando duplicar l√≥gica.
- Permiten abstraer implementaciones y ocultar detalles complejos.
- Promueven la desacoplaci√≥n entre los componentes.
- Se aplican mucho en proyectos grandes donde hay que `integrar sistemas`, `librer√≠as` o `APIs externas`.

---

## Adapter

El `Adapter` es un `patr√≥n estructural` que `permite que dos clases con interfaces incompatibles trabajen juntas`.
Funciona como un traductor entre dos mundos: convierte la interfaz de una clase en otra interfaz que un cliente espera.

üëâ Idea clave: ‚Äúadaptar lo que ya existe para que encaje sin modificarlo‚Äù.

### üìê Representaci√≥n UML del patr√≥n Adapter

![01.png](assets/04-java-plano-estructural/01.png)

1. `Client`: contiene la l√≥gica de negocio existente del programa. No conoce directamente al `Adapter` ni al `Adaptee`,
   sino que interact√∫a a trav√©s de la interfaz `Target`.
2. `Target`: define el protocolo que el `Client` espera usar. Es una interfaz que otras clases deben implementar para
   colaborar con el cliente.
3. `Adaptee`: representa una clase √∫til (normalmente de una biblioteca externa o heredada) cuya interfaz es
   incompatible con `Target`. El cliente no puede utilizarla directamente.
4. `Adapter`: implementa la interfaz `Target` y envuelve una instancia de `Adaptee`. Traduce las llamadas del cliente
   en invocaciones compatibles con `Adaptee`, permitiendo que el cliente use su funcionalidad sin conocer su interfaz
   real.
5. Gracias a que el `Client` depende solo de `Target`, se puede introducir nuevos `Adapter` sin modificar el c√≥digo
   cliente. Esto es √∫til cuando cambia la interfaz de `Adaptee` o se reemplaza por otra clase: basta con crear un nuevo
   `Adapter` que implemente `Target`.

### üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

En la mayor√≠a de aplicaciones modernas necesitamos consumir APIs externas para obtener informaci√≥n que no est√° dentro
de nuestro sistema. Un caso muy com√∫n es la integraci√≥n con proveedores de clima, donde cada servicio ofrece su propia
API con distintos formatos de respuesta y par√°metros.

#### Situaci√≥n

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

#### Soluci√≥n con Adapter

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

- Definiremos una interfaz com√∫n (WeatherService) que la aplicaci√≥n utilizar√°.
- Crearemos un Adapter para cada API externa que traduzca las peticiones y respuestas al formato esperado.
- De esta forma, podremos cambiar o agregar proveedores f√°cilmente sin modificar el resto del sistema.

#### Proveedores de clima a usar

1. `OpenWeatherMap` ‚Üí https://home.openweathermap.org
    - Devolver√° informaci√≥n del clima en un formato JSON propio.
    - Estructura JSON: Campos como `main.temp`, `weather[0].description`, `wind.speed`.
    - Trabajaremos con la estructura `JSON`.


2. `WeatherAPI` ‚Üí https://www.weatherapi.com
    - Tambi√©n ofrece datos de clima, pero con una estructura de respuesta diferente.
    - Estructura JSON o XML: Campos como `current.temp_c`, `current.condition.text`, `current.wind_kph`.
    - Trabajaremos con la estructura `XML`.

### üå§Ô∏è Patr√≥n Adapter con WeatherAPI (XML)

### Verificando modelo XML del proveedor

En esta primera parte vamos a ver que la API `WeatherAPI` nos retorna la siguiente estructura `XML` con la que
estaremos trabajando:

````xml

<?xml version="1.0" encoding="utf-8"?>
<root>
    <location>
        <name>Lima</name>
        <region>Lima</region>
        <country>Peru</country>
        <lat>-12.05</lat>
        <lon>-77.05</lon>
        <tz_id>America/Lima</tz_id>
        <localtime_epoch>1758498001</localtime_epoch>
        <localtime>2025-09-21 18:40</localtime>
    </location>
    <current>
        <last_updated_epoch>1758497400</last_updated_epoch>
        <last_updated>2025-09-21 18:30</last_updated>
        <temp_c>16.6</temp_c>
        <temp_f>61.8</temp_f>
        <is_day>0</is_day>
        <condition>
            <text>Sunny</text>
            <icon>//cdn.weatherapi.com/weather/64x64/night/113.png</icon>
            <code>1000</code>
        </condition>
        <wind_mph>8.9</wind_mph>
        ...
        <gti>0</gti>
    </current>
</root>
````

A partir de esta estructura, necesitamos extraer solo algunos datos relevantes para nuestro modelo `WeatherInfo`:

- `location.name` ‚Üí Ciudad.
- `current.temp_c` ‚Üí Temperatura en Celsius.
- `current.condition.text` ‚Üí Descripci√≥n del clima.

### Justificaci√≥n del uso de Jackson-XML

Por defecto, `Jackson` trabaja con `JSON`, pero para `XML` necesitamos un m√≥dulo adicional: `jackson-dataformat-xml`.

Este m√≥dulo provee la clase `XmlMapper`, que nos permite deserializar directamente un `XML` en clases `Java`
intermedias (`WeatherResponse`, `Location`, `Current`, etc.).

Posteriormente, dentro del `Adapter`, convertiremos esas clases intermedias al modelo est√°ndar de nuestra aplicaci√≥n:
`WeatherInfo`.

### Dependencia necesaria

En nuestro proyecto Maven debemos agregar la siguiente dependencia:

````xml

<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
````

### üìò Modelando la estructura XML del servicio externo en objetos Java

1. `@JsonIgnoreProperties(ignoreUnknown = true)`. Se usa en todas las clases (`Condition`, `Current`, `Location`) para
   ignorar campos del `XML` que no estamos modelando.
   > Esto es √∫til porque el `XML` de `WeatherAPI` trae muchos datos (latitud, longitud, humedad, presi√≥n, etc.),
   > pero en nuestro caso solo nos interesa una parte (ej. ciudad, pa√≠s, temperatura, descripci√≥n del clima).

    - Sin esta anotaci√≥n, `Jackson` lanzar√≠a un error si encuentra propiedades no mapeadas.
    - Con esta anotaci√≥n, `Jackson` simplemente las ignora.
    - Ejemplo aplicado en tu Condition:
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Condition(String text) {
    }
    ````
   Aqu√≠ `Condition` solo mapea `<text>Sunny</text>` y se despreocupa de `<icon>` y `<code>` que tambi√©n vienen en el
   `XML`.


2. `@JacksonXmlProperty(localName = "temp_c")`. Se utiliza en el record `Current` para indicar que el campo
   `temperature` corresponde al nodo `<temp_c>`.
   > `Jackson` por defecto mapear√≠a temperature con `<temperature>`, pero como en el `XML` el campo es `<temp_c>`,
   > necesitamos especificarlo.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Current(@JacksonXmlProperty(localName = "temp_c") double temperature,
                          Condition condition) {
    }
    ````


3. Otra campo a mapear es el `Location`.
    ````java
    
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record Location(String name,
                           String country) {
    }
    ````


4. `@JacksonXmlRootElement(localName = "root")`. Esta anotaci√≥n le dice a `Jackson` cu√°l es el `elemento ra√≠z` del
   `XML`.
    - En nuestro `XML`, todo est√° envuelto en `<root>...</root>`.
    - Por eso, necesitamos marcar el record `WeatherResponse` como la representaci√≥n del `documento ra√≠z`:
    ````java
    
    @JacksonXmlRootElement(localName = "root")
    public record WeatherResponse(Location location,
                                  Current current) {
    }
    ````
   Si no la pones, Jackson intentar√° adivinar el root element y podr√≠as obtener errores al deserializar.

