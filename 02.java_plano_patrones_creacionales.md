# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de dise√±o de software` que se centran en la
`creaci√≥n de objetos`. Su prop√≥sito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la l√≥gica de instanciaci√≥n`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es √∫til cuando el proceso de creaci√≥n es complejo, involucra varias etapas o depende de la configuraci√≥n
  del sistema.


- `Encapsular la creaci√≥n de objetos`: Ocultan los detalles de c√≥mo se crean los objetos, lo que facilita el cambio de
  la implementaci√≥n de la creaci√≥n sin afectar el c√≥digo cliente.


- `Promover la flexibilidad y la reutilizaci√≥n`: Al desacoplar el c√≥digo que usa los objetos de la l√≥gica de creaci√≥n,
  puedes cambiar f√°cilmente el tipo de objeto que se crea, adapt√°ndolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creaci√≥n de objetos, promoviendo un
dise√±o de software m√°s robusto, modular y f√°cil de mantener.

üìå Ejemplos cl√°sicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan qu√© clase instanciar.
En otras palabras, delega la creaci√≥n de objetos a las subclases.

### Caracter√≠sticas del Factory Method

‚úÖ Ventajas:

- `Elimina acoplamiento`: El c√≥digo cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: F√°cil agregar nuevos productos sin modificar c√≥digo existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo espec√≠fico
- `Polimorfismo`: Usa herencia y polimorfismo para la creaci√≥n

‚ùå Desventajas:

- `Complejidad`: Introduce m√°s clases al sistema
- `Jerarqu√≠a`: Requiere crear subclases para cada tipo de producto

### üéØ Cu√°ndo usar Factory Method:

- Cuando no sabes de antemano qu√© tipos exactos de objetos necesitar√°s
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcci√≥n de objetos es complejo

### üíº Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones espec√≠ficos seg√∫n el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones seg√∫n el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers seg√∫n extensi√≥n (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers seg√∫n destino (file, console, database)
- `Notificaciones`: Crear notificadores seg√∫n canal (email, SMS, push) ‚Üê Nuestro caso

### üìê Representaci√≥n UML del patr√≥n Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es com√∫n a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el m√©todo de f√°brica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este m√©todo coincida con la interfaz `Product`.
   > Puedes declarar el patr√≥n `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del m√©todo. Como alternativa, el m√©todo de f√°brica base puede devolver alg√∫n tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creaci√≥n de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna l√≥gica de negocios central relacionada con los productos. El
   > patr√≥n `Factory Method` ayuda a desacoplar esta l√≥gica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el m√©todo de f√°brica no tiene que crear nuevas instancias todo el tiempo. Tambi√©n puede devolver
   > objetos existentes de una memor√≠a cach√©, una agrupaci√≥n de objetos, u otra fuente.

### üéØ Ejemplo 01: Sistema de Notificaciones Multi-canal usando Factory Method

Este ejemplo implementa un sistema de notificaciones empresarial que puede enviar mensajes a trav√©s de m√∫ltiples canales
de comunicaci√≥n (Email, SMS, Push Notifications, WhatsApp).

#### `Problem√°tica`

Una aplicaci√≥n de e-commerce necesita notificar a sus usuarios sobre diferentes eventos del negocio (confirmaci√≥n de
pedidos, cambios de estado, promociones, alertas de seguridad) utilizando distintos medios seg√∫n las preferencias del
usuario, la urgencia del mensaje y el tipo de evento.

#### `Soluci√≥n con Factory Method`

En lugar de que el c√≥digo cliente conozca y decida qu√© tipo espec√≠fico de notificaci√≥n crear, se utiliza el patr√≥n
Factory Method para delegar esta responsabilidad a clases especializadas. Cada ConcreteCreator sabe exactamente c√≥mo
configurar y crear su tipo espec√≠fico de notificaci√≥n (configuraciones SMTP para email, APIs de terceros para SMS,
tokens para push notifications, etc.).

#### `Beneficio`

El sistema puede f√°cilmente incorporar nuevos canales de notificaci√≥n (Telegram, Discord, Slack) sin modificar el c√≥digo
cliente existente, y cada factory se encarga de los detalles t√©cnicos espec√≠ficos de su canal, manteniendo el c√≥digo
limpio y desacoplado.

#### `Escenario real`

Similar a lo que implementan plataformas como Amazon, Netflix, o cualquier banco que necesita comunicarse con usuarios a
trav√©s de m√∫ltiples canales de forma consistente y escalable.

### üöÄ Product del Factory Method

En el patr√≥n `Factory Method`, el `Product` define la interfaz o clase abstracta que describe las operaciones que los
objetos creados por la f√°brica deben implementar. Todas las implementaciones concretas del producto seguir√°n este
contrato.

En nuestro caso:

````java
public interface Notification {
    void send(String message, String recipient);

    NotificationChannel getChannel();
}
````

- `Notification` es la interfaz que representa el `Product` en el patr√≥n `Factory Method`. Define el contrato com√∫n que
  todas las implementaciones concretas de notificaciones deben cumplir:
    - `send(String message, String recipient)`: m√©todo para enviar el mensaje a un destinatario.
    - `getChannel()`: m√©todo para identificar el canal de la notificaci√≥n mediante `NotificationChannel`.
- Este dise√±o permite que el c√≥digo cliente interact√∫e con cualquier tipo de notificaci√≥n sin conocer su implementaci√≥n
  concreta.

````java
public enum NotificationChannel {
    EMAIL,
    SMS,
    PUSH,
    WHATSAPP
}
````

- `NotificationChannel` es un enumerador que define los distintos canales de notificaci√≥n que el sistema soporta.
  En el contexto del patr√≥n `Factory Method`, este `enum` act√∫a como criterio para que la f√°brica determine qu√© tipo de
  producto (notificaci√≥n concreta) debe crear.
- Esto evita el uso de cadenas de texto y garantiza seguridad de tipo.

### üöÄ Concrete Products del Factory Method

Los `Concrete Products` son las implementaciones concretas de la interfaz o clase abstracta `Product`, en nuestro caso
implementaciones concretas del `Notification`.

Cada uno define:

- C√≥mo se comporta el producto en su caso espec√≠fico.
- C√≥mo implementa las operaciones definidas por el `Product`.
- Sus propiedades espec√≠ficas necesarias para funcionar.

En este caso, cada `ConcreteProduct` representa un tipo de notificaci√≥n (`EmailNotification`, `PushNotification`,
`SMSNotification`, `WhatsAppNotification`), todos implementando la interfaz `Notification`.

````java

@Slf4j
@RequiredArgsConstructor
public class EmailNotification implements Notification {

    private final String smtpServer;
    private final int port;
    private final String username;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Email Notification ===");
        log.info("SMTP Server: {}:{}", this.smtpServer, this.port);
        log.info("From: {}", this.username);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("Email sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.EMAIL;
    }
}
````

`EmailNotification` es un `Concrete Product` que implementa la interfaz `Notification` para el canal `EMAIL`.

Sus particularidades son:

- `Atributos propios`: `smtpServer`, `port`, `username` necesarios para configurar el env√≠o de correos electr√≥nicos.
- `Implementaci√≥n de send`: contiene la l√≥gica para enviar un email (en este ejemplo se simula mediante logs).
- `Implementaci√≥n de getChannel`: devuelve el valor `NotificationChannel.EMAIL` para identificar el canal que
  representa.

Relaci√≥n con el patr√≥n:

- La f√°brica se encargar√° de instanciar este producto cuando se solicite una notificaci√≥n de tipo `EMAIL`.
- El cliente no necesita saber c√≥mo se configura o env√≠a el correo, solo que puede invocar `send(...)`.

A continuaci√≥n se muestra el c√≥digo de los dem√°s `concret products`.

````java

@Slf4j
@RequiredArgsConstructor
public class PushNotification implements Notification {

    private final String firebaseKey;
    private final String appId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Push Notification ===");
        log.info("Firebase Key: {}", this.firebaseKey.substring(0, 10) + "...");
        log.info("APP ID: {}", this.appId);
        log.info("Device Token: {}", recipient);
        log.info("Message: {}", message);
        log.info("Push notification sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.PUSH;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class SMSNotification implements Notification {

    private final String apiKey;
    private final String provider;

    @Override
    public void send(String message, String recipient) {
        log.info("=== SMS Notification ===");
        log.info("Provider: {}", this.provider);
        log.info("API Key: {}", this.apiKey.substring(0, 8) + "...");
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("SMS sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.SMS;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class WhatsAppNotification implements Notification {

    private final String businessApiKey;
    private final String phoneNumberId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== WhatsApp Notification ===");
        log.info("Business API KEY: {}", this.businessApiKey.substring(0, 12) + "...");
        log.info("Phone Number ID: {}", this.phoneNumberId);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("WhatsApp message sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.WHATSAPP;
    }
}
````

### üöÄ Creator del Factory Method

La clase abstracta `NotificationCreator` es la clase `Creator` dentro del patr√≥n `Factory Method`.

Su rol es definir el `m√©todo f√°brica` abstracto (`createNotification()`), que ser√° implementado por las subclases para
instanciar el `Concrete Product` correspondiente.

````java

@Slf4j
public abstract class NotificationCreator {

    public void processNotification(String message, String recipient) {
        // Usar el factory method para crear la notificaci√≥n apropiada
        Notification notification = this.createNotification();

        // L√≥gica de negocio adicional antes del env√≠o
        log.info("Procesando {} notification...", notification.getChannel());

        // Validaciones generales (l√≥gica de negocio com√∫n)
        if (Objects.isNull(message) || message.isBlank()) {
            log.error("El mensaje no puede estar vac√≠o");
            return;
        }

        if (Objects.isNull(recipient) || recipient.isBlank()) {
            log.error("El destinatario no puede estar vac√≠o");
            return;
        }

        // Enviar la notificaci√≥n usando polimorfismo
        notification.send(message, recipient);

        // L√≥gica de negocio despu√©s del env√≠o (logging, m√©tricas, etc)
        log.info("Logged: {} notificaci√≥n enviado a {}", notification.getChannel(), recipient);
    }

    // Factory Method - debe ser implementado por las subclases
    public abstract Notification createNotification();
}
````

Adem√°s, en este ejemplo:

- Incluye el m√©todo `processNotification(...)` que encapsula un flujo com√∫n de negocio:
    1. Crea la notificaci√≥n a trav√©s del m√©todo f√°brica.
    2. Aplica validaciones generales (mensaje y destinatario no vac√≠os).
    3. Env√≠a la notificaci√≥n mediante `polimorfismo`.
    4. Ejecuta tareas posteriores (`logging`, `m√©tricas`).

- De esta forma, `la l√≥gica de creaci√≥n queda delegada a las subclases`, pero la l√≥gica de uso y validaciones comunes
  se mantiene centralizada en el `Creator`.

Beneficio en el patr√≥n:

- Separa el `‚Äúqu√© hacer‚Äù` (flujo com√∫n en `processNotification(...)`) de el `‚Äúcon qu√© hacerlo‚Äù`
  (implementaci√≥n de `createNotification()` en subclases).
- Permite a√±adir nuevos canales de notificaci√≥n sin modificar el `Creator`, solo creando nuevas subclases.
