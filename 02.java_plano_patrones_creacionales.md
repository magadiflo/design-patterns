# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de dise√±o de software` que se centran en la
`creaci√≥n de objetos`. Su prop√≥sito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la l√≥gica de instanciaci√≥n`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es √∫til cuando el proceso de creaci√≥n es complejo, involucra varias etapas o depende de la configuraci√≥n
  del sistema.


- `Encapsular la creaci√≥n de objetos`: Ocultan los detalles de c√≥mo se crean los objetos, lo que facilita el cambio de
  la implementaci√≥n de la creaci√≥n sin afectar el c√≥digo cliente.


- `Promover la flexibilidad y la reutilizaci√≥n`: Al desacoplar el c√≥digo que usa los objetos de la l√≥gica de creaci√≥n,
  puedes cambiar f√°cilmente el tipo de objeto que se crea, adapt√°ndolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creaci√≥n de objetos, promoviendo un
dise√±o de software m√°s robusto, modular y f√°cil de mantener.

üìå Ejemplos cl√°sicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan qu√© clase instanciar.
En otras palabras, delega la creaci√≥n de objetos a las subclases.

### Caracter√≠sticas del Factory Method

‚úÖ Ventajas:

- `Elimina acoplamiento`: El c√≥digo cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: F√°cil agregar nuevos productos sin modificar c√≥digo existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo espec√≠fico
- `Polimorfismo`: Usa herencia y polimorfismo para la creaci√≥n

‚ùå Desventajas:

- `Complejidad`: Introduce m√°s clases al sistema
- `Jerarqu√≠a`: Requiere crear subclases para cada tipo de producto

### üéØ Cu√°ndo usar Factory Method:

- Cuando no sabes de antemano qu√© tipos exactos de objetos necesitar√°s
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcci√≥n de objetos es complejo

### üíº Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones espec√≠ficos seg√∫n el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones seg√∫n el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers seg√∫n extensi√≥n (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers seg√∫n destino (file, console, database)
- `Notificaciones`: Crear notificadores seg√∫n canal (email, SMS, push) ‚Üê Nuestro caso

### üìê Representaci√≥n UML del patr√≥n Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es com√∫n a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el m√©todo de f√°brica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este m√©todo coincida con la interfaz `Product`.
   > Puedes declarar el patr√≥n `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del m√©todo. Como alternativa, el m√©todo de f√°brica base puede devolver alg√∫n tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creaci√≥n de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna l√≥gica de negocios central relacionada con los productos. El
   > patr√≥n `Factory Method` ayuda a desacoplar esta l√≥gica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el m√©todo de f√°brica no tiene que crear nuevas instancias todo el tiempo. Tambi√©n puede devolver
   > objetos existentes de una memor√≠a cach√©, una agrupaci√≥n de objetos, u otra fuente.

### üéØ Ejemplo 01: Sistema de Notificaciones Multi-canal usando Factory Method

Este ejemplo implementa un sistema de notificaciones empresarial que puede enviar mensajes a trav√©s de m√∫ltiples canales
de comunicaci√≥n (`Email`, `SMS`, `Push Notifications`, `WhatsApp`).

#### `Problem√°tica`

Una aplicaci√≥n de e-commerce necesita notificar a sus usuarios sobre diferentes eventos del negocio (confirmaci√≥n de
pedidos, cambios de estado, promociones, alertas de seguridad) utilizando distintos medios seg√∫n las preferencias del
usuario, la urgencia del mensaje y el tipo de evento.

#### `Soluci√≥n con Factory Method`

En lugar de que el c√≥digo cliente conozca y decida qu√© tipo espec√≠fico de notificaci√≥n crear, se utiliza el patr√≥n
Factory Method para delegar esta responsabilidad a clases especializadas. Cada ConcreteCreator sabe exactamente c√≥mo
configurar y crear su tipo espec√≠fico de notificaci√≥n (configuraciones SMTP para email, APIs de terceros para SMS,
tokens para push notifications, etc.).

#### `Beneficio`

El sistema puede f√°cilmente incorporar nuevos canales de notificaci√≥n (Telegram, Discord, Slack) sin modificar el c√≥digo
cliente existente, y cada factory se encarga de los detalles t√©cnicos espec√≠ficos de su canal, manteniendo el c√≥digo
limpio y desacoplado.

#### `Escenario real`

Similar a lo que implementan plataformas como Amazon, Netflix, o cualquier banco que necesita comunicarse con usuarios a
trav√©s de m√∫ltiples canales de forma consistente y escalable.

El siguiente diagrama de clases muestra la implementaci√≥n de nuestro patr√≥n `Factory Method`.

![02.png](assets/03-java-plano-creacional/02.png)

### üöÄ Product del Factory Method

En el patr√≥n `Factory Method`, el `Product` define la interfaz o clase abstracta que describe las operaciones que los
objetos creados por la f√°brica deben implementar. Todas las implementaciones concretas del producto seguir√°n este
contrato.

En nuestro caso:

````java
public interface Notification {
    void send(String message, String recipient);

    NotificationChannel getChannel();
}
````

- `Notification` es la interfaz que representa el `Product` en el patr√≥n `Factory Method`. Define el contrato com√∫n que
  todas las implementaciones concretas de notificaciones deben cumplir:
    - `send(String message, String recipient)`: m√©todo para enviar el mensaje a un destinatario.
    - `getChannel()`: m√©todo para identificar el canal de la notificaci√≥n mediante `NotificationChannel`.
- Este dise√±o permite que el c√≥digo cliente interact√∫e con cualquier tipo de notificaci√≥n sin conocer su implementaci√≥n
  concreta.

````java
public enum NotificationChannel {
    EMAIL,
    SMS,
    PUSH,
    WHATSAPP
}
````

- `NotificationChannel` es un enumerador que define los distintos canales de notificaci√≥n que el sistema soporta.
  En el contexto del patr√≥n `Factory Method`, este `enum` act√∫a como criterio para que la f√°brica determine qu√© tipo de
  producto (notificaci√≥n concreta) debe crear.
- Esto evita el uso de cadenas de texto y garantiza seguridad de tipo.

### üöÄ Concrete Products del Factory Method

Los `Concrete Products` son las implementaciones concretas de la interfaz o clase abstracta `Product`, en nuestro caso
implementaciones concretas del `Notification`.

Cada uno define:

- C√≥mo se comporta el producto en su caso espec√≠fico.
- C√≥mo implementa las operaciones definidas por el `Product`.
- Sus propiedades espec√≠ficas necesarias para funcionar.

En este caso, cada `ConcreteProduct` representa un tipo de notificaci√≥n (`EmailNotification`, `PushNotification`,
`SMSNotification`, `WhatsAppNotification`), todos implementando la interfaz `Notification`.

````java

@Slf4j
@RequiredArgsConstructor
public class EmailNotification implements Notification {

    private final String smtpServer;
    private final int port;
    private final String username;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Email Notification ===");
        log.info("SMTP Server: {}:{}", this.smtpServer, this.port);
        log.info("From: {}", this.username);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("Email sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.EMAIL;
    }
}
````

`EmailNotification` es un `Concrete Product` que implementa la interfaz `Notification` para el canal `EMAIL`.

Sus particularidades son:

- `Atributos propios`: `smtpServer`, `port`, `username` necesarios para configurar el env√≠o de correos electr√≥nicos.
- `Implementaci√≥n de send`: contiene la l√≥gica para enviar un email (en este ejemplo se simula mediante logs).
- `Implementaci√≥n de getChannel`: devuelve el valor `NotificationChannel.EMAIL` para identificar el canal que
  representa.

Relaci√≥n con el patr√≥n:

- La f√°brica se encargar√° de instanciar este producto cuando se solicite una notificaci√≥n de tipo `EMAIL`.
- El cliente no necesita saber c√≥mo se configura o env√≠a el correo, solo que puede invocar `send(...)`.

A continuaci√≥n se muestra el c√≥digo de los dem√°s `concret products`.

````java

@Slf4j
@RequiredArgsConstructor
public class PushNotification implements Notification {

    private final String firebaseKey;
    private final String appId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Push Notification ===");
        log.info("Firebase Key: {}", this.firebaseKey.substring(0, 10) + "...");
        log.info("APP ID: {}", this.appId);
        log.info("Device Token: {}", recipient);
        log.info("Message: {}", message);
        log.info("Push notification sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.PUSH;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class SMSNotification implements Notification {

    private final String apiKey;
    private final String provider;

    @Override
    public void send(String message, String recipient) {
        log.info("=== SMS Notification ===");
        log.info("Provider: {}", this.provider);
        log.info("API Key: {}", this.apiKey.substring(0, 8) + "...");
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("SMS sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.SMS;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class WhatsAppNotification implements Notification {

    private final String businessApiKey;
    private final String phoneNumberId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== WhatsApp Notification ===");
        log.info("Business API KEY: {}", this.businessApiKey.substring(0, 12) + "...");
        log.info("Phone Number ID: {}", this.phoneNumberId);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("WhatsApp message sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.WHATSAPP;
    }
}
````

### üöÄ Creator del Factory Method

La clase abstracta `NotificationCreator` es la clase `Creator` dentro del patr√≥n `Factory Method`.

Su rol es definir el `m√©todo f√°brica` abstracto (`createNotification()`), que ser√° implementado por las subclases para
instanciar el `Concrete Product` correspondiente.

````java

@Slf4j
public abstract class NotificationCreator {

    public void processNotification(String message, String recipient) {
        // Usar el factory method para crear la notificaci√≥n apropiada
        Notification notification = this.createNotification();

        // L√≥gica de negocio adicional antes del env√≠o
        log.info("Procesando {} notification...", notification.getChannel());

        // Validaciones generales (l√≥gica de negocio com√∫n)
        if (Objects.isNull(message) || message.isBlank()) {
            log.error("El mensaje no puede estar vac√≠o");
            return;
        }

        if (Objects.isNull(recipient) || recipient.isBlank()) {
            log.error("El destinatario no puede estar vac√≠o");
            return;
        }

        // Enviar la notificaci√≥n usando polimorfismo
        notification.send(message, recipient);

        // L√≥gica de negocio despu√©s del env√≠o (logging, m√©tricas, etc)
        log.info("Logged: {} notificaci√≥n enviado a {}", notification.getChannel(), recipient);
    }

    // Factory Method - debe ser implementado por las subclases
    public abstract Notification createNotification();
}
````

Adem√°s, en este ejemplo:

- Incluye el m√©todo `processNotification(...)` que encapsula un flujo com√∫n de negocio:
    1. Crea la notificaci√≥n a trav√©s del m√©todo f√°brica.
    2. Aplica validaciones generales (mensaje y destinatario no vac√≠os).
    3. Env√≠a la notificaci√≥n mediante `polimorfismo`.
    4. Ejecuta tareas posteriores (`logging`, `m√©tricas`).

- De esta forma, `la l√≥gica de creaci√≥n queda delegada a las subclases`, pero la l√≥gica de uso y validaciones comunes
  se mantiene centralizada en el `Creator`.

Beneficio en el patr√≥n:

- Separa el `‚Äúqu√© hacer‚Äù` (flujo com√∫n en `processNotification(...)`) de el `‚Äúcon qu√© hacerlo‚Äù`
  (implementaci√≥n de `createNotification()` en subclases).
- Permite a√±adir nuevos canales de notificaci√≥n sin modificar el `Creator`, solo creando nuevas subclases.

### üöÄ Concrete Creator del Factory Method

Los `Concrete Creators` son las subclases que implementan el `m√©todo f√°brica` definido en el `Creator`. Su funci√≥n
principal es:

- Decidir `qu√© producto concreto` se va a crear.
- Encapsular la l√≥gica de instanciaci√≥n del producto.
- Devolver un objeto que implementa la interfaz o clase abstracta `Product`, en nuestro caso retornar√° una
  implementaci√≥n de la interfaz `Notification`.

Beneficios:

- El c√≥digo cliente no conoce ni depende de las clases concretas de los productos.
- Facilita la extensi√≥n: para agregar un nuevo producto, solo se crea un nuevo `Concrete Creator`.

````java
public class EmailNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new EmailNotification("smtp.company.com", 587, "notifications@company.com");
    }
}
````

`EmailNotificationCreator` es un `Concrete Creator` que implementa el m√©todo `createNotification()` para instanciar un
`EmailNotification` preconfigurado con:

- Servidor SMTP (smtp.company.com)
- Puerto (587)
- Direcci√≥n remitente (notifications@company.com)

Relaci√≥n con el patr√≥n:

- Esta clase sabe exactamente qu√© tipo de producto crear (`EmailNotification`) y con qu√© par√°metros configurarlo.
- El cliente no necesita saber c√≥mo se crea o qu√© datos requiere el producto: solo llama a `processNotification()`
  en el `Creator` y recibe el comportamiento adecuado.

A continuaci√≥n se muestras los dem√°s `Concrete Creators`.

````java
public class PushNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new PushNotification("firebase_server_key_def456", "com.company.app");
    }
}
````

````java
public class SMSNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new SMSNotification("twilio_api_key_abc123xyz", "Twilio");
    }
}
````

````java
public class WhatsAppNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new WhatsAppNotification("whatsapp_business_key_ghi789", "943854789");
    }
}
````

### üöÄ Uso del Patr√≥n Factory Method

En el `Factory Method`, el `Cliente` no crea directamente los productos, sino que trabaja con el `Creator`
(o `Concrete Creator`) y, a trav√©s de √©l, obtiene el `Product` correcto sin conocer su clase concreta.

En el patr√≥n `Factory Method`, el `Cliente` es la pieza que:

1. Elige qu√© `ConcreteCreator` utilizar seg√∫n el contexto o requerimiento.
2. Invoca el flujo de negocio del `Creator` (en este caso `processNotification(...)`), que internamente usa el
   `factory method` para crear el `Product` adecuado.
3. Consume el producto sin conocer su implementaci√≥n concreta.

En este ejemplo:

- La clase `Main` act√∫a como `Cliente`.
- Para cada escenario:
    - Instancia un `ConcreteCreator` espec√≠fico (`EmailNotificationCreator`, `SMSNotificationCreator`, etc.).
    - Llama a `processNotification`, delegando en el `Creator` la validaci√≥n, la creaci√≥n del producto y el env√≠o.
- Gracias al patr√≥n, el `Cliente` nunca llama directamente a `new EmailNotification(...)` ni a ninguna otra
  implementaci√≥n de `Notification`. Toda la creaci√≥n queda encapsulada en los `ConcreteCreator`.

Beneficio en este punto:

- Si ma√±ana se agrega un nuevo canal de notificaci√≥n (por ejemplo, `Telegram`), no es necesario modificar el c√≥digo de
  `Main` para saber c√≥mo se crea o configura; solo instanciar el nuevo `Creator`.
- Esto asegura bajo acoplamiento y mayor facilidad de mantenimiento.

````java

@Slf4j
public class Main {

    private static final String SEPARATOR = "================================================================";

    public static void main(String[] args) {
        log.info("FACTORY METHOD PATTERN - Sistema de Notificaciones Multi-canal");
        log.info(SEPARATOR);

        // Escenario 01: Confirmaci√≥n de Pedido (Email)
        log.info("Escenario 01: Confirmaci√≥n de Pedido");
        NotificationCreator emailCreator = new EmailNotificationCreator();
        emailCreator.processNotification(
                "Su pedido #415 ha sido confirmado. Total: S/ 1500.00",
                "cliente@example.com");


        // Escenario 02: Alerta urgente (SMS)
        log.info(SEPARATOR);
        log.info("Escenario 02: Alerta de seguridad");
        NotificationCreator smsCreator = new SMSNotificationCreator();
        smsCreator.processNotification(
                "C√≥digo de verificaci√≥n: 123456. V√°lido por 5 minutos.",
                "+51946741485");


        // Escenario 03: Promoci√≥n (Push)
        log.info(SEPARATOR);
        log.info("Escenario 03: Notificaci√≥n Push - Promoci√≥n");
        NotificationCreator pushCreator = new PushNotificationCreator();
        pushCreator.processNotification(
                "¬°50% OFF en todos los productos! Aprovecha ahora.",
                "device_token_abc123xyz789");


        // Escenario 04: Soporte personalizado (WhatsApp)
        log.info(SEPARATOR);
        log.info("Escenario 04: Soporte WhatsApp");
        NotificationCreator whatsAppCreator = new WhatsAppNotificationCreator();
        whatsAppCreator.processNotification(
                "Hola! Su consulta ha sido recibida. Un agente le responder√° pronto.",
                "+51987458778");
    }
}
````

### üß™ Ejecuci√≥n y validaci√≥n del patr√≥n

Verificar que el cliente (`Main`) pueda enviar notificaciones por distintos canales sin conocer los detalles de
creaci√≥n de cada implementaci√≥n concreta.

````bash
factorymethod.notification.Main -- FACTORY METHOD PATTERN - Sistema de Notificaciones Multi-canal
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 01: Confirmaci√≥n de Pedido
factorymethod.notification.factory.NotificationCreator -- Procesando EMAIL notification...
factorymethod.notification.model.EmailNotification -- === Email Notification ===
factorymethod.notification.model.EmailNotification -- SMTP Server: smtp.company.com:587
factorymethod.notification.model.EmailNotification -- From: notifications@company.com
factorymethod.notification.model.EmailNotification -- To: cliente@example.com
factorymethod.notification.model.EmailNotification -- Message: Su pedido #415 ha sido confirmado. Total: S/ 1500.00
factorymethod.notification.model.EmailNotification -- Email sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: EMAIL notificaci√≥n enviado a cliente@example.com
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 02: Alerta de seguridad
factorymethod.notification.factory.NotificationCreator -- Procesando SMS notification...
factorymethod.notification.model.SMSNotification -- === SMS Notification ===
factorymethod.notification.model.SMSNotification -- Provider: Twilio
factorymethod.notification.model.SMSNotification -- API Key: twilio_a...
factorymethod.notification.model.SMSNotification -- To: +51946741485
factorymethod.notification.model.SMSNotification -- Message: C√≥digo de verificaci√≥n: 123456. V√°lido por 5 minutos.
factorymethod.notification.model.SMSNotification -- SMS sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: SMS notificaci√≥n enviado a +51946741485
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 03: Notificaci√≥n Push - Promoci√≥n
factorymethod.notification.factory.NotificationCreator -- Procesando PUSH notification...
factorymethod.notification.model.PushNotification -- === Push Notification ===
factorymethod.notification.model.PushNotification -- Firebase Key: firebase_s...
factorymethod.notification.model.PushNotification -- APP ID: com.company.app
factorymethod.notification.model.PushNotification -- Device Token: device_token_abc123xyz789
factorymethod.notification.model.PushNotification -- Message: ¬°50% OFF en todos los productos! Aprovecha ahora.
factorymethod.notification.model.PushNotification -- Push notification sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: PUSH notificaci√≥n enviado a device_token_abc123xyz789
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 04: Soporte WhatsApp
factorymethod.notification.factory.NotificationCreator -- Procesando WHATSAPP notification...
factorymethod.notification.model.WhatsAppNotification -- === WhatsApp Notification ===
factorymethod.notification.model.WhatsAppNotification -- Business API KEY: whatsapp_bus...
factorymethod.notification.model.WhatsAppNotification -- Phone Number ID: 943854789
factorymethod.notification.model.WhatsAppNotification -- To: +51987458778
factorymethod.notification.model.WhatsAppNotification -- Message: Hola! Su consulta ha sido recibida. Un agente le responder√° pronto.
factorymethod.notification.model.WhatsAppNotification -- WhatsApp message sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: WHATSAPP notificaci√≥n enviado a +51987458778
````

La ejecuci√≥n confirma que:

- El patr√≥n `Factory Method` se implement√≥ correctamente.
- Cada escenario de notificaci√≥n funciona de manera independiente.
- Se logra flexibilidad y extensibilidad, cumpliendo los objetivos del patr√≥n.

---

## Builder

El patr√≥n `Builder` es un patr√≥n de dise√±o creacional que permite `construir objetos complejos paso a paso`, de manera
que el mismo proceso de construcci√≥n pueda crear diferentes representaciones. Este patr√≥n es especialmente √∫til cuando:

- Un objeto requiere muchos par√°metros para su construcci√≥n.
- Algunos par√°metros son opcionales.
- El proceso de construcci√≥n debe ser independiente de las partes que componen el objeto.
- Se necesita crear diferentes representaciones del mismo objeto.

### üß© Problema que resuelve

- `Constructor telesc√≥pico`: M√∫ltiples constructores con diferentes combinaciones de par√°metros.
- `Objetos inconsistentes`: Construcci√≥n en m√∫ltiples pasos donde el objeto puede quedar en estado inv√°lido.
- `C√≥digo poco legible`: Dif√≠cil entender qu√© par√°metro corresponde a qu√© atributo.
- `Par√°metros opcionales`: Manejo complejo de par√°metros opcionales.

Ejemplo del problema

````java
// Constructor telesc√≥pico - dif√≠cil de mantener y entender
User user = new User("John", "Doe", "john@email.com", "123456789",
                "123 Main St", "New York", "NY", "10001",
                true, false, "Manager", "IT");
// ¬øQu√© representa cada par√°metro?
//
// Algunos valores como "john@email.com" sugieren claramente que se trata de un correo electr√≥nico.
// Pero otros, como "10001", ¬øa qu√© atributo corresponden? ¬øEs un c√≥digo postal, un ID, un n√∫mero interno?
// La relaci√≥n entre valores y atributos no es evidente, lo que dificulta la lectura y el mantenimiento.
// Si el orden cambia accidentalmente, el c√≥digo puede seguir compilando pero comportarse de forma incorrecta.
````

### Caracter√≠sticas del Patr√≥n

- `Construcci√≥n paso a paso`: Permite crear objetos complejos de forma incremental, asignando atributos de manera
  controlada.
- `Compatibilidad con inmutabilidad`: El producto final `puede ser inmutable` si el dise√±o lo requiere, pero no es
  obligatorio. Por ejemplo, en entidades JPA se necesita mutabilidad.
- `Flexibilidad`: Diferentes builders pueden construir distintas representaciones del mismo tipo de objeto, adapt√°ndose
  a distintos contextos.
- `Legibilidad`: Facilita una API fluida y expresiva, evitando constructores telesc√≥picos y mejorando la comprensi√≥n
  del c√≥digo.
- `Validaci√≥n`: Permite validar el estado del objeto antes de construirlo, centralizando reglas de negocio o
  consistencia.

> üí° `Nota`: La inmutabilidad es una pr√°ctica recomendada en objetos que no deben cambiar su estado una vez creados,
> como DTOs o configuraciones. Sin embargo, en frameworks como Spring Boot, las entidades suelen requerir mutabilidad
> para funcionar correctamente con JPA.

### üìê Representaci√≥n UML del patr√≥n Builder Cl√°sico (GoF)

![03.png](assets/03-java-plano-creacional/03.png)

1. La interfaz `Builder` declara pasos de construcci√≥n de producto que todos los tipos de objetos constructores tienen
   en com√∫n.
2. Los `Concrete Builders` ofrecen distintas implementaciones de los pasos de construcci√≥n. Los `Concrete Builders`
   pueden crear productos que no siguen la interfaz com√∫n.
3. El `Product` es el objeto complejo que se est√° construyendo.
4. La clase `Director` define el orden en el que se invocar√°n los pasos de construcci√≥n.
5. El `Client` usa el `Director` y el `Builder` para construir el objeto.

### Variantes del Patr√≥n

1. `Builder Cl√°sico (GoF)`
    - Usa `Director` para coordinar la construcci√≥n.
    - Interfaz `Builder` separada.
    - M√∫ltiples `ConcreteBuilders` posibles.


2. `Fluent Builder (Moderno)`
    - M√°s com√∫n en el mundo real.
    - API fluida con encadenamiento de m√©todos.
    - Sin `Director` expl√≠cito.
    - Patr√≥n `Method Chaining` integrado.
    ````java
    // Ejemplo Fluent Builder
    User user = User.builder()
            .firstName("John")
            .lastName("Doe")
            .email("john@email.com")
            .phone("123456789")
            .address("123 Main St")
            .city("New York")
            .build();
    ````
