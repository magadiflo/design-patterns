# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de dise√±o de software` que se centran en la
`creaci√≥n de objetos`. Su prop√≥sito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la l√≥gica de instanciaci√≥n`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es √∫til cuando el proceso de creaci√≥n es complejo, involucra varias etapas o depende de la configuraci√≥n
  del sistema.


- `Encapsular la creaci√≥n de objetos`: Ocultan los detalles de c√≥mo se crean los objetos, lo que facilita el cambio de
  la implementaci√≥n de la creaci√≥n sin afectar el c√≥digo cliente.


- `Promover la flexibilidad y la reutilizaci√≥n`: Al desacoplar el c√≥digo que usa los objetos de la l√≥gica de creaci√≥n,
  puedes cambiar f√°cilmente el tipo de objeto que se crea, adapt√°ndolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creaci√≥n de objetos, promoviendo un
dise√±o de software m√°s robusto, modular y f√°cil de mantener.

üìå Ejemplos cl√°sicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan qu√© clase instanciar.
En otras palabras, delega la creaci√≥n de objetos a las subclases.

### Caracter√≠sticas del Factory Method

‚úÖ Ventajas:

- `Elimina acoplamiento`: El c√≥digo cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: F√°cil agregar nuevos productos sin modificar c√≥digo existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo espec√≠fico
- `Polimorfismo`: Usa herencia y polimorfismo para la creaci√≥n

‚ùå Desventajas:

- `Complejidad`: Introduce m√°s clases al sistema
- `Jerarqu√≠a`: Requiere crear subclases para cada tipo de producto

### üéØ Cu√°ndo usar Factory Method:

- Cuando no sabes de antemano qu√© tipos exactos de objetos necesitar√°s
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcci√≥n de objetos es complejo

### üíº Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones espec√≠ficos seg√∫n el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones seg√∫n el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers seg√∫n extensi√≥n (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers seg√∫n destino (file, console, database)
- `Notificaciones`: Crear notificadores seg√∫n canal (email, SMS, push) ‚Üê Nuestro caso

### üìê Representaci√≥n UML del patr√≥n Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es com√∫n a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el m√©todo de f√°brica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este m√©todo coincida con la interfaz `Product`.
   > Puedes declarar el patr√≥n `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del m√©todo. Como alternativa, el m√©todo de f√°brica base puede devolver alg√∫n tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creaci√≥n de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna l√≥gica de negocios central relacionada con los productos. El
   > patr√≥n `Factory Method` ayuda a desacoplar esta l√≥gica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el m√©todo de f√°brica no tiene que crear nuevas instancias todo el tiempo. Tambi√©n puede devolver
   > objetos existentes de una memor√≠a cach√©, una agrupaci√≥n de objetos, u otra fuente.

### üéØ Ejemplo 01: Sistema de Notificaciones Multi-canal usando Factory Method

Este ejemplo implementa un sistema de notificaciones empresarial que puede enviar mensajes a trav√©s de m√∫ltiples canales
de comunicaci√≥n (Email, SMS, Push Notifications, WhatsApp).

#### `Problem√°tica`

Una aplicaci√≥n de e-commerce necesita notificar a sus usuarios sobre diferentes eventos del negocio (confirmaci√≥n de
pedidos, cambios de estado, promociones, alertas de seguridad) utilizando distintos medios seg√∫n las preferencias del
usuario, la urgencia del mensaje y el tipo de evento.

#### `Soluci√≥n con Factory Method`

En lugar de que el c√≥digo cliente conozca y decida qu√© tipo espec√≠fico de notificaci√≥n crear, se utiliza el patr√≥n
Factory Method para delegar esta responsabilidad a clases especializadas. Cada ConcreteCreator sabe exactamente c√≥mo
configurar y crear su tipo espec√≠fico de notificaci√≥n (configuraciones SMTP para email, APIs de terceros para SMS,
tokens para push notifications, etc.).

#### `Beneficio`

El sistema puede f√°cilmente incorporar nuevos canales de notificaci√≥n (Telegram, Discord, Slack) sin modificar el c√≥digo
cliente existente, y cada factory se encarga de los detalles t√©cnicos espec√≠ficos de su canal, manteniendo el c√≥digo
limpio y desacoplado.

#### `Escenario real`

Similar a lo que implementan plataformas como Amazon, Netflix, o cualquier banco que necesita comunicarse con usuarios a
trav√©s de m√∫ltiples canales de forma consistente y escalable.

