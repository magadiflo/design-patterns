# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de diseño de software` que se centran en la
`creación de objetos`. Su propósito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la lógica de instanciación`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es útil cuando el proceso de creación es complejo, involucra varias etapas o depende de la configuración
  del sistema.


- `Encapsular la creación de objetos`: Ocultan los detalles de cómo se crean los objetos, lo que facilita el cambio de
  la implementación de la creación sin afectar el código cliente.


- `Promover la flexibilidad y la reutilización`: Al desacoplar el código que usa los objetos de la lógica de creación,
  puedes cambiar fácilmente el tipo de objeto que se crea, adaptándolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creación de objetos, promoviendo un
diseño de software más robusto, modular y fácil de mantener.

📌 Ejemplos clásicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan qué clase instanciar.
En otras palabras, delega la creación de objetos a las subclases.

### Características del Factory Method

✅ Ventajas:

- `Elimina acoplamiento`: El código cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: Fácil agregar nuevos productos sin modificar código existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo específico
- `Polimorfismo`: Usa herencia y polimorfismo para la creación

❌ Desventajas:

- `Complejidad`: Introduce más clases al sistema
- `Jerarquía`: Requiere crear subclases para cada tipo de producto

### 🎯 Cuándo usar Factory Method:

- Cuando no sabes de antemano qué tipos exactos de objetos necesitarás
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcción de objetos es complejo

### 💼 Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones específicos según el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones según el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers según extensión (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers según destino (file, console, database)
- `Notificaciones`: Crear notificadores según canal (email, SMS, push) ← Nuestro caso

### 📐 Representación UML del patrón Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es común a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el método de fábrica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este método coincida con la interfaz `Product`.
   > Puedes declarar el patrón `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del método. Como alternativa, el método de fábrica base puede devolver algún tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creación de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna lógica de negocios central relacionada con los productos. El
   > patrón `Factory Method` ayuda a desacoplar esta lógica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el método de fábrica no tiene que crear nuevas instancias todo el tiempo. También puede devolver
   > objetos existentes de una memoría caché, una agrupación de objetos, u otra fuente.

### 🎯 Ejemplo 01: Estrategias de pago

`Contexto realista`: Supongamos que queremos aplicar diferentes estrategias de pago: `tarjeta de crédito`, `PayPal` y
`transferencia bancaria`.

Entonces, la implementación de nuestro patrón `Strategy` estará basado en el siguiente diagrama de clases.

![02.png](assets/02-java-plano-comportamiento/02.png)
