# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de dise√±o de software` que se centran en la
`creaci√≥n de objetos`. Su prop√≥sito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la l√≥gica de instanciaci√≥n`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es √∫til cuando el proceso de creaci√≥n es complejo, involucra varias etapas o depende de la configuraci√≥n
  del sistema.


- `Encapsular la creaci√≥n de objetos`: Ocultan los detalles de c√≥mo se crean los objetos, lo que facilita el cambio de
  la implementaci√≥n de la creaci√≥n sin afectar el c√≥digo cliente.


- `Promover la flexibilidad y la reutilizaci√≥n`: Al desacoplar el c√≥digo que usa los objetos de la l√≥gica de creaci√≥n,
  puedes cambiar f√°cilmente el tipo de objeto que se crea, adapt√°ndolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creaci√≥n de objetos, promoviendo un
dise√±o de software m√°s robusto, modular y f√°cil de mantener.

üìå Ejemplos cl√°sicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan qu√© clase instanciar.
En otras palabras, delega la creaci√≥n de objetos a las subclases.

### Caracter√≠sticas del Factory Method

‚úÖ Ventajas:

- `Elimina acoplamiento`: El c√≥digo cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: F√°cil agregar nuevos productos sin modificar c√≥digo existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo espec√≠fico
- `Polimorfismo`: Usa herencia y polimorfismo para la creaci√≥n

‚ùå Desventajas:

- `Complejidad`: Introduce m√°s clases al sistema
- `Jerarqu√≠a`: Requiere crear subclases para cada tipo de producto

### üéØ Cu√°ndo usar Factory Method:

- Cuando no sabes de antemano qu√© tipos exactos de objetos necesitar√°s
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcci√≥n de objetos es complejo

### üíº Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones espec√≠ficos seg√∫n el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones seg√∫n el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers seg√∫n extensi√≥n (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers seg√∫n destino (file, console, database)
- `Notificaciones`: Crear notificadores seg√∫n canal (email, SMS, push) ‚Üê Nuestro caso

### üìê Representaci√≥n UML del patr√≥n Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es com√∫n a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el m√©todo de f√°brica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este m√©todo coincida con la interfaz `Product`.
   > Puedes declarar el patr√≥n `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del m√©todo. Como alternativa, el m√©todo de f√°brica base puede devolver alg√∫n tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creaci√≥n de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna l√≥gica de negocios central relacionada con los productos. El
   > patr√≥n `Factory Method` ayuda a desacoplar esta l√≥gica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el m√©todo de f√°brica no tiene que crear nuevas instancias todo el tiempo. Tambi√©n puede devolver
   > objetos existentes de una memor√≠a cach√©, una agrupaci√≥n de objetos, u otra fuente.

### üéØ Ejemplo 01: Sistema de Notificaciones Multi-canal usando Factory Method

Este ejemplo implementa un sistema de notificaciones empresarial que puede enviar mensajes a trav√©s de m√∫ltiples canales
de comunicaci√≥n (`Email`, `SMS`, `Push Notifications`, `WhatsApp`).

#### `Problem√°tica`

Una aplicaci√≥n de e-commerce necesita notificar a sus usuarios sobre diferentes eventos del negocio (confirmaci√≥n de
pedidos, cambios de estado, promociones, alertas de seguridad) utilizando distintos medios seg√∫n las preferencias del
usuario, la urgencia del mensaje y el tipo de evento.

#### `Soluci√≥n con Factory Method`

En lugar de que el c√≥digo cliente conozca y decida qu√© tipo espec√≠fico de notificaci√≥n crear, se utiliza el patr√≥n
Factory Method para delegar esta responsabilidad a clases especializadas. Cada ConcreteCreator sabe exactamente c√≥mo
configurar y crear su tipo espec√≠fico de notificaci√≥n (configuraciones SMTP para email, APIs de terceros para SMS,
tokens para push notifications, etc.).

#### `Beneficio`

El sistema puede f√°cilmente incorporar nuevos canales de notificaci√≥n (Telegram, Discord, Slack) sin modificar el c√≥digo
cliente existente, y cada factory se encarga de los detalles t√©cnicos espec√≠ficos de su canal, manteniendo el c√≥digo
limpio y desacoplado.

#### `Escenario real`

Similar a lo que implementan plataformas como Amazon, Netflix, o cualquier banco que necesita comunicarse con usuarios a
trav√©s de m√∫ltiples canales de forma consistente y escalable.

El siguiente diagrama de clases muestra la implementaci√≥n de nuestro patr√≥n `Factory Method`.

![02.png](assets/03-java-plano-creacional/02.png)

### üöÄ Product del Factory Method

En el patr√≥n `Factory Method`, el `Product` define la interfaz o clase abstracta que describe las operaciones que los
objetos creados por la f√°brica deben implementar. Todas las implementaciones concretas del producto seguir√°n este
contrato.

En nuestro caso:

````java
public interface Notification {
    void send(String message, String recipient);

    NotificationChannel getChannel();
}
````

- `Notification` es la interfaz que representa el `Product` en el patr√≥n `Factory Method`. Define el contrato com√∫n que
  todas las implementaciones concretas de notificaciones deben cumplir:
    - `send(String message, String recipient)`: m√©todo para enviar el mensaje a un destinatario.
    - `getChannel()`: m√©todo para identificar el canal de la notificaci√≥n mediante `NotificationChannel`.
- Este dise√±o permite que el c√≥digo cliente interact√∫e con cualquier tipo de notificaci√≥n sin conocer su implementaci√≥n
  concreta.

````java
public enum NotificationChannel {
    EMAIL,
    SMS,
    PUSH,
    WHATSAPP
}
````

- `NotificationChannel` es un enumerador que define los distintos canales de notificaci√≥n que el sistema soporta.
  En el contexto del patr√≥n `Factory Method`, este `enum` act√∫a como criterio para que la f√°brica determine qu√© tipo de
  producto (notificaci√≥n concreta) debe crear.
- Esto evita el uso de cadenas de texto y garantiza seguridad de tipo.

### üöÄ Concrete Products del Factory Method

Los `Concrete Products` son las implementaciones concretas de la interfaz o clase abstracta `Product`, en nuestro caso
implementaciones concretas del `Notification`.

Cada uno define:

- C√≥mo se comporta el producto en su caso espec√≠fico.
- C√≥mo implementa las operaciones definidas por el `Product`.
- Sus propiedades espec√≠ficas necesarias para funcionar.

En este caso, cada `ConcreteProduct` representa un tipo de notificaci√≥n (`EmailNotification`, `PushNotification`,
`SMSNotification`, `WhatsAppNotification`), todos implementando la interfaz `Notification`.

````java

@Slf4j
@RequiredArgsConstructor
public class EmailNotification implements Notification {

    private final String smtpServer;
    private final int port;
    private final String username;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Email Notification ===");
        log.info("SMTP Server: {}:{}", this.smtpServer, this.port);
        log.info("From: {}", this.username);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("Email sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.EMAIL;
    }
}
````

`EmailNotification` es un `Concrete Product` que implementa la interfaz `Notification` para el canal `EMAIL`.

Sus particularidades son:

- `Atributos propios`: `smtpServer`, `port`, `username` necesarios para configurar el env√≠o de correos electr√≥nicos.
- `Implementaci√≥n de send`: contiene la l√≥gica para enviar un email (en este ejemplo se simula mediante logs).
- `Implementaci√≥n de getChannel`: devuelve el valor `NotificationChannel.EMAIL` para identificar el canal que
  representa.

Relaci√≥n con el patr√≥n:

- La f√°brica se encargar√° de instanciar este producto cuando se solicite una notificaci√≥n de tipo `EMAIL`.
- El cliente no necesita saber c√≥mo se configura o env√≠a el correo, solo que puede invocar `send(...)`.

A continuaci√≥n se muestra el c√≥digo de los dem√°s `concret products`.

````java

@Slf4j
@RequiredArgsConstructor
public class PushNotification implements Notification {

    private final String firebaseKey;
    private final String appId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== Push Notification ===");
        log.info("Firebase Key: {}", this.firebaseKey.substring(0, 10) + "...");
        log.info("APP ID: {}", this.appId);
        log.info("Device Token: {}", recipient);
        log.info("Message: {}", message);
        log.info("Push notification sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.PUSH;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class SMSNotification implements Notification {

    private final String apiKey;
    private final String provider;

    @Override
    public void send(String message, String recipient) {
        log.info("=== SMS Notification ===");
        log.info("Provider: {}", this.provider);
        log.info("API Key: {}", this.apiKey.substring(0, 8) + "...");
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("SMS sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.SMS;
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
public class WhatsAppNotification implements Notification {

    private final String businessApiKey;
    private final String phoneNumberId;

    @Override
    public void send(String message, String recipient) {
        log.info("=== WhatsApp Notification ===");
        log.info("Business API KEY: {}", this.businessApiKey.substring(0, 12) + "...");
        log.info("Phone Number ID: {}", this.phoneNumberId);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);
        log.info("WhatsApp message sent successfully!");
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.WHATSAPP;
    }
}
````

### üöÄ Creator del Factory Method

La clase abstracta `NotificationCreator` es la clase `Creator` dentro del patr√≥n `Factory Method`.

Su rol es definir el `m√©todo f√°brica` abstracto (`createNotification()`), que ser√° implementado por las subclases para
instanciar el `Concrete Product` correspondiente.

````java

@Slf4j
public abstract class NotificationCreator {

    public void processNotification(String message, String recipient) {
        // Usar el factory method para crear la notificaci√≥n apropiada
        Notification notification = this.createNotification();

        // L√≥gica de negocio adicional antes del env√≠o
        log.info("Procesando {} notification...", notification.getChannel());

        // Validaciones generales (l√≥gica de negocio com√∫n)
        if (Objects.isNull(message) || message.isBlank()) {
            log.error("El mensaje no puede estar vac√≠o");
            return;
        }

        if (Objects.isNull(recipient) || recipient.isBlank()) {
            log.error("El destinatario no puede estar vac√≠o");
            return;
        }

        // Enviar la notificaci√≥n usando polimorfismo
        notification.send(message, recipient);

        // L√≥gica de negocio despu√©s del env√≠o (logging, m√©tricas, etc)
        log.info("Logged: {} notificaci√≥n enviado a {}", notification.getChannel(), recipient);
    }

    // Factory Method - debe ser implementado por las subclases
    public abstract Notification createNotification();
}
````

Adem√°s, en este ejemplo:

- Incluye el m√©todo `processNotification(...)` que encapsula un flujo com√∫n de negocio:
    1. Crea la notificaci√≥n a trav√©s del m√©todo f√°brica.
    2. Aplica validaciones generales (mensaje y destinatario no vac√≠os).
    3. Env√≠a la notificaci√≥n mediante `polimorfismo`.
    4. Ejecuta tareas posteriores (`logging`, `m√©tricas`).

- De esta forma, `la l√≥gica de creaci√≥n queda delegada a las subclases`, pero la l√≥gica de uso y validaciones comunes
  se mantiene centralizada en el `Creator`.

Beneficio en el patr√≥n:

- Separa el `‚Äúqu√© hacer‚Äù` (flujo com√∫n en `processNotification(...)`) de el `‚Äúcon qu√© hacerlo‚Äù`
  (implementaci√≥n de `createNotification()` en subclases).
- Permite a√±adir nuevos canales de notificaci√≥n sin modificar el `Creator`, solo creando nuevas subclases.

### üöÄ Concrete Creator del Factory Method

Los `Concrete Creators` son las subclases que implementan el `m√©todo f√°brica` definido en el `Creator`. Su funci√≥n
principal es:

- Decidir `qu√© producto concreto` se va a crear.
- Encapsular la l√≥gica de instanciaci√≥n del producto.
- Devolver un objeto que implementa la interfaz o clase abstracta `Product`, en nuestro caso retornar√° una
  implementaci√≥n de la interfaz `Notification`.

Beneficios:

- El c√≥digo cliente no conoce ni depende de las clases concretas de los productos.
- Facilita la extensi√≥n: para agregar un nuevo producto, solo se crea un nuevo `Concrete Creator`.

````java
public class EmailNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new EmailNotification("smtp.company.com", 587, "notifications@company.com");
    }
}
````

`EmailNotificationCreator` es un `Concrete Creator` que implementa el m√©todo `createNotification()` para instanciar un
`EmailNotification` preconfigurado con:

- Servidor SMTP (smtp.company.com)
- Puerto (587)
- Direcci√≥n remitente (notifications@company.com)

Relaci√≥n con el patr√≥n:

- Esta clase sabe exactamente qu√© tipo de producto crear (`EmailNotification`) y con qu√© par√°metros configurarlo.
- El cliente no necesita saber c√≥mo se crea o qu√© datos requiere el producto: solo llama a `processNotification()`
  en el `Creator` y recibe el comportamiento adecuado.

A continuaci√≥n se muestras los dem√°s `Concrete Creators`.

````java
public class PushNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new PushNotification("firebase_server_key_def456", "com.company.app");
    }
}
````

````java
public class SMSNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new SMSNotification("twilio_api_key_abc123xyz", "Twilio");
    }
}
````

````java
public class WhatsAppNotificationCreator extends NotificationCreator {
    @Override
    public Notification createNotification() {
        return new WhatsAppNotification("whatsapp_business_key_ghi789", "943854789");
    }
}
````

### üöÄ Uso del Patr√≥n Factory Method

En el `Factory Method`, el `Cliente` no crea directamente los productos, sino que trabaja con el `Creator`
(o `Concrete Creator`) y, a trav√©s de √©l, obtiene el `Product` correcto sin conocer su clase concreta.

En el patr√≥n `Factory Method`, el `Cliente` es la pieza que:

1. Elige qu√© `ConcreteCreator` utilizar seg√∫n el contexto o requerimiento.
2. Invoca el flujo de negocio del `Creator` (en este caso `processNotification(...)`), que internamente usa el
   `factory method` para crear el `Product` adecuado.
3. Consume el producto sin conocer su implementaci√≥n concreta.

En este ejemplo:

- La clase `Main` act√∫a como `Cliente`.
- Para cada escenario:
    - Instancia un `ConcreteCreator` espec√≠fico (`EmailNotificationCreator`, `SMSNotificationCreator`, etc.).
    - Llama a `processNotification`, delegando en el `Creator` la validaci√≥n, la creaci√≥n del producto y el env√≠o.
- Gracias al patr√≥n, el `Cliente` nunca llama directamente a `new EmailNotification(...)` ni a ninguna otra
  implementaci√≥n de `Notification`. Toda la creaci√≥n queda encapsulada en los `ConcreteCreator`.

Beneficio en este punto:

- Si ma√±ana se agrega un nuevo canal de notificaci√≥n (por ejemplo, `Telegram`), no es necesario modificar el c√≥digo de
  `Main` para saber c√≥mo se crea o configura; solo instanciar el nuevo `Creator`.
- Esto asegura bajo acoplamiento y mayor facilidad de mantenimiento.

````java

@Slf4j
public class Main {

    private static final String SEPARATOR = "================================================================";

    public static void main(String[] args) {
        log.info("FACTORY METHOD PATTERN - Sistema de Notificaciones Multi-canal");
        log.info(SEPARATOR);

        // Escenario 01: Confirmaci√≥n de Pedido (Email)
        log.info("Escenario 01: Confirmaci√≥n de Pedido");
        NotificationCreator emailCreator = new EmailNotificationCreator();
        emailCreator.processNotification(
                "Su pedido #415 ha sido confirmado. Total: S/ 1500.00",
                "cliente@example.com");


        // Escenario 02: Alerta urgente (SMS)
        log.info(SEPARATOR);
        log.info("Escenario 02: Alerta de seguridad");
        NotificationCreator smsCreator = new SMSNotificationCreator();
        smsCreator.processNotification(
                "C√≥digo de verificaci√≥n: 123456. V√°lido por 5 minutos.",
                "+51946741485");


        // Escenario 03: Promoci√≥n (Push)
        log.info(SEPARATOR);
        log.info("Escenario 03: Notificaci√≥n Push - Promoci√≥n");
        NotificationCreator pushCreator = new PushNotificationCreator();
        pushCreator.processNotification(
                "¬°50% OFF en todos los productos! Aprovecha ahora.",
                "device_token_abc123xyz789");


        // Escenario 04: Soporte personalizado (WhatsApp)
        log.info(SEPARATOR);
        log.info("Escenario 04: Soporte WhatsApp");
        NotificationCreator whatsAppCreator = new WhatsAppNotificationCreator();
        whatsAppCreator.processNotification(
                "Hola! Su consulta ha sido recibida. Un agente le responder√° pronto.",
                "+51987458778");
    }
}
````

### üß™ Ejecuci√≥n y validaci√≥n del patr√≥n

Verificar que el cliente (`Main`) pueda enviar notificaciones por distintos canales sin conocer los detalles de
creaci√≥n de cada implementaci√≥n concreta.

````bash
factorymethod.notification.Main -- FACTORY METHOD PATTERN - Sistema de Notificaciones Multi-canal
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 01: Confirmaci√≥n de Pedido
factorymethod.notification.factory.NotificationCreator -- Procesando EMAIL notification...
factorymethod.notification.model.EmailNotification -- === Email Notification ===
factorymethod.notification.model.EmailNotification -- SMTP Server: smtp.company.com:587
factorymethod.notification.model.EmailNotification -- From: notifications@company.com
factorymethod.notification.model.EmailNotification -- To: cliente@example.com
factorymethod.notification.model.EmailNotification -- Message: Su pedido #415 ha sido confirmado. Total: S/ 1500.00
factorymethod.notification.model.EmailNotification -- Email sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: EMAIL notificaci√≥n enviado a cliente@example.com
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 02: Alerta de seguridad
factorymethod.notification.factory.NotificationCreator -- Procesando SMS notification...
factorymethod.notification.model.SMSNotification -- === SMS Notification ===
factorymethod.notification.model.SMSNotification -- Provider: Twilio
factorymethod.notification.model.SMSNotification -- API Key: twilio_a...
factorymethod.notification.model.SMSNotification -- To: +51946741485
factorymethod.notification.model.SMSNotification -- Message: C√≥digo de verificaci√≥n: 123456. V√°lido por 5 minutos.
factorymethod.notification.model.SMSNotification -- SMS sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: SMS notificaci√≥n enviado a +51946741485
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 03: Notificaci√≥n Push - Promoci√≥n
factorymethod.notification.factory.NotificationCreator -- Procesando PUSH notification...
factorymethod.notification.model.PushNotification -- === Push Notification ===
factorymethod.notification.model.PushNotification -- Firebase Key: firebase_s...
factorymethod.notification.model.PushNotification -- APP ID: com.company.app
factorymethod.notification.model.PushNotification -- Device Token: device_token_abc123xyz789
factorymethod.notification.model.PushNotification -- Message: ¬°50% OFF en todos los productos! Aprovecha ahora.
factorymethod.notification.model.PushNotification -- Push notification sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: PUSH notificaci√≥n enviado a device_token_abc123xyz789
factorymethod.notification.Main -- ================================================================
factorymethod.notification.Main -- Escenario 04: Soporte WhatsApp
factorymethod.notification.factory.NotificationCreator -- Procesando WHATSAPP notification...
factorymethod.notification.model.WhatsAppNotification -- === WhatsApp Notification ===
factorymethod.notification.model.WhatsAppNotification -- Business API KEY: whatsapp_bus...
factorymethod.notification.model.WhatsAppNotification -- Phone Number ID: 943854789
factorymethod.notification.model.WhatsAppNotification -- To: +51987458778
factorymethod.notification.model.WhatsAppNotification -- Message: Hola! Su consulta ha sido recibida. Un agente le responder√° pronto.
factorymethod.notification.model.WhatsAppNotification -- WhatsApp message sent successfully!
factorymethod.notification.factory.NotificationCreator -- Logged: WHATSAPP notificaci√≥n enviado a +51987458778
````

La ejecuci√≥n confirma que:

- El patr√≥n `Factory Method` se implement√≥ correctamente.
- Cada escenario de notificaci√≥n funciona de manera independiente.
- Se logra flexibilidad y extensibilidad, cumpliendo los objetivos del patr√≥n.

---

## Builder

El patr√≥n `Builder` es un patr√≥n de dise√±o creacional que permite `construir objetos complejos paso a paso`, de manera
que el mismo proceso de construcci√≥n pueda crear diferentes representaciones. Este patr√≥n es especialmente √∫til cuando:

- Un objeto requiere muchos par√°metros para su construcci√≥n.
- Algunos par√°metros son opcionales.
- El proceso de construcci√≥n debe ser independiente de las partes que componen el objeto.
- Se necesita crear diferentes representaciones del mismo objeto.

### üß© Problema que resuelve

- `Constructor telesc√≥pico`: M√∫ltiples constructores con diferentes combinaciones de par√°metros.
- `Objetos inconsistentes`: Construcci√≥n en m√∫ltiples pasos donde el objeto puede quedar en estado inv√°lido.
- `C√≥digo poco legible`: Dif√≠cil entender qu√© par√°metro corresponde a qu√© atributo.
- `Par√°metros opcionales`: Manejo complejo de par√°metros opcionales.

Ejemplo del problema

````java
// Constructor telesc√≥pico - dif√≠cil de mantener y entender
User user = new User("John", "Doe", "john@email.com", "123456789",
                "123 Main St", "New York", "NY", "10001",
                true, false, "Manager", "IT");
// ¬øQu√© representa cada par√°metro?
//
// Algunos valores como "john@email.com" sugieren claramente que se trata de un correo electr√≥nico.
// Pero otros, como "10001", ¬øa qu√© atributo corresponden? ¬øEs un c√≥digo postal, un ID, un n√∫mero interno?
// La relaci√≥n entre valores y atributos no es evidente, lo que dificulta la lectura y el mantenimiento.
// Si el orden cambia accidentalmente, el c√≥digo puede seguir compilando pero comportarse de forma incorrecta.
````

### Caracter√≠sticas del Patr√≥n

- `Construcci√≥n paso a paso`: Permite crear objetos complejos de forma incremental, asignando atributos de manera
  controlada.
- `Compatibilidad con inmutabilidad`: El producto final `puede ser inmutable` si el dise√±o lo requiere, pero no es
  obligatorio. Por ejemplo, en entidades JPA se necesita mutabilidad.
- `Flexibilidad`: Diferentes builders pueden construir distintas representaciones del mismo tipo de objeto, adapt√°ndose
  a distintos contextos.
- `Legibilidad`: Facilita una API fluida y expresiva, evitando constructores telesc√≥picos y mejorando la comprensi√≥n
  del c√≥digo.
- `Validaci√≥n`: Permite validar el estado del objeto antes de construirlo, centralizando reglas de negocio o
  consistencia.

> üí° `Nota`: La inmutabilidad es una pr√°ctica recomendada en objetos que no deben cambiar su estado una vez creados,
> como DTOs o configuraciones. Sin embargo, en frameworks como Spring Boot, las entidades suelen requerir mutabilidad
> para funcionar correctamente con JPA.

### üìê Representaci√≥n UML del patr√≥n Builder Cl√°sico (GoF)

![03.png](assets/03-java-plano-creacional/03.png)

1. La interfaz `Builder` declara pasos de construcci√≥n de producto que todos los tipos de objetos constructores tienen
   en com√∫n.
2. Los `Concrete Builders` ofrecen distintas implementaciones de los pasos de construcci√≥n. Los `Concrete Builders`
   pueden crear productos que no siguen la interfaz com√∫n.
3. El `Product` es el objeto complejo que se est√° construyendo.
4. La clase `Director` define el orden en el que se invocar√°n los pasos de construcci√≥n.
5. El `Client` usa el `Director` y el `Builder` para construir el objeto.

### Variantes del Patr√≥n

1. `Builder Cl√°sico (GoF)`
    - Usa `Director` para coordinar la construcci√≥n.
    - Interfaz `Builder` separada.
    - M√∫ltiples `ConcreteBuilders` posibles.


2. `Fluent Builder (Moderno)`
    - M√°s com√∫n en el mundo real.
    - API fluida con encadenamiento de m√©todos.
    - Sin `Director` expl√≠cito.
    - Patr√≥n `Method Chaining` integrado.
    ````java
    // Ejemplo Fluent Builder
    User user = User.builder()
                    .name("Nophy")
                    .username("dog")
                    .password("12345")
                    .edad(4)
                    .build();
    ````

### üìê Diagrama UML del patr√≥n Builder (Moderno)

![04.png](assets/03-java-plano-creacional/04.png)

### Ejemplo 01: Builder GoF cl√°sico - Sistema de reportes

En una empresa se generan reportes de ventas que contienen informaci√≥n estructurada como t√≠tulo, tabla de datos y
totales. Aunque el contenido es el mismo, la forma de presentaci√≥n var√≠a seg√∫n el formato requerido por el usuario
final: `PDF`, `Excel` o `HTML`.

Este escenario es ideal para aplicar el patr√≥n `Builder cl√°sico`, ya que permite separar el proceso de construcci√≥n del
reporte (que es fijo) de su representaci√≥n final (que var√≠a). As√≠, se puede reutilizar la l√≥gica de construcci√≥n
mientras se encapsulan las diferencias de formato en distintos builders concretos.

### üß© Clase: Report ‚Äì Producto

Representa el objeto complejo que se construye paso a paso mediante el `patr√≥n Builder`. En este caso, encapsula la
estructura de un reporte de ventas, compuesto por tres secciones principales: encabezado, contenido y pie de p√°gina.

#### üõ†Ô∏è Responsabilidad

Define los atributos del reporte y provee m√©todos para establecerlos (`setHeader`, `setContent`, `setFooter`) y
obtenerlos (`getHeader`, etc.). No contiene l√≥gica de construcci√≥n ni formato, lo que permite que distintos builders
lo configuren seg√∫n el tipo de salida (PDF, Excel, HTML).

````java
public class Report {

    private String header;
    private String content;
    private String footer;

    public String getHeader() {
        return header;
    }

    public void setHeader(String header) {
        this.header = header;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }

    public String getFooter() {
        return footer;
    }

    public void setFooter(String footer) {
        this.footer = footer;
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("Report{");
        sb.append("header='").append(header).append('\'');
        sb.append(", content='").append(content).append('\'');
        sb.append(", footer='").append(footer).append('\'');
        sb.append('}');
        return sb.toString();
    }
}
````

üìö Observaciones

- El m√©todo `toString()` facilita la visualizaci√≥n del estado del objeto, √∫til para pruebas o depuraci√≥n.
- La clase es agn√≥stica al formato de salida, lo que permite reutilizarla en m√∫ltiples representaciones sin modificar su
  estructura

### üß© Interfaz: ReportBuilder ‚Äì Builder

Define la estructura abstracta del proceso de construcci√≥n del objeto complejo `Report`. Cada m√©todo representa un paso
espec√≠fico en la creaci√≥n del reporte, permitiendo que distintas implementaciones generen representaciones diferentes
(PDF, Excel, HTML) sin alterar el proceso general.

#### üõ†Ô∏è Responsabilidad

Establece los m√©todos que deben implementar los builders concretos para construir cada parte del reporte:

- `buildHeader(String title)`: configura el encabezado del reporte.
- `buildContent(String data)`: define el cuerpo principal con los datos.
- `buildFooter(String author)`: agrega el pie de p√°gina con informaci√≥n adicional.
- `getResult()`: retorna el objeto Report completamente construido.

````java
public interface ReportBuilder {
    void buildHeader(String title);

    void buildContent(String data);

    void buildFooter(String author);

    Report getResult();
}
````

#### üìö Observaciones

- Esta interfaz permite aplicar el principio de `abstracci√≥n` y `polimorfismo`, facilitando la extensi√≥n del sistema
  con nuevos formatos sin modificar el c√≥digo existente.
- El m√©todo `getResult()` act√∫a como punto final del proceso de construcci√≥n, entregando el producto terminado.

### üß© Clase: PDFReportBuilder ‚Äì Builder Concreto

Implementa la interfaz `ReportBuilder`, definiendo c√≥mo construir cada parte del objeto `Report` espec√≠ficamente para
el formato PDF. Cada m√©todo aplica un estilo o prefijo propio del formato, manteniendo la l√≥gica encapsulada y
reutilizable.

#### üõ†Ô∏è Responsabilidad

Encargado de construir un reporte en formato PDF, aplicando convenciones visuales propias del medio (encabezados
delimitados, contenido con prefijos, pie con autor). Internamente, mantiene una instancia de `Report` que va
configurando paso a paso.

````java
public class PDFReportBuilder implements ReportBuilder {

    private final Report report = new Report();

    @Override
    public void buildHeader(String title) {
        this.report.setHeader("=== PDF HEADER: " + title + " ===");
    }

    @Override
    public void buildContent(String data) {
        this.report.setContent("PDF Content: " + data);
    }

    @Override
    public void buildFooter(String author) {
        this.report.setFooter("PDF Footer - Author: " + author);
    }

    @Override
    public Report getResult() {
        return this.report;
    }
}
````

üìö Observaciones

- Cada m√©todo aplica un formato espec√≠fico al contenido, simulando c√≥mo se ver√≠a en un archivo PDF.
- La instancia `report` se mantiene como estado interno del builder, siguiendo el patr√≥n cl√°sico.
- El m√©todo `getResult()` devuelve el producto final, listo para ser utilizado por el `Director` o directamente por el
  cliente.

### üß© Clase: ExcelReportBuilder ‚Äì Builder Concreto

Implementa la interfaz `ReportBuilder` para construir un objeto `Report` con formato espec√≠fico para hojas de c√°lculo
Excel. Cada m√©todo aplica convenciones propias del medio, como etiquetas o prefijos que simulan la estructura de
una hoja.

#### üõ†Ô∏è Responsabilidad

Encapsula la l√≥gica de construcci√≥n de reportes orientados a Excel, manteniendo la coherencia con el proceso definido
por el patr√≥n Builder cl√°sico. Permite reutilizar el flujo de construcci√≥n mientras adapta la representaci√≥n final al
formato requerido.

````java

public class ExcelReportBuilder implements ReportBuilder {

    private final Report report = new Report();

    @Override
    public void buildHeader(String title) {
        this.report.setHeader("[Excel sheet: " + title + "]");
    }

    @Override
    public void buildContent(String data) {
        this.report.setContent("Excel Rows: " + data);
    }

    @Override
    public void buildFooter(String author) {
        this.report.setFooter("Excel Footer - " + author);
    }

    @Override
    public Report getResult() {
        return this.report;
    }
}
````

### üß© Clase: ReportDirector ‚Äì Director

Encapsula el proceso de construcci√≥n del objeto complejo `Report`, delegando los pasos espec√≠ficos al builder
proporcionado. El director no conoce los detalles de implementaci√≥n del builder, solo invoca los pasos en un orden
definido.

#### üõ†Ô∏è Responsabilidad

- Coordina la construcci√≥n del reporte invocando los m√©todos del builder en secuencia.
- Permite cambiar din√°micamente el builder mediante el m√©todo `changeBuilder`, lo que facilita la reutilizaci√≥n del
  flujo de construcci√≥n con diferentes representaciones (PDF, Excel, HTML).
- Expone el m√©todo `build(...)` como punto de entrada para generar un reporte completo a partir de los datos de entrada.

````java
public class ReportDirector {

    private ReportBuilder builder;

    public ReportDirector(ReportBuilder builder) {
        this.builder = builder;
    }

    public void changeBuilder(ReportBuilder builder) {
        this.builder = builder;
    }

    public Report build(String title, String data, String author) {
        this.builder.buildHeader(title);
        this.builder.buildContent(data);
        this.builder.buildFooter(author);
        return this.builder.getResult();
    }
}
````

üìö Observaciones

- El m√©todo `build(...)` define un flujo fijo de construcci√≥n, lo que garantiza consistencia en la estructura del
  reporte independientemente del formato.
- La posibilidad de cambiar el builder en tiempo de ejecuci√≥n permite aplicar el patr√≥n con flexibilidad, sin necesidad
  de instanciar m√∫ltiples directores.

### üöÄ Clase: ReportGenerationsService ‚Äì Cliente

Act√∫a como `cliente` del patr√≥n Builder, utilizando el `Director` y los `builders concretos` para generar reportes en
distintos formatos. Demuestra c√≥mo el mismo conjunto de datos puede representarse de forma diferente sin alterar el
proceso de construcci√≥n.

#### üõ†Ô∏è Responsabilidad

- Instancia el builder deseado (`PDFReportBuilder`, `ExcelReportBuilder`).
- Utiliza el `ReportDirector` para construir el reporte con un flujo fijo.
- Cambia din√°micamente el builder para generar otra variante del mismo reporte.
- Muestra el resultado mediante `log.info(...)`, facilitando la verificaci√≥n del contenido generado.

````java

@Slf4j
public class ReportGenerationsService {
    public static void main(String[] args) {
        ReportBuilder pdfBuilder = new PDFReportBuilder();
        ReportDirector director = new ReportDirector(pdfBuilder);
        Report pdfReport = director.build("Reporte de ventas", "Datos de venta aqu√≠", "Milagros D√≠az");
        log.info(pdfReport.toString());

        ReportBuilder excelBuilder = new ExcelReportBuilder();
        director.changeBuilder(excelBuilder);
        Report excelReport = director.build("Reporte de ventas", "Datos de venta aqu√≠", "Milagros D√≠az");
        log.info(excelReport.toString());
    }
}
````

üìö Observaciones

- El uso de `@Slf4j` permite una salida limpia y profesional del resultado, ideal para entornos productivos o pruebas.
- La reutilizaci√≥n del `Director` con distintos builders demuestra la flexibilidad del patr√≥n.
- El ejemplo es f√°cilmente extensible: bastar√≠a con implementar un nuevo builder (por ejemplo, `HtmlReportBuilder`)
  para generar otro formato sin modificar el flujo.

### üñ•Ô∏è Ejecuci√≥n del ejemplo

Al ejecutar la clase `ReportGenerationsService`, se generan dos reportes con el mismo conjunto de datos pero con
formatos distintos: `PDF` y `Excel`. La salida muestra c√≥mo cada builder concreto aplica su propio estilo al encabezado,
contenido y pie del reporte.

````bash
21:08:14.583 [main] INFO ..ReportGenerationsService -- Report{header='=== PDF HEADER: Reporte de ventas ===', content='PDF Content: Datos de venta aqu√≠', footer='PDF Footer - Author: Milagros D√≠az'}
21:08:14.588 [main] INFO ..ReportGenerationsService -- Report{header='[Excel sheet: Reporte de ventas]', content='Excel Rows: Datos de venta aqu√≠', footer='Excel Footer - Milagros D√≠az'}
````

üìö Observaciones

- Ambos reportes comparten el mismo flujo de construcci√≥n (title, data, author), definido por el Director.
- La diferencia en la salida se debe exclusivamente al builder concreto utilizado, lo que valida la separaci√≥n entre
  construcci√≥n y representaci√≥n.
- El patr√≥n permite agregar nuevos formatos (por ejemplo, HTML) sin modificar el flujo ni la l√≥gica del cliente.

### Ejemplo 02: Builder Moderno (Fluent Builder) ‚Äì Usuario

En sistemas donde se crean objetos con m√∫ltiples atributos opcionales, como el caso de un User, el uso de constructores
tradicionales puede volverse problem√°tico. A medida que se agregan m√°s par√°metros, se recurre al constructor
telesc√≥pico, que genera m√∫ltiples versiones del constructor con distintas combinaciones de argumentos. Esto provoca:

- C√≥digo dif√≠cil de leer y mantener.
- Ambig√ºedad en el orden de los par√°metros.
- P√©rdida de claridad sem√°ntica.

Para resolver este problema, se aplica el patr√≥n `Fluent Builder moderno`, que permite construir objetos de forma clara,
encadenando m√©todos con nombres expl√≠citos y devolviendo el propio builder en cada paso.

### üß© Clase: User ‚Äì Producto con Fluent Builder

Representa el objeto complejo que se desea construir. En este caso, un usuario con m√∫ltiples atributos, algunos
opcionales. La clase incluye una implementaci√≥n moderna del patr√≥n Builder, encapsulada como clase interna est√°tica.

#### üõ†Ô∏è Responsabilidad

- Define los atributos del usuario (name, username, password, age).
- Expone un m√©todo est√°tico `builder()` que inicia el proceso de construcci√≥n.
- Utiliza un constructor privado que recibe el builder como argumento, asegurando que el objeto solo se cree mediante el
  builder.

### üß© Clase interna: UserBuilder ‚Äì Fluent Builder

Encapsula el proceso de construcci√≥n del objeto `User`, permitiendo encadenar m√©todos de forma fluida. Cada m√©todo
configura un atributo y retorna el builder, facilitando una sintaxis clara y legible.

#### üõ†Ô∏è Responsabilidad

- Provee m√©todos como `name(...)`, `username(...)`, `password(...)`, `age(...)`, cada uno retornando el builder.
- El m√©todo `build()` crea una instancia de `User` con los valores configurados

````java
public class User {

    private String name;
    private String username;
    private String password;
    private int age;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.username = builder.username;
        this.password = builder.password;
        this.age = builder.age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public static UserBuilder builder() {
        return new UserBuilder();
    }

    @Override
    public String toString() {
        final StringBuilder sb = new StringBuilder("User{");
        sb.append("name='").append(name).append('\'');
        sb.append(", username='").append(username).append('\'');
        sb.append(", password='").append(password).append('\'');
        sb.append(", age=").append(age);
        sb.append('}');
        return sb.toString();
    }

    // Clase Builder: Clase anidada o clase interna
    public static class UserBuilder {

        private String name;
        private String username;
        private String password;
        private int age;

        private UserBuilder() {

        }

        public UserBuilder name(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder username(String username) {
            this.username = username;
            return this;
        }

        public UserBuilder password(String password) {
            this.password = password;
            return this;
        }

        public UserBuilder age(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
````

#### üìÑ Ejemplo de uso

````java

@Slf4j
public class Client {
    public static void main(String[] args) {
        User user = User.builder()
                .name("Milagros")
                .username("mila")
                .password("123456")
                .age(19)
                .build();
        log.info(user.toString());
    }
}
````

üìö Observaciones

- El patr√≥n `Fluent Builder` mejora la legibilidad y evita el uso de constructores telesc√≥picos.
- La clase interna `UserBuilder` mantiene el encapsulamiento y permite una construcci√≥n controlada.
- Este enfoque es especialmente √∫til cuando hay muchos par√°metros opcionales o cuando se desea una API fluida y
  expresiva.

#### üñ•Ô∏è Ejecuci√≥n del ejemplo

Al ejecutar el c√≥digo, se construye un objeto `User` utilizando el builder fluido. Cada atributo se establece mediante
m√©todos encadenados, lo que mejora la legibilidad y evita errores comunes del constructor telesc√≥pico.

````bash
00:07:43.803 [main] INFO ...Client -- User{name='Milagros', username='mila', password='123456', age=19} 
````

üìö Observaciones

- El objeto se construye correctamente con todos los atributos definidos.
- La sintaxis fluida permite una lectura natural del c√≥digo, como si se estuviera ‚Äúdescribiendo‚Äù al usuario.
- Este enfoque es especialmente √∫til en objetos con muchos campos opcionales, donde la claridad y la flexibilidad son
  clave.

---

## Singleton

Es un patr√≥n de dise√±o creacional que nos permite asegurarnos de que `una clase` tenga `una √∫nica instancia`, a la vez
que proporciona un `punto de acceso global` a dicha instancia.

### Caracter√≠sticas del Singleton

- `Una sola instancia`: La clase solo puede tener una instancia durante toda la ejecuci√≥n.
- `Acceso global`: Proporciona un punto de acceso global a esa instancia.
- `Inicializaci√≥n controlada`: La clase controla cu√°ndo y c√≥mo se crea la instancia.
- `Responsabilidad √∫nica`: La clase es responsable de crear y gestionar su propia instancia.
- Suele usarse cuando se necesita un recurso compartido que debe ser √∫nico: logger, conexi√≥n a base de datos (pool),
  configuraci√≥n global, cache, etc.

### üìê Representaci√≥n UML del patr√≥n Singleton

![05.png](assets/03-java-plano-creacional/05.png)

1. La clase `Singleton` declara el m√©todo est√°tico `getInstance()` que devuelve la misma instancia de su propia clase.
   El constructor del Singleton debe ocultarse del c√≥digo cliente. La llamada al m√©todo `getInstance()` debe ser la
   √∫nica manera de obtener el objeto de Singleton.

### Tipos de implementaci√≥n

### 1. Eager Initialization (Inicializaci√≥n Temprana)

El `Singleton` del tipo `Eager Initialization` es seguro para subprocesos. En la inicializaci√≥n temprana, se crea una
instancia en el momento de la carga de la clase, por lo que no tendremos ning√∫n problema de seguridad de subprocesos
si elegimos ir con una inicializaci√≥n temprana.

Si su aplicaci√≥n siempre crea y usa una instancia de Singleton o los aspectos generales de creaci√≥n y tiempo de
ejecuci√≥n de Singleton no son una carga, es posible que desee crear su Singleton con inicializaci√≥n temprana, as√≠:

````java
public class ConfigManager {
    // Esto se ejecuta cuando la JVM carga la clase ConfigManager por primera vez
    private static final ConfigManager INSTANCE = new ConfigManager();

    private ConfigManager() {
    }

    public static ConfigManager getInstance() {
        return INSTANCE;  // Solo retorna, no verifica ni crea
    }
}
````

#### ¬øPor qu√© es Eager Initialization?

- La instancia (`INSTANCE`) se crea inmediatamente cuando se carga la clase.
- No hay verificaci√≥n condicional en `getInstance()` - simplemente retorna la instancia ya creada.
- La inicializaci√≥n ocurre en tiempo de carga de clase (`static final`), no en tiempo de primera llamada.
- No se necesita sincronizaci√≥n manual (`synchronized`, `volatile`, etc.), porque el `classloader` de Java garantiza
  que la inicializaci√≥n est√°tica es `thread-safe`.

#### Por qu√© decimos que es `thread-safe`

La `JVM` asegura que la inicializaci√≥n est√°tica de una clase ocurre de forma at√≥mica y sincronizada en el momento en
que el `classloader` carga la clase en memoria. Por eso, aunque m√∫ltiples hilos llamen a `ConfigManager.getInstance()`,
todos ven la misma referencia.

üëâ M√°s adelante, en la prueba con hilos `(Thread.ofPlatform())`, al imprimir `System.identityHashCode(configManager)`
se ve el mismo valor, lo que confirma que efectivamente es la misma instancia en ambos hilos.

#### Cosas a tener en cuenta con Eager Initialization

1. `Simplicidad`: es la forma m√°s sencilla de implementar un Singleton.
2. `Thread-safe por defecto`: no requiere sincronizaci√≥n expl√≠cita.
3. `Coste de inicializaci√≥n`: la instancia se crea aunque nunca se use, lo que puede ser un problema si:
    - La instancia es muy pesada (ej. carga de archivos grandes, conexiones, etc.).
    - La app nunca llega a necesitarla.
4. `Excepciones en inicializaci√≥n`: si el constructor lanza una excepci√≥n, la clase queda en un estado inconsistente y
   puede provocar `ExceptionInInitializerError`.
5. `Riesgos adicionales`:
    - `Reflexi√≥n`: con `Constructor#setAccessible(true)` alguien podr√≠a crear otra instancia.
    - `Serializaci√≥n`: sin `readResolve()`, una deserializaci√≥n podr√≠a crear otra instancia.
    - `Clonaci√≥n`: si alguien implementa `Cloneable`, tambi√©n podr√≠a duplicarse.

#### üìå Probando Singleton del tipo Eager Initialization

El objetivo de la prueba es comprobar que, incluso cuando m√∫ltiples hilos intentan obtener la instancia de
`ConfigManager` en paralelo, todos reciben exactamente el mismo objeto en memoria.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        IntStream.range(0, 10).forEach(value -> {
            // 1. Definimos una tarea (Runnable) que obtiene el Singleton y lo imprime
            Runnable task = () -> {
                ConfigManager configManager = ConfigManager.getInstance();
                log.info("Thread-{} -> {}", value, System.identityHashCode(configManager));
            };

            // 2. Lanzamos la tarea en un nuevo hilo de ejecuci√≥n
            Thread.ofPlatform().start(task);
        });
    }
}
````

#### Explicaci√≥n paso a paso

1. Creaci√≥n de varias tareas con `IntStream.range(0, 10)`
    - Generamos 10 n√∫meros (0 a 9), y para cada uno definimos un bloque de c√≥digo que se ejecutar√° en un hilo
      independiente.
2. Uso de `Runnable`
    - `Runnable` es una interfaz funcional de Java que representa una tarea que puede ejecutarse en un hilo.
    - Aqu√≠, la lambda `() -> { ... }` implementa el m√©todo `run()` de `Runnable`.
    - Dentro de la tarea:
        - Obtenemos la instancia del `ConfigManager` con `getInstance()`.
        - Usamos `System.identityHashCode()` para imprimir el identificador √∫nico basado en la referencia de objeto (no
          en equals() ni hashCode() sobrecargados).
3. Ejecuci√≥n con `Thread.ofPlatform().start(task)`
    - `Thread.ofPlatform()` es una forma moderna (desde `Java 19`) de crear hilos de `plataforma` tradicionales de la
      `JVM` (los mismos que siempre ha usado `new Thread()`).
    - Con `.start(task)` le pasamos la tarea `Runnable` y se ejecuta en un hilo nuevo.
    - Cada hilo correr√° en paralelo e imprimir√° el objeto `ConfigManager` que le toc√≥.
    - üìå En versiones previas de Java se habr√≠a hecho con: `new Thread(task).start();`
    - Pero `Thread.ofPlatform()` es una API m√°s expresiva y compatible con los nuevos modelos de concurrencia en Java.
4. Resultados
    - En el log se imprime la referencia del objeto obtenida por cada hilo. Como todos muestran el mismo n√∫mero
      (`528207363` en el ejemplo), queda demostrado que:
        - Todos los hilos accedieron a la misma instancia en memoria.
        - `ConfigManager` realmente funciona como `Singleton`.

#### Salida del programa

Resultado: Los 10 hilos ejecutados tienen el mismo `identityHashCode`.

````bash
23:33:18.973 [Thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-6 -> 528207363
23:33:18.973 [Thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-7 -> 528207363
23:33:18.973 [Thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-1 -> 528207363
23:33:18.973 [Thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-2 -> 528207363
23:33:18.973 [Thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-4 -> 528207363
23:33:18.973 [Thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-9 -> 528207363
23:33:18.973 [Thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-8 -> 528207363
23:33:18.973 [Thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-3 -> 528207363
23:33:18.973 [Thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-5 -> 528207363
23:33:18.973 [Thread-0] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.eager.Main -- Thread-0 -> 528207363
````

#### ‚úÖ Conclusi√≥n:

La prueba demuestra que el `Singleton` de tipo `Eager Initialization` es `thread-safe` sin necesidad de sincronizaci√≥n
adicional. Esto ocurre porque la instancia se crea en el momento de la carga de la clase `(static final)` y la `JVM`
garantiza la seguridad en esa inicializaci√≥n.

### 2. Thread-Safe con Bill Pugh (recomendado en Java)

El patr√≥n `Singleton con Bill Pugh` resuelve los problemas que ten√≠an las implementaciones cl√°sicas de inicializaci√≥n
perezosa (`Lazy Initialization`) en versiones antiguas de Java.

Antes de `Java 5`, el modelo de memoria de la JVM ten√≠a inconsistencias y los enfoques basados en doble verificaci√≥n
con `synchronized` pod√≠an fallar bajo condiciones de mucha concurrencia.

Para solucionarlo, `Bill Pugh` propuso el uso de una `clase interna est√°tica auxiliar`, que aprovecha la sem√°ntica
de inicializaci√≥n diferida de las clases en Java:

- La clase interna no se carga hasta que realmente se usa.
- Cuando se invoca `getInstance()`, la `JVM` carga la clase est√°tica interna y crea la instancia √∫nica del `Singleton`
  de forma `thread-safe` y sin necesidad de usar `synchronized`.

Este enfoque combina lo mejor de ambos mundos:

- `Lazy initialization` ‚Üí la instancia no se crea hasta que se necesita.
- `Thread-safety` ‚Üí garantizada por la sem√°ntica de inicializaci√≥n de clases en la `JVM`.
- `Eficiencia` ‚Üí no hay bloqueos ni sincronizaci√≥n expl√≠cita.

````java

@Slf4j
public class ConfigService {
    private ConfigService() {
        log.info("Instancia creada");
    }

    public static ConfigService getInstance() {
        return SingletonHelper.INSTANCE;
    }

    // Clase interna est√°tica auxiliar
    // Esta clase NO se carga cuando se carga ConfigService
    // Solo se carga cuando se referencia por primera vez
    private static class SingletonHelper {
        private static final ConfigService INSTANCE = new ConfigService();
    }
}
````

Momento de creaci√≥n:

- La clase `ConfigService` se carga ‚Üí `SingletonHelper` NO se carga a√∫n.
- Primera llamada a `getInstance()` ‚Üí Se carga `SingletonHelper` ‚Üí Se crea la instancia.
- Posteriores llamadas ‚Üí Solo retorna la instancia ya creada.

#### Prueba del Singleton con m√∫ltiples hilos

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        IntStream.range(0, 10).forEach(value -> {
            Runnable task = () -> {
                ConfigService configService = ConfigService.getInstance();
                log.info("Thread-{} -> {}", value, System.identityHashCode(configService));
            };
            Thread.ofPlatform().start(task);
        });
    }
}
````

- `IntStream.range(0, 10)` ‚Üí genera 10 valores para lanzar 10 hilos.
- `Runnable task` ‚Üí cada hilo obtiene la instancia de `ConfigService` y muestra su referencia en memoria
  (`System.identityHashCode`).
- `Thread.ofPlatform().start(task)` ‚Üí arranca un hilo de plataforma cl√°sico para ejecutar la tarea.

#### Salida del programa

````bash
00:13:07.437 [Thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.ConfigService -- Instancia creada
00:13:07.442 [Thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-8 -> 925731762
00:13:07.442 [Thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-6 -> 925731762
00:13:07.442 [Thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-4 -> 925731762
00:13:07.442 [Thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-7 -> 925731762
00:13:07.442 [Thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-2 -> 925731762
00:13:07.442 [Thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-9 -> 925731762
00:13:07.442 [Thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-3 -> 925731762
00:13:07.442 [Thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-1 -> 925731762
00:13:07.442 [Thread-0] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-0 -> 925731762
00:13:07.442 [Thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.billpugh.Main -- Thread-5 -> 925731762 
````

- El mensaje `Instancia creada` aparece una sola vez, indicando que la instancia se construy√≥ al primer acceso.
- Todos los hilos imprimen el mismo `identityHashCode`, confirmando que comparten la misma instancia √∫nica.

#### ‚úÖ Conclusi√≥n

La implementaci√≥n `Bill Pugh` es `la m√°s recomendada` en `Java puro` porque:

- Es `lazy` (no crea la instancia hasta que se necesita).
- Es `thread-safe` sin necesidad de sincronizaci√≥n.
- Es m√°s eficiente que otras variantes (no tiene penalizaci√≥n de bloqueos).

En proyectos con `Spring Boot`, este patr√≥n suele ser innecesario, ya que el contenedor `IoC` ya gestiona singletons de
forma segura.

### 3. Lazy Initialization (Inicializaci√≥n Perezosa) - No Thread Safe

La `inicializaci√≥n perezosa (lazy initialization)` difiere de la `inicializaci√≥n temprana` porque la instancia del
Singleton no se crea en el momento de la carga de la clase, sino √∫nicamente cuando se solicita por primera vez a
trav√©s del m√©todo `getInstance()`.

Este enfoque puede ser √∫til en escenarios donde:

- La creaci√≥n del objeto es costosa en t√©rminos de recursos.
- Existe la posibilidad de que nunca se necesite la instancia durante la ejecuci√≥n de la aplicaci√≥n.

Sin embargo, esta implementaci√≥n `no es segura en entornos multi-hilo`: m√∫ltiples threads podr√≠an entrar al m√©todo
`getInstance()` simult√°neamente, comprobar que `instance == null` y crear varias instancias, rompiendo el principio del
patr√≥n `Singleton`.

#### Implementaci√≥n b√°sica (no segura en multi-hilo)

````java

@Slf4j
public class DatabaseConnection {
    private static DatabaseConnection instance; //lazy initialization

    private DatabaseConnection() {
        log.info("Instancia creada");
    }

    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
````

#### Prueba en entorno concurrente

En la siguiente prueba utilizamos un `pool de 10 threads` para simular accesos concurrentes al `Singleton`. Cada thread
solicita la instancia y se imprime su `identityHashCode`, que permite verificar si los objetos son realmente el mismo.

Se emplea `ExecutorService` para manejar los hilos y `IntStream` para generar las tareas.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        try (ExecutorService executorService = Executors.newFixedThreadPool(10)) {
            IntStream.range(0, 10).forEach(value -> {
                Runnable task = () -> {
                    DatabaseConnection connection = DatabaseConnection.getInstance();
                    log.info("Thread-{} -> {}", value, System.identityHashCode(connection));
                };
                executorService.submit(task);
            });
            executorService.shutdown();
        }
    }
}
````

üîé Explicaci√≥n detallada:

- `ExecutorService executorService = Executors.newFixedThreadPool(10);`. Crea un pool de 10 hilos reutilizables. Esto
  significa que el sistema no tiene que estar creando y destruyendo threads constantemente (lo cual es costoso en
  memoria y CPU).


- `IntStream.range(0, 10).forEach(value -> ... )`. Genera una secuencia de n√∫meros del 0 al 9 (10 iteraciones). En cada
  iteraci√≥n, se env√≠a una tarea al pool.


- `executorService.submit(task)`. Env√≠a una tarea (un `Runnable`) al pool de threads. El pool se encarga de
  decidir qu√© hilo ejecutar√° cada tarea.


- `DatabaseConnection connection = DatabaseConnection.getInstance();`. Aqu√≠ cada hilo solicita la instancia del
  Singleton.


- `log.info("Thread-{} -> {}", value, System.identityHashCode(connection));`. Cada hilo imprime su n√∫mero de
  identificaci√≥n (del `IntStream`) y el `identityHashCode` de la instancia obtenida.


- `executorService.shutdown();`. Indica que ya no se aceptar√°n nuevas tareas, pero que las que est√°n pendientes deben
  terminarse. El `try-with-resources` `(try (...) {})` se asegura de que el `ExecutorService` se cierre adecuadamente
  cuando acabe el main.

> üëâ En resumen: este c√≥digo lanza 10 tareas concurrentes, gestionadas de manera ordenada y eficiente por un pool de
> hilos.

#### Diferencias principales entre `Thread.ofPlatform().start(task)` y `ExecutorService (ThreadPool)`

| Aspecto              | `Thread.ofPlatform().start(task)`                                                     | `ExecutorService (ThreadPool)`                                                                   |
|----------------------|---------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------|
| **Gesti√≥n de hilos** | Crea un nuevo hilo en cada llamada.                                                   | Usa un conjunto fijo (pool) de hilos reutilizables.                                              |
| **Eficiencia**       | Poco eficiente si necesitas muchos hilos, porque crear/destruir threads es costoso.   | Mucho m√°s eficiente en escenarios de concurrencia intensiva.                                     |
| **Control**          | No hay control sobre cu√°ntos hilos puedes lanzar; podr√≠an ser miles y saturar la JVM. | Puedes limitar la cantidad de hilos (`newFixedThreadPool(10)`), evitando sobrecargar el sistema. |
| **Flexibilidad**     | Simples pruebas o ejecuciones r√°pidas.                                                | Producci√≥n real, procesamiento de tareas concurrentes, servidores, colas de trabajo, etc.        |
| **Apagado ordenado** | No hay mecanismo de shutdown autom√°tico.                                              | Puedes cerrar el pool con `shutdown()` o `shutdownNow()`.                                        |

#### Resultado esperado

La salida evidencia el problema de concurrencia:

- Se crean m√∫ltiples instancias (se imprime varias veces `"Instancia creada"`).
- Los `identityHashCode` de los objetos son distintos, confirmando que el `Singleton` se ha roto en un entorno
  `multi-hilo`.

````bash
13:51:40.884 [pool-1-thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-10] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.884 [pool-1-thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.DatabaseConnection -- Instancia creada
13:51:40.888 [pool-1-thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-4 -> 105561592
13:51:40.888 [pool-1-thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-1 -> 378199387
13:51:40.888 [pool-1-thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-3 -> 1330106099
13:51:40.888 [pool-1-thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-8 -> 747844514
13:51:40.888 [pool-1-thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-0 -> 1832903611
13:51:40.889 [pool-1-thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-6 -> 487242617
13:51:40.888 [pool-1-thread-10] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-9 -> 1603698417
13:51:40.888 [pool-1-thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-2 -> 541207191
13:51:40.888 [pool-1-thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-5 -> 1608673501
13:51:40.888 [pool-1-thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.nothreadsafe.Main -- Thread-7 -> 481913664
````

#### ‚úÖ Conclusi√≥n

La `inicializaci√≥n perezosa` funciona en aplicaciones `single-thread`, pero no garantiza `thread-safety`.
Para escenarios `multi-hilo`, es necesario a√±adir sincronizaci√≥n u otros mecanismos, que veremos en la siguiente
variante.

### 4. Lazy Initialization (Inicializaci√≥n Perezosa) - Thread Safe (synchronized)

En la implementaci√≥n anterior del `Lazy Initialization`, vimos que m√∫ltiples hilos pod√≠an entrar simult√°neamente al
m√©todo `getInstance()` y terminar creando varias instancias del Singleton, rompiendo el patr√≥n.

La forma m√°s sencilla de resolver este problema es sincronizar el m√©todo de acceso global `(getInstance())`. Con
`synchronized`, solo un hilo puede ejecutar ese m√©todo a la vez:

- Si un hilo ya est√° creando la instancia, los dem√°s deber√°n esperar.
- Una vez creada la instancia, los dem√°s hilos simplemente la reutilizar√°n.

#### Implementaci√≥n con `synchronized`

````java

@Slf4j
public class Logger {

    private static Logger instance;

    private Logger() {
        log.info("Instancia creada");
    }

    public static synchronized Logger getInstance() { // El uso de synchronized garantiza seguridad en entornos multihilo.
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }
}
````

#### Prueba concurrente con `ExecutorService`

En la siguiente prueba creamos un pool de 10 hilos y lanzamos 10 tareas que acceden a la instancia del Singleton.
Cada hilo imprime el `identityHashCode` de la instancia para verificar que es la misma en todos los casos.

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        try (ExecutorService executorService = Executors.newFixedThreadPool(10)) {
            IntStream.range(0, 10).forEach(value -> {
                Runnable task = () -> {
                    Logger instance = Logger.getInstance();
                    log.info("Thread-{} -> {}", value, System.identityHashCode(instance));
                };
                executorService.submit(task);
            });
            executorService.shutdown();
        }
    }
}
````

#### Resultado esperado

La salida confirma que:

1. La instancia solo se crea una vez (`"Instancia creada"` aparece solo una vez en el log).
2. Todos los hilos comparten la misma instancia, ya que el `identityHashCode` es id√©ntico en todos los casos.

````bash
14:17:02.117 [pool-1-thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Logger -- Instancia creada
14:17:02.123 [pool-1-thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-3 -> 2141535956
14:17:02.122 [pool-1-thread-10] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-9 -> 2141535956
14:17:02.123 [pool-1-thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-7 -> 2141535956
14:17:02.122 [pool-1-thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-8 -> 2141535956
14:17:02.122 [pool-1-thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-1 -> 2141535956
14:17:02.123 [pool-1-thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-0 -> 2141535956
14:17:02.123 [pool-1-thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-2 -> 2141535956
14:17:02.123 [pool-1-thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-4 -> 2141535956
14:17:02.123 [pool-1-thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-5 -> 2141535956
14:17:02.123 [pool-1-thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-6 -> 2141535956
````

#### Conclusi√≥n

- ‚úÖ Esta variante garantiza `thread-safety`.
- ‚ö†Ô∏è Sin embargo, el uso de `synchronized` en cada llamada a `getInstance()` introduce sobrecarga de rendimiento,
  ya que incluso despu√©s de creada la instancia, los hilos siguen compitiendo por la sincronizaci√≥n.
- Por esta raz√≥n, en aplicaciones de alto rendimiento se suele preferir optimizaciones como el `Double-Checked Locking`
  o el enfoque de `Bill Pugh` (que ya vimos antes).

### 5. Lazy Initialization (Inicializaci√≥n Perezosa) - Thread Safe (Double-Checked Locking)

Cuando aplicamos `synchronized` directamente en todo el m√©todo `getInstance()`, logramos seguridad en entornos
multihilo, pero el costo de sincronizaci√≥n se paga cada vez que se invoca el m√©todo, incluso despu√©s de que la
instancia ya fue creada.

Para mejorar esto, podemos aplicar el patr√≥n de bloqueo verificado dos veces `(Double-Checked Locking)`.
Este enfoque consiste en:

1. `Primera verificaci√≥n (check 1)`:
    - Se comprueba si la instancia es `null` antes de entrar al bloque sincronizado.
    - Esto evita que todos los hilos pasen a la secci√≥n cr√≠tica cuando ya existe una instancia.


2. `Bloque sincronizado`:
    - Si la instancia a√∫n no existe, solo un hilo podr√° entrar en la secci√≥n sincronizada.


3. `Segunda verificaci√≥n (check 2)`:
    - Dentro del bloque sincronizado se vuelve a comprobar si la instancia sigue siendo `null` antes de crearla.
    - Esto asegura que solo un hilo cree la instancia, incluso si varios hilos llegaron casi al mismo tiempo.

- ‚ö†Ô∏è `Problema hist√≥rico`: antes de Java 5, este patr√≥n pod√≠a fallar porque la `JVM` pod√≠a `‚Äúpublicar‚Äù` un objeto
  parcialmente construido.
- ‚úÖ `Soluci√≥n`: marcar la variable instance como `volatile`. Esto garantiza que la instancia no ser√° visible para
  otros hilos hasta que se inicialice por completo.

#### ¬øQu√© significa `volatile` en Java?

En Java, cuando varios hilos acceden a una misma variable, existe un problema llamado `cach√© de hilos`:

- Cada hilo puede guardar una copia local de la variable en su propia memoria cach√© (en lugar de leerla directamente de
  la memoria principal de la JVM).
- Esto significa que un hilo podr√≠a estar trabajando con un valor antiguo o desactualizado, aunque otro hilo ya lo haya
  cambiado.

#### ¬øQu√© hace `volatile`?

Cuando declaras una variable como `volatile`, le est√°s diciendo a la JVM:

1. `Visibilidad garantizada`:
    - Todos los hilos siempre leer√°n y escribir√°n el valor directamente en la memoria principal.
    - üëâ As√≠, si un hilo cambia la variable, los dem√°s hilos ven inmediatamente ese cambio.

2. `Orden de publicaci√≥n seguro`:
    - `volatile` asegura que la variable no estar√° disponible para otros hilos hasta que haya sido completamente
      inicializada.
    - üëâ Esto evita que un hilo reciba una ‚Äúinstancia a medio construir‚Äù.

#### El Problema Sin volatile

Imag√≠nate que tienes varios hilos trabajando, y cada hilo tiene su propia copia local de la variable instance en su
`cache/memoria`:

````bash
Hilo 1: instance = null (en su cache local)
Hilo 2: instance = null (en su cache local)  
Memoria Principal: instance = null
````

¬øQu√© puede pasar?

1. Hilo 1 entra, ve `instance == null`, crea la instancia
2. Hilo 1 guarda `instance = nueva_instancia` en su cache local
3. Hilo 2 sigue viendo `instance == null` en su cache local
4. ¬°Hilo 2 crea OTRA instancia! üí•

La soluci√≥n con `volatile`. `volatile` le dice a la JVM: `¬°Oye! Esta variable es especial`:

1. `No uses cache local` - Siempre lee/escribe directo en memoria principal
2. `Hazlo visible inmediatamente` - Cuando un hilo cambie la variable, todos los dem√°s hilos lo ven al instante

#### Implementaci√≥n

````java

@Slf4j
public class CacheManager {

    // 'volatile' garantiza la visibilidad y evita problemas de publicaci√≥n parcial
    private static volatile CacheManager instance;

    private CacheManager() {
        log.info("Instancia creada");
    }

    public static CacheManager getInstance() {
        if (instance == null) { // check 1
            synchronized (CacheManager.class) {
                if (instance == null) { // check 2
                    instance = new CacheManager();
                }
            }
        }
        return instance;
    }
}
````

#### Ejecuci√≥n de prueba

````java

@Slf4j
public class Main {
    public static void main(String[] args) {
        try (ExecutorService executorService = Executors.newFixedThreadPool(10)) {
            IntStream.range(0, 10).forEach(value -> {
                Runnable task = () -> {
                    CacheManager instance = CacheManager.getInstance();
                    log.info("Thread-{} -> {}", value, System.identityHashCode(instance));
                };
                executorService.submit(task);
            });
            executorService.shutdown();
        }
    }
}
````

#### Resultado esperado

````bash
18:26:25.372 [pool-1-thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.CacheManager -- Instancia creada
18:26:25.377 [pool-1-thread-3] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-2 -> 1521103290
18:26:25.377 [pool-1-thread-4] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-3 -> 1521103290
18:26:25.377 [pool-1-thread-10] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-9 -> 1521103290
18:26:25.377 [pool-1-thread-5] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-4 -> 1521103290
18:26:25.377 [pool-1-thread-1] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-0 -> 1521103290
18:26:25.377 [pool-1-thread-6] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-5 -> 1521103290
18:26:25.377 [pool-1-thread-7] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-6 -> 1521103290
18:26:25.377 [pool-1-thread-2] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-1 -> 1521103290
18:26:25.377 [pool-1-thread-8] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-7 -> 1521103290
18:26:25.377 [pool-1-thread-9] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.lazy.threadsafe.Main -- Thread-8 -> 1521103290
````

Observamos que:

- La instancia se crea `una sola vez` (`"Instancia creada"`).
- Todos los hilos comparten la misma referencia (`System.identityHashCode` id√©ntico).

> ‚úÖ `Ventaja`: m√°s eficiente que sincronizar todo el m√©todo, ya que la sincronizaci√≥n solo se usa durante la creaci√≥n
> inicial.
>
> ‚ö†Ô∏è `Desventaja`: aunque ahora es seguro gracias a `volatile`, es un patr√≥n m√°s complejo que puede ser reemplazado por
> enfoques m√°s simples (como `Bill Pugh`).

### 6.Violaci√≥n de Singleton con Reflexi√≥n

Incluso si usamos la `Inicializaci√≥n Temprana (Eager Initialization)` para crear un `Singleton`, todav√≠a existe una
manera de romper este patr√≥n en Java: `el uso de la reflexi√≥n`.

`Java Reflection API` permite acceder y manipular clases, m√©todos y constructores en tiempo de ejecuci√≥n, incluso si
son privados. Esto significa que un atacante (o incluso nosotros, por error) puede crear nuevas instancias de un
`Singleton` accediendo a su constructor privado.

#### Ejemplo de implementaci√≥n (Eager Initialization)

````java

@Slf4j
public class EventRegistry {

    private static final EventRegistry instance = new EventRegistry();

    private EventRegistry() {
        log.info("Instancia creada");
    }

    public static EventRegistry getInstance() {
        return instance;
    }

}
````

En este punto, todo parece correcto:

- El constructor es privado.
- La instancia se crea una sola vez al cargar la clase.
- `getInstance()` devuelve siempre la misma referencia.

#### Rompiendo el Singleton con Reflexi√≥n

````java

@Slf4j
public class Main {
    public static void main(String[] args) throws Exception {
        EventRegistry registry1 = EventRegistry.getInstance();
        EventRegistry registry2 = EventRegistry.getInstance();
        log.info("{}", System.identityHashCode(registry1));
        log.info("{}", System.identityHashCode(registry2));

        // Usando reflexi√≥n para acceder al constructor privado
        Class<?> clazz = Class.forName("dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.EventRegistry");
        Constructor<EventRegistry> constructor = (Constructor<EventRegistry>) clazz.getDeclaredConstructor();
        constructor.setAccessible(true);  // <-- Forzamos acceso al constructor privado

        // Creamos una nueva instancia en tiempo de ejecuci√≥n
        EventRegistry registry3 = constructor.newInstance();
        log.info("{}", System.identityHashCode(registry3));
    }
}
````

#### Salida de ejecuci√≥n

````bash
19:34:09.500 [main] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.EventRegistry -- Instancia creada
19:34:09.500 [main] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.Main -- 306206744
19:34:09.500 [main] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.Main -- 306206744
19:34:09.500 [main] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.EventRegistry -- Instancia creada
19:34:09.500 [main] INFO dev.magadiflo.patterns.plainjava.creational.singleton.implementations.reflection.problem.Main -- 477289012
````

üëâ Observamos que:

- La primera instancia (`registry1`) y la segunda (`registry2`) tienen el mismo `identityHashCode`.
- Pero al usar `reflexi√≥n`, se crea una nueva instancia (`registry3`), con un `identityHashCode` distinto.
- Esto demuestra que el patr√≥n `Singleton` puede ser violado f√°cilmente con `Reflection`.

#### üîé Conclusi√≥n de este caso

> Aunque el constructor es privado, la reflexi√≥n permite saltarse esa restricci√≥n y crear m√∫ltiples instancias de una
> clase Singleton. Esto rompe la idea central del patr√≥n, que es garantizar una sola instancia global.
>
> (M√°s adelante veremos c√≥mo protegernos contra este tipo de violaci√≥n, por ahora solo nos quedamos con la evidencia del
> problema üëÄ).

