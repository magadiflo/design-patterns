# Patrones creacionales

Los patrones creacionales de GoF son un tipo de `patrones de diseÃ±o de software` que se centran en la
`creaciÃ³n de objetos`. Su propÃ³sito principal es desacoplar la forma en que los objetos se crean de la forma en que se
usan. Esto significa que proporcionan mecanismos para crear objetos de una manera que es flexible, eficiente y
controlada, sin necesidad de especificar la clase exacta de objeto que se va a crear.

Estos patrones te permiten:

- `Abstraer la lÃ³gica de instanciaciÃ³n`: Te dan la flexibilidad de crear objetos sin usar directamente el operador
  `new`. Esto es Ãºtil cuando el proceso de creaciÃ³n es complejo, involucra varias etapas o depende de la configuraciÃ³n
  del sistema.


- `Encapsular la creaciÃ³n de objetos`: Ocultan los detalles de cÃ³mo se crean los objetos, lo que facilita el cambio de
  la implementaciÃ³n de la creaciÃ³n sin afectar el cÃ³digo cliente.


- `Promover la flexibilidad y la reutilizaciÃ³n`: Al desacoplar el cÃ³digo que usa los objetos de la lÃ³gica de creaciÃ³n,
  puedes cambiar fÃ¡cilmente el tipo de objeto que se crea, adaptÃ¡ndolo a diferentes contextos o requisitos.

En resumen, los patrones creacionales son soluciones elegantes para problemas de creaciÃ³n de objetos, promoviendo un
diseÃ±o de software mÃ¡s robusto, modular y fÃ¡cil de mantener.

ğŸ“Œ Ejemplos clÃ¡sicos: `Singleton`, `Factory Method`, `Builder`, etc.

---

## Factory Method

El `Factory Method` define una interfaz para crear objetos, pero permite que las subclases decidan quÃ© clase instanciar.
En otras palabras, delega la creaciÃ³n de objetos a las subclases.

### CaracterÃ­sticas del Factory Method

âœ… Ventajas:

- `Elimina acoplamiento`: El cÃ³digo cliente no conoce las clases concretas
- `Principio Abierto/Cerrado`: FÃ¡cil agregar nuevos productos sin modificar cÃ³digo existente
- `Single Responsibility`: Cada factory se encarga de crear un tipo especÃ­fico
- `Polimorfismo`: Usa herencia y polimorfismo para la creaciÃ³n

âŒ Desventajas:

- `Complejidad`: Introduce mÃ¡s clases al sistema
- `JerarquÃ­a`: Requiere crear subclases para cada tipo de producto

### ğŸ¯ CuÃ¡ndo usar Factory Method:

- Cuando no sabes de antemano quÃ© tipos exactos de objetos necesitarÃ¡s
- Cuando quieres proporcionar a los usuarios una forma de extender componentes internos
- Cuando quieres reutilizar objetos existentes en lugar de crear nuevos
- Cuando el proceso de construcciÃ³n de objetos es complejo

### ğŸ’¼ Ejemplos del mundo real:

- `GUI Frameworks`: Crear botones especÃ­ficos segÃºn el OS (Windows, Mac, Linux)
- `Conectores de BD`: Crear conexiones segÃºn el tipo (MySQL, PostgreSQL, Oracle)
- `Procesadores de archivos`: Crear parsers segÃºn extensiÃ³n (.csv, .json, .xml)
- `Sistemas de logging`: Crear loggers segÃºn destino (file, console, database)
- `Notificaciones`: Crear notificadores segÃºn canal (email, SMS, push) â† Nuestro caso

### ğŸ“ RepresentaciÃ³n UML del patrÃ³n Factory Method

![01.png](assets/03-java-plano-creacional/01.png)

1. El `Product` declara la interfaz, que es comÃºn a todos los objetos que puede producir la clase creadora y sus
   subclases.

2. Los `Concrete Products` son distintas implementaciones de la interfaz `Product`.
3. La clase `Creator` declara el mÃ©todo de fÃ¡brica `(Factory Method)` que devuelve nuevos objetos de `Product`. Es
   importante que el tipo de retorno de este mÃ©todo coincida con la interfaz `Product`.
   > Puedes declarar el patrÃ³n `Factory Method` como abstracto para forzar a todas las subclases a implementar sus
   > propias versiones del mÃ©todo. Como alternativa, el mÃ©todo de fÃ¡brica base puede devolver algÃºn tipo de producto
   > por defecto.
   >
   > Observa que, a pesar de su nombre, la creaciÃ³n de producto no es la principal responsabilidad de la clase
   > `Creator`. Normalmente, esta clase cuenta con alguna lÃ³gica de negocios central relacionada con los productos. El
   > patrÃ³n `Factory Method` ayuda a desacoplar esta lÃ³gica de las clases concretas de producto.


4. Los `Concrete Creators` sobreescriben el `Factory Method` base, de modo que devuelva un tipo diferente de `Product`.
   > Observa que el mÃ©todo de fÃ¡brica no tiene que crear nuevas instancias todo el tiempo. TambiÃ©n puede devolver
   > objetos existentes de una memorÃ­a cachÃ©, una agrupaciÃ³n de objetos, u otra fuente.

### ğŸ¯ Ejemplo 01: Estrategias de pago

`Contexto realista`: Supongamos que queremos aplicar diferentes estrategias de pago: `tarjeta de crÃ©dito`, `PayPal` y
`transferencia bancaria`.

Entonces, la implementaciÃ³n de nuestro patrÃ³n `Strategy` estarÃ¡ basado en el siguiente diagrama de clases.

![02.png](assets/02-java-plano-comportamiento/02.png)
