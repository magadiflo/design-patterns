# Patrones estructurales aplicados en Spring Boot

---

# Adapter

## üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

### Modelo externo del servicio de OpenWeather

Este conjunto de records representa el modelo externo que define la estructura del JSON recibido desde el servicio de
`OpenWeather`. Cada clase refleja una parte del payload original: ciudad (name), pa√≠s (Sys), temperatura (Main) y
descripci√≥n del clima (Weather). Estas estructuras est√°n alineadas con el formato que expone la API p√∫blica de
`OpenWeather` y se utilizan exclusivamente para deserializar la respuesta tal como llega desde el proveedor.

En el contexto del patr√≥n `Adapter`, este modelo act√∫a como el formato nativo del `Adaptee`, es decir, el lenguaje
propio del servicio externo. No est√° dise√±ado para ser usado directamente por el resto de la aplicaci√≥n, sino que ser√°
transformado por el `Adapter` hacia un modelo interno m√°s coherente con las necesidades del dominio.

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record OpenWeatherResponse(String name,
                                  Sys sys,
                                  Main main,
                                  @JsonProperty(value = "weather")
                                  List<Weather> weathers) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Main(double temp) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Sys(String country) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Weather(String description) {
}
````

### Modelo interno del negocio

Este record representa el modelo interno del negocio, dise√±ado para encapsular la informaci√≥n clim√°tica en un formato
coherente con las necesidades de la aplicaci√≥n. A diferencia del modelo externo, este objeto est√° simplificado y
estructurado para ser consumido directamente por los controladores, servicios o capas de presentaci√≥n.

En el contexto del patr√≥n `Adapter`, `WeatherInfo` es el formato objetivo al que se debe adaptar la respuesta del
proveedor externo. Es decir, es el modelo que la aplicaci√≥n espera recibir, independientemente de c√≥mo est√©
estructurada la fuente original. Esta separaci√≥n permite desacoplar el dominio interno del formato externo, facilitando
el mantenimiento, la evoluci√≥n del sistema y la integraci√≥n con m√∫ltiples proveedores en el futuro.

````java
public record WeatherInfo(String city,
                          String country,
                          double temperature,
                          String description) {
}
````

### Adaptee

Esta clase representa el `Adaptee` dentro del patr√≥n `Adapter`. Se trata de un cliente especializado que encapsula la
l√≥gica de comunicaci√≥n con el servicio externo de `OpenWeather`. Su interfaz y modelo de respuesta
(`OpenWeatherResponse`) est√°n acoplados al formato original del proveedor, lo que lo hace incompatible directamente
con el modelo interno de la aplicaci√≥n.

El `OpenWeatherApiClient` se encarga de construir la solicitud HTTP, manejar errores espec√≠ficos del proveedor (como
c√≥digos 4xx y 5xx), y devolver la respuesta en su forma nativa. Adem√°s, incluye un manejo robusto de excepciones
(`ExternalApiException`) para propagar fallos de red, deserializaci√≥n o l√≥gica del proveedor.

En t√©rminos del patr√≥n `Adapter`, esta clase es el componente externo que necesita ser adaptado. Su interfaz no cumple
con las expectativas del resto del sistema, por lo que ser√° envuelta por un `Adapter` que traduzca su salida al modelo
interno (`WeatherInfo`) y exponga una interfaz m√°s estable y coherente (`WeatherService`).

````java

@Slf4j
@Component
public class OpenWeatherApiClient {

    private static final String API_KEY = "1e795276e48658194d444a8b37e77bfc";
    private final RestClient restClient;

    public OpenWeatherApiClient(RestClient.Builder builder) {
        this.restClient = builder.baseUrl("https://api.openweathermap.org").build();
    }

    public OpenWeatherResponse fetchWeather(String city) {
        try {
            return this.restClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/data/2.5/weather")
                            .queryParam("q", city)
                            .queryParam("appid", API_KEY)
                            .queryParam("units", "metric")
                            .build())
                    .retrieve()
                    .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                        log.warn("Ciudad no encontrada: {}", city);
                        throw new ExternalApiException("Ciudad no encontrada: " + city);
                    })
                    .onStatus(HttpStatusCode::is5xxServerError, (request, response) -> {
                        log.error("Error interno en OpenWeather API");
                        throw new ExternalApiException("Error en el proveedor clim√°tico");
                    })
                    .body(OpenWeatherResponse.class);
        } catch (RestClientException e) {
            log.error("Error al consumir OpenWeather: {}", e.getMessage());
            throw new ExternalApiException("No se pudo conectar con el proveedor clim√°tico: " + e.getMessage());
        }
    }
}
````

````java
public class ExternalApiException extends RuntimeException {
    public ExternalApiException(String message) {
        super(message);
    }
}
````

### Target (interfaz esperada)

Esta interfaz representa el `Target` dentro del patr√≥n `Adapter`. Define el contrato que la aplicaci√≥n espera utilizar
para obtener informaci√≥n clim√°tica, sin preocuparse por la fuente ni el formato original de los datos. Al abstraer
el acceso al clima mediante `WeatherService`, se logra un nivel de desacoplamiento que permite cambiar el proveedor
externo sin afectar el resto del sistema.

En t√©rminos del patr√≥n `Adapter`, esta interfaz es el punto de conexi√≥n est√°ndar que el cliente (por ejemplo, el
`controlador`) consume. El `Adapter` se encargar√° de implementar esta interfaz y traducir las llamadas hacia el
`Adaptee` (`OpenWeatherApiClient`), devolviendo los datos en el formato interno (`WeatherInfo`) que la aplicaci√≥n
necesita.

````java
public interface WeatherService {
    WeatherInfo getWeather(String city);
}
````

### Adapter

Esta clase representa el `Adapter` dentro del patr√≥n `Adapter`. Su funci√≥n principal es traducir la respuesta del
`Adaptee` (`OpenWeatherApiClient`) al modelo interno (`WeatherInfo`) que la aplicaci√≥n espera consumir. Implementa la
interfaz `WeatherService`, lo que permite que el resto del sistema interact√∫e con ella sin conocer los detalles del
proveedor externo.

El m√©todo `getWeather(...)` encapsula la l√≥gica de adaptaci√≥n: invoca al cliente externo, recibe el modelo nativo
(`OpenWeatherResponse`) y lo transforma mediante el m√©todo privado `toWeatherInfo(...)`. Esta transformaci√≥n desacopla
completamente el formato externo del proveedor del modelo interno del negocio, permitiendo que el controlador y otras
capas trabajen con una estructura estable y coherente.

Gracias a esta clase, el sistema puede integrar `OpenWeather` sin depender directamente de su estructura, y queda
preparado para incorporar otros proveedores clim√°ticos en el futuro simplemente creando nuevos adapters que implementen
la misma interfaz `WeatherService`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class OpenWeatherAdapterService implements WeatherService {

    private final OpenWeatherApiClient api;

    @Override
    public WeatherInfo getWeather(String city) {
        OpenWeatherResponse weatherResponse = this.api.fetchWeather(city);
        return this.toWeatherInfo(weatherResponse);
    }

    private WeatherInfo toWeatherInfo(OpenWeatherResponse response) {
        return new WeatherInfo(
                response.name(),
                response.sys().country(),
                response.main().temp(),
                response.weathers().getFirst().description()
        );
    }
}
````

### Client

Esta clase representa el `Client` dentro del patr√≥n `Adapter`. Es el componente que consume la interfaz `WeatherService`
para obtener informaci√≥n clim√°tica, sin conocer ni depender de los detalles de implementaci√≥n, el proveedor externo
o el formato original de los datos. El controlador simplemente invoca el m√©todo `getWeather(...)` y recibe un objeto
`WeatherInfo`, ya adaptado y listo para ser expuesto como respuesta HTTP.

Gracias a esta abstracci√≥n, el cliente puede mantenerse enfocado en su responsabilidad ‚Äîexponer un endpoint REST‚Äî
mientras delega completamente la l√≥gica de integraci√≥n y transformaci√≥n al Adapter. Esto permite que el sistema sea m√°s
flexible, testeable y preparado para evolucionar sin romper contratos externos.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/weathers")
public class WeatherController {

    private final WeatherService weatherService;

    @GetMapping
    public ResponseEntity<WeatherInfo> getWeather(@RequestParam String city) {
        return ResponseEntity.ok(this.weatherService.getWeather(city));
    }

}
````

### Resultado

Este resultado confirma que toda tu implementaci√≥n est√° funcionando de forma impecable: el `Adapter` ha cumplido su rol
al transformar correctamente la respuesta del proveedor externo (`OpenWeatherResponse`) en el modelo interno
(`WeatherInfo`), y el controlador ha expuesto el endpoint REST con una estructura clara, coherente y desacoplada.

El JSON de salida refleja exactamente lo que tu aplicaci√≥n necesita: una respuesta limpia, sem√°ntica y lista para ser
consumida por cualquier cliente frontend o servicio externo. Adem√°s, el uso de curl y jq para validar el endpoint
demuestra una pr√°ctica profesional de verificaci√≥n directa, ideal para pruebas r√°pidas y documentaci√≥n t√©cnica.

Este resultado no solo valida el funcionamiento t√©cnico, sino que tambi√©n ilustra el valor del patr√≥n Adapter aplicado
en un contexto real: integraci√≥n con servicios externos sin comprometer la estabilidad ni la claridad del modelo
interno.

````bash
$ curl -v http://localhost:8080/api/v1/weathers?city=Chimbote | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Sun, 28 Sep 2025 06:24:45 GMT
<
{
  "city": "Chimbote",
  "country": "PE",
  "temperature": 16.46,
  "description": "scattered clouds"
} 
````
