# Patrones estructurales aplicados en Spring Boot

---

# Adapter

## üéØ Ejemplo 01: Consumir APIs externas de distintos proveedores (climas)

Nuestra aplicaci√≥n necesita consultar el clima actual de una ciudad, pero queremos que el resto del sistema use una
interfaz unificada, sin importar qu√© proveedor de clima est√© detr√°s (`OpenWeather`, `WeatherStack`, `AccuWeather`,
etc.).

El problema es que cada API externa:

- Expone endpoints diferentes.
- Requiere par√°metros con nombres distintos.
- Devuelve estructuras JSON/XML incompatibles entre s√≠.

Aplicaremos el patr√≥n Adapter para desacoplar nuestra l√≥gica de negocio de la implementaci√≥n concreta de cada proveedor.

### Modelo externo del servicio de OpenWeather

Este conjunto de records representa el modelo externo que define la estructura del JSON recibido desde el servicio de
`OpenWeather`. Cada clase refleja una parte del payload original: ciudad (name), pa√≠s (Sys), temperatura (Main) y
descripci√≥n del clima (Weather). Estas estructuras est√°n alineadas con el formato que expone la API p√∫blica de
`OpenWeather` y se utilizan exclusivamente para deserializar la respuesta tal como llega desde el proveedor.

En el contexto del patr√≥n `Adapter`, este modelo act√∫a como el formato nativo del `Adaptee`, es decir, el lenguaje
propio del servicio externo. No est√° dise√±ado para ser usado directamente por el resto de la aplicaci√≥n, sino que ser√°
transformado por el `Adapter` hacia un modelo interno m√°s coherente con las necesidades del dominio.

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record OpenWeatherResponse(String name,
                                  Sys sys,
                                  Main main,
                                  @JsonProperty(value = "weather")
                                  List<Weather> weathers) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Main(double temp) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Sys(String country) {
}
````

````java

@JsonIgnoreProperties(ignoreUnknown = true)
public record Weather(String description) {
}
````

### Modelo interno del negocio

Este record representa el modelo interno del negocio, dise√±ado para encapsular la informaci√≥n clim√°tica en un formato
coherente con las necesidades de la aplicaci√≥n. A diferencia del modelo externo, este objeto est√° simplificado y
estructurado para ser consumido directamente por los controladores, servicios o capas de presentaci√≥n.

En el contexto del patr√≥n `Adapter`, `WeatherInfo` es el formato objetivo al que se debe adaptar la respuesta del
proveedor externo. Es decir, es el modelo que la aplicaci√≥n espera recibir, independientemente de c√≥mo est√©
estructurada la fuente original. Esta separaci√≥n permite desacoplar el dominio interno del formato externo, facilitando
el mantenimiento, la evoluci√≥n del sistema y la integraci√≥n con m√∫ltiples proveedores en el futuro.

````java
public record WeatherInfo(String city,
                          String country,
                          double temperature,
                          String description) {
}
````

### Adaptee

Esta clase representa el `Adaptee` dentro del patr√≥n `Adapter`. Se trata de un cliente especializado que encapsula la
l√≥gica de comunicaci√≥n con el servicio externo de `OpenWeather`. Su interfaz y modelo de respuesta
(`OpenWeatherResponse`) est√°n acoplados al formato original del proveedor, lo que lo hace incompatible directamente
con el modelo interno de la aplicaci√≥n.

El `OpenWeatherApiClient` se encarga de construir la solicitud HTTP, manejar errores espec√≠ficos del proveedor (como
c√≥digos 4xx y 5xx), y devolver la respuesta en su forma nativa. Adem√°s, incluye un manejo robusto de excepciones
(`ExternalApiException`) para propagar fallos de red, deserializaci√≥n o l√≥gica del proveedor.

En t√©rminos del patr√≥n `Adapter`, esta clase es el componente externo que necesita ser adaptado. Su interfaz no cumple
con las expectativas del resto del sistema, por lo que ser√° envuelta por un `Adapter` que traduzca su salida al modelo
interno (`WeatherInfo`) y exponga una interfaz m√°s estable y coherente (`WeatherService`).

````java

@Slf4j
@Component
public class OpenWeatherApiClient {

    private static final String API_KEY = "1e795276e48658194d444a8b37e77bfc";
    private final RestClient restClient;

    public OpenWeatherApiClient(RestClient.Builder builder) {
        this.restClient = builder.baseUrl("https://api.openweathermap.org").build();
    }

    public OpenWeatherResponse fetchWeather(String city) {
        try {
            return this.restClient.get()
                    .uri(uriBuilder -> uriBuilder
                            .path("/data/2.5/weather")
                            .queryParam("q", city)
                            .queryParam("appid", API_KEY)
                            .queryParam("units", "metric")
                            .build())
                    .retrieve()
                    .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> {
                        log.warn("Ciudad no encontrada: {}", city);
                        throw new ExternalApiException("Ciudad no encontrada: " + city);
                    })
                    .onStatus(HttpStatusCode::is5xxServerError, (request, response) -> {
                        log.error("Error interno en OpenWeather API");
                        throw new ExternalApiException("Error en el proveedor clim√°tico");
                    })
                    .body(OpenWeatherResponse.class);
        } catch (RestClientException e) {
            log.error("Error al consumir OpenWeather: {}", e.getMessage());
            throw new ExternalApiException("No se pudo conectar con el proveedor clim√°tico: " + e.getMessage());
        }
    }
}
````

````java
public class ExternalApiException extends RuntimeException {
    public ExternalApiException(String message) {
        super(message);
    }
}
````

### Target (interfaz esperada)

Esta interfaz representa el `Target` dentro del patr√≥n `Adapter`. Define el contrato que la aplicaci√≥n espera utilizar
para obtener informaci√≥n clim√°tica, sin preocuparse por la fuente ni el formato original de los datos. Al abstraer
el acceso al clima mediante `WeatherService`, se logra un nivel de desacoplamiento que permite cambiar el proveedor
externo sin afectar el resto del sistema.

En t√©rminos del patr√≥n `Adapter`, esta interfaz es el punto de conexi√≥n est√°ndar que el cliente (por ejemplo, el
`controlador`) consume. El `Adapter` se encargar√° de implementar esta interfaz y traducir las llamadas hacia el
`Adaptee` (`OpenWeatherApiClient`), devolviendo los datos en el formato interno (`WeatherInfo`) que la aplicaci√≥n
necesita.

````java
public interface WeatherService {
    WeatherInfo getWeather(String city);
}
````

### Adapter

Esta clase representa el `Adapter` dentro del patr√≥n `Adapter`. Su funci√≥n principal es traducir la respuesta del
`Adaptee` (`OpenWeatherApiClient`) al modelo interno (`WeatherInfo`) que la aplicaci√≥n espera consumir. Implementa la
interfaz `WeatherService`, lo que permite que el resto del sistema interact√∫e con ella sin conocer los detalles del
proveedor externo.

El m√©todo `getWeather(...)` encapsula la l√≥gica de adaptaci√≥n: invoca al cliente externo, recibe el modelo nativo
(`OpenWeatherResponse`) y lo transforma mediante el m√©todo privado `toWeatherInfo(...)`. Esta transformaci√≥n desacopla
completamente el formato externo del proveedor del modelo interno del negocio, permitiendo que el controlador y otras
capas trabajen con una estructura estable y coherente.

Gracias a esta clase, el sistema puede integrar `OpenWeather` sin depender directamente de su estructura, y queda
preparado para incorporar otros proveedores clim√°ticos en el futuro simplemente creando nuevos adapters que implementen
la misma interfaz `WeatherService`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class OpenWeatherAdapterService implements WeatherService {

    private final OpenWeatherApiClient api;

    @Override
    public WeatherInfo getWeather(String city) {
        OpenWeatherResponse weatherResponse = this.api.fetchWeather(city);
        return this.toWeatherInfo(weatherResponse);
    }

    private WeatherInfo toWeatherInfo(OpenWeatherResponse response) {
        return new WeatherInfo(
                response.name(),
                response.sys().country(),
                response.main().temp(),
                response.weathers().getFirst().description()
        );
    }
}
````

### Client

Esta clase representa el `Client` dentro del patr√≥n `Adapter`. Es el componente que consume la interfaz `WeatherService`
para obtener informaci√≥n clim√°tica, sin conocer ni depender de los detalles de implementaci√≥n, el proveedor externo
o el formato original de los datos. El controlador simplemente invoca el m√©todo `getWeather(...)` y recibe un objeto
`WeatherInfo`, ya adaptado y listo para ser expuesto como respuesta HTTP.

Gracias a esta abstracci√≥n, el cliente puede mantenerse enfocado en su responsabilidad ‚Äîexponer un endpoint REST‚Äî
mientras delega completamente la l√≥gica de integraci√≥n y transformaci√≥n al Adapter. Esto permite que el sistema sea m√°s
flexible, testeable y preparado para evolucionar sin romper contratos externos.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/weathers")
public class WeatherController {

    private final WeatherService weatherService;

    @GetMapping
    public ResponseEntity<WeatherInfo> getWeather(@RequestParam String city) {
        return ResponseEntity.ok(this.weatherService.getWeather(city));
    }

}
````

### Resultado

Este resultado confirma que toda tu implementaci√≥n est√° funcionando de forma impecable: el `Adapter` ha cumplido su rol
al transformar correctamente la respuesta del proveedor externo (`OpenWeatherResponse`) en el modelo interno
(`WeatherInfo`), y el controlador ha expuesto el endpoint REST con una estructura clara, coherente y desacoplada.

El JSON de salida refleja exactamente lo que tu aplicaci√≥n necesita: una respuesta limpia, sem√°ntica y lista para ser
consumida por cualquier cliente frontend o servicio externo. Adem√°s, el uso de curl y jq para validar el endpoint
demuestra una pr√°ctica profesional de verificaci√≥n directa, ideal para pruebas r√°pidas y documentaci√≥n t√©cnica.

Este resultado no solo valida el funcionamiento t√©cnico, sino que tambi√©n ilustra el valor del patr√≥n Adapter aplicado
en un contexto real: integraci√≥n con servicios externos sin comprometer la estabilidad ni la claridad del modelo
interno.

````bash
$ curl -v http://localhost:8080/api/v1/weathers?city=Chimbote | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Sun, 28 Sep 2025 06:24:45 GMT
<
{
  "city": "Chimbote",
  "country": "PE",
  "temperature": 16.46,
  "description": "scattered clouds"
} 
````

---

# Proxy

## üéØ Ejemplo 01: Proxy + Cache-Aside para Cat√°logo de Productos

En un sistema de `e-commerce`, el cat√°logo de productos es una de las partes m√°s consultadas por los clientes:

- Buscar productos por categor√≠a (ej. ‚Äúzapatos deportivos‚Äù).
- Consultar productos relacionados (ej. ‚Äúquien compr√≥ este producto tambi√©n vio‚Ä¶‚Äù).
- Buscar con filtros avanzados (precio m√≠nimo y m√°ximo, categor√≠a, etc.).

Estas operaciones suelen ser costosas porque:

- Requieren m√∫ltiples consultas a la base de datos.
- Pueden involucrar c√°lculos adicionales (ej. recomendaciones, descuentos, disponibilidad).
- Escalan r√°pidamente si miles de usuarios hacen b√∫squedas al mismo tiempo.

Para mejorar la performance y la experiencia del usuario, muchas empresas aplican cach√©s intermedias (como `Redis` o
`Guava`). En este ejemplo simularemos ese comportamiento implementando el `patr√≥n Proxy` con la estrategia
`Cache-Aside`.

### üß© Modelo de dominio ‚Äî Product

Esta clase representa la entidad principal del dominio: `un producto dentro del sistema de cat√°logo`.
Su funci√≥n es modelar los atributos esenciales de un producto, los cuales pueden ser utilizados por diferentes capas de
la aplicaci√≥n (servicio, repositorio, controladores, etc.).

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
public class Product {
    private Long id;
    private String name;
    private String category;
    private BigDecimal price;
    private Double rating;
    private String brand;
    private boolean available;
}
````

### üßæ Data Transfer Objects (DTOs)

Los `DTOs (Data Transfer Objects)` son clases inmutables utilizadas para transportar datos entre las capas de la
aplicaci√≥n (por ejemplo, desde el servicio hasta el controlador o hacia la respuesta HTTP).

Su principal objetivo es reducir el acoplamiento con el modelo de dominio y exponer solo la informaci√≥n necesaria.

### üì¶ `ProductDTO`

Este `DTO` representa una versi√≥n simplificada e inmutable del modelo `Product`. Se utiliza para transferir informaci√≥n
de los productos hacia las respuestas API, ocultando detalles internos como el campo `available`.

````java
public record ProductDTO(Long id,
                         String name,
                         String category,
                         BigDecimal price,
                         Double rating,
                         String brand) {
}
````

### üì¶ `ApiResponse<T>`

Esta clase gen√©rica act√∫a como envoltorio estandarizado para las respuestas de la API. Proporciona una estructura
uniforme que incluye informaci√≥n sobre el estado de la operaci√≥n, el tiempo de ejecuci√≥n, y si los datos provinieron
de cach√©.

Adem√°s, este record define el m√©todo `create(...)` como un m√©todo de f√°brica que simplifica la creaci√≥n de instancias
de `ApiResponse`, agregando autom√°ticamente la marca de tiempo actual.

````java
public record ApiResponse<T>(boolean success,
                             String message,
                             T data,
                             boolean cacheHit,
                             long executionTimeMs,
                             LocalDateTime timestamp) {

    public static <T> ApiResponse<T> create(boolean success, String message, T data, boolean cacheHit, long executionTimeMs) {
        return new ApiResponse<>(success, message, data, cacheHit, executionTimeMs, LocalDateTime.now());
    }
}
````

### üíæ Cache Entry

La clase `CacheEntry<T>` representa una unidad de almacenamiento en cach√© que contiene tanto los datos almacenados
como la informaci√≥n de control de tiempo de vida (`TTL ‚Äî Time To Live`).

Es utilizada por el `Proxy` para implementar la estrategia `Cache-Aside`, gestionando la expiraci√≥n y validez de los
datos almacenados temporalmente.

````java
public class CacheEntry<T> {
    @Getter
    private final T data;
    @Getter
    private final LocalDateTime timestamp;
    private final int ttlMinutes;

    public CacheEntry(T data, int ttlMinutes) {
        this.timestamp = LocalDateTime.now();
        this.data = data;
        this.ttlMinutes = ttlMinutes;
    }

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(this.timestamp.plusMinutes(this.ttlMinutes));
    }
}
````

### ‚ö° Cache Result

La clase `CacheResult<T>` es un record inmutable que encapsula el resultado de una operaci√≥n que puede provenir del
cach√© o del servicio real. Se utiliza dentro del `Proxy` para transportar tanto los datos obtenidos como la
informaci√≥n de diagn√≥stico relacionada con la ejecuci√≥n, como el tiempo de respuesta y si la operaci√≥n fue un
`cache hit` o un `cache miss`.

````java
public record CacheResult<T>(T data,
                             boolean cacheHit,
                             long executionTimeMs) {
}
````

### üß© Mock Data

La clase `MockProductDatabase` act√∫a como una fuente de datos simulada que representa una base de datos relacional.
Su prop√≥sito es proveer informaci√≥n est√°tica que ser√° utilizada por el `RealSubject (ProductServiceImpl)` al ejecutar
consultas ‚Äúcostosas‚Äù, permitiendo enfocar el ejemplo en el mecanismo del `Proxy` y la `cach√©`, sin depender de ninguna
base de datos real ni frameworks adicionales.

````java

@UtilityClass
public class MockProductDatabase {
    public static List<Product> initializeDatabase() {
        List<Product> products = new ArrayList<>();

        // Electronics
        products.add(new Product(1L, "iPhone 15", "Electronics", new BigDecimal("1200.00"), 4.5, "Apple", true));
        products.add(new Product(2L, "Samsung Galaxy S24", "Electronics", new BigDecimal("1100.00"), 4.3, "Samsung", true));
        products.add(new Product(3L, "MacBook Pro", "Electronics", new BigDecimal("2500.00"), 4.7, "Apple", true));
        products.add(new Product(4L, "Dell XPS 13", "Electronics", new BigDecimal("1800.00"), 4.4, "Dell", true));
        products.add(new Product(5L, "AirPods Pro", "Electronics", new BigDecimal("250.00"), 4.6, "Apple", true));

        // Clothing
        products.add(new Product(6L, "Nike T-Shirt", "Clothing", new BigDecimal("45.00"), 4.2, "Nike", true));
        products.add(new Product(7L, "Levi's Jeans", "Clothing", new BigDecimal("80.00"), 4.4, "Levi's", true));
        products.add(new Product(8L, "Adidas Sneakers", "Clothing", new BigDecimal("120.00"), 4.3, "Adidas", true));
        products.add(new Product(9L, "North Face Jacket", "Clothing", new BigDecimal("200.00"), 4.5, "North Face", true));
        products.add(new Product(10L, "Casio Watch", "Clothing", new BigDecimal("150.00"), 4.1, "Casio", true));

        // Home
        products.add(new Product(11L, "Dyson Vacuum", "Home", new BigDecimal("400.00"), 4.6, "Dyson", true));
        products.add(new Product(12L, "Nespresso Coffee Machine", "Home", new BigDecimal("180.00"), 4.4, "Nespresso", true));
        products.add(new Product(13L, "Ergonomic Chair", "Home", new BigDecimal("300.00"), 4.2, "Herman Miller", true));
        products.add(new Product(14L, "Dining Table", "Home", new BigDecimal("500.00"), 4.3, "IKEA", true));
        products.add(new Product(15L, "LED Lamp", "Home", new BigDecimal("75.00"), 4.0, "Philips", true));

        return products;
    }
}
````

### üß© Subject ‚Äî ProductService

La interfaz `ProductService` representa el `Subject` dentro del `Patr√≥n Proxy`.
Define las operaciones que pueden ser ejecutadas sobre productos, sin exponer detalles de implementaci√≥n o
almacenamiento.

Tanto el objeto real (`ProductServiceImpl`) como el proxy (`ProductServiceCacheProxy`) implementan esta interfaz,
garantizando intercambiabilidad y bajo acoplamiento.

````java
public interface ProductService {
    CacheResult<List<Product>> findByCategory(String category, int page);

    CacheResult<List<Product>> getRelatedProducts(Long productId);

    CacheResult<List<Product>> searchWithFilters(String category, BigDecimal minPrice, BigDecimal maxPrice);
}
````

Esta interfaz cumple el rol de punto de entrada com√∫n para los consumidores del servicio.
Al interactuar con el `ProductService`, la aplicaci√≥n no necesita saber si la l√≥gica est√° siendo ejecutada:

- directamente por el objeto real (`ProductServiceImpl`), o
- interceptada por el proxy (`ProductServiceCacheProxy`) que aplica la l√≥gica de caching.

De esta forma, se logra el `principio de sustituci√≥n de Liskov (LSP)` y se
`desacopla la l√≥gica de negocio del mecanismo de optimizaci√≥n` (la cach√©).

### ‚öôÔ∏è Real Subject ‚Äî ProductServiceImpl

La clase `ProductServiceImpl` implementa la interfaz `ProductService` y representa el objeto real (üß± `Real Subject`)
dentro del `Patr√≥n Proxy`. Contiene la l√≥gica de negocio ‚Äúpesada‚Äù que simula operaciones costosas
‚Äîcomo consultas a base de datos, c√°lculos o peticiones externas‚Äî. El `Proxy` m√°s adelante interceptar√° las llamadas
a esta clase para decidir cu√°ndo reutilizar los resultados desde cach√©.

Esta clase act√∫a como el componente que realiza el trabajo pesado. El `Proxy` intervendr√° antes o despu√©s de su
ejecuci√≥n para:

- verificar si la informaci√≥n ya est√° disponible en cach√©,
- o en caso contrario, delegar la ejecuci√≥n a este servicio real y luego almacenar el resultado.

De esta manera:

- el `ProductServiceImpl` no tiene conocimiento del cach√©,
- y el `Proxy` no necesita conocer la l√≥gica de negocio interna.

Se logra una separaci√≥n clara de responsabilidades (principio `Single Responsibility` y `Open/Closed` de SOLID).

````java

@Slf4j
@Service
public class ProductServiceImpl implements ProductService {

    private final List<Product> database = MockProductDatabase.initializeDatabase();

    @Override
    public CacheResult<List<Product>> findByCategory(String category, int page) {
        log.info("Ejecutando consulta cara por categor√≠a...");
        long startTime = System.currentTimeMillis();

        this.simulateExpensiveQuery();

        int pageSize = 5;
        int sartIndex = (page - 1) * pageSize;

        List<Product> data = database.stream()
                .filter(product -> product.getCategory().equalsIgnoreCase(category) && product.isAvailable())
                .skip(sartIndex)
                .limit(pageSize)
                .toList();

        long executionTime = System.currentTimeMillis() - startTime;
        return new CacheResult<>(data, false, executionTime);
    }

    @Override
    public CacheResult<List<Product>> getRelatedProducts(Long productId) {
        log.info("Ejecutando consulta cara para productos relacionados...");
        long startTime = System.currentTimeMillis();

        this.simulateExpensiveQuery();

        Optional<Product> optionalProduct = this.findProductById(productId);
        List<Product> data = optionalProduct
                .map(p -> this.database.stream()
                        .filter(product -> !product.getId().equals(productId))
                        .filter(product -> product.getCategory().equals(p.getCategory()))
                        .filter(product -> Math.abs(product.getPrice().doubleValue() - p.getPrice().doubleValue()) <= 100)
                        .limit(3)
                        .toList())
                .orElseGet(List::of);

        long executionTime = System.currentTimeMillis() - startTime;
        return new CacheResult<>(data, false, executionTime);
    }

    @Override
    public CacheResult<List<Product>> searchWithFilters(String category, BigDecimal minPrice, BigDecimal maxPrice) {
        log.info("Ejecutando consulta cara con m√∫ltiples filtros...");
        long startTime = System.currentTimeMillis();

        this.simulateExpensiveQuery();

        List<Product> data = this.database.stream()
                .filter(product -> product.getCategory().equalsIgnoreCase(category))
                .filter(product -> product.getPrice().compareTo(minPrice) >= 0)
                .filter(product -> product.getPrice().compareTo(maxPrice) <= 0)
                .filter(Product::isAvailable)
                .toList();

        long executionTime = System.currentTimeMillis() - startTime;
        return new CacheResult<>(data, false, executionTime);
    }

    private Optional<Product> findProductById(Long productId) {
        return this.database.stream()
                .filter(product -> product.getId().equals(productId))
                .findFirst();
    }

    private void simulateExpensiveQuery() {
        try {
            Thread.sleep(2500);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
````

### üß± Proxy ‚Äî ProductServiceCacheProxy

Esta clase implementa el `Patr√≥n Proxy` sobre la interfaz `ProductService`. Su funci√≥n principal es interceptar las
llamadas al servicio real (`ProductServiceImpl`) y decidir si retornar los datos desde cach√© o consultar el servicio
real.

Con esto, se implementa el patr√≥n `Cache-Aside` en un contexto `Spring Boot`, de forma transparente y no intrusiva.

üí° Detalles T√©cnicos

- `@Qualifier("productServiceImpl")`:
    - Es esencial para que Spring sepa inyectar el servicio real (y no el proxy mismo).
    - Evita un ciclo de dependencias.
- `Supplier<CacheResult<List<Product>>>`:
    - Permite pasar una referencia diferida a la operaci√≥n real (lambda) sin ejecutarla hasta que sea necesario.
- `generateKey(...)`:
    - Crea claves √∫nicas para cada combinaci√≥n de par√°metros, garantizando que el cach√© sea espec√≠fico por tipo de
      consulta.

````java

@Slf4j
@Service
public class ProductServiceCacheProxy implements ProductService {

    private final ProductService realService;
    private final ConcurrentHashMap<String, CacheEntry<List<Product>>> cache;
    private final int ttlMinutes;

    public ProductServiceCacheProxy(@Qualifier("productServiceImpl") ProductService realService) {
        this.realService = realService;
        this.cache = new ConcurrentHashMap<>();
        this.ttlMinutes = 2;
    }

    @Override
    public CacheResult<List<Product>> findByCategory(String category, int page) {
        String cacheKey = this.generateKey("category", category, "page", String.valueOf(page));
        return this.executeWithCache(cacheKey, () -> this.realService.findByCategory(category, page));
    }

    @Override
    public CacheResult<List<Product>> getRelatedProducts(Long productId) {
        String cacheKey = this.generateKey("related", String.valueOf(productId));
        return this.executeWithCache(cacheKey, () -> this.realService.getRelatedProducts(productId));
    }

    @Override
    public CacheResult<List<Product>> searchWithFilters(String category, BigDecimal minPrice, BigDecimal maxPrice) {
        String cacheKey = this.generateKey("filters", category, minPrice.toString(), maxPrice.toString());
        return this.executeWithCache(cacheKey, () -> this.realService.searchWithFilters(category, minPrice, maxPrice));
    }

    // ===============================================
    // CACHE-ASIDE IMPLEMENTATION
    // ===============================================
    private CacheResult<List<Product>> executeWithCache(String cacheKey, Supplier<CacheResult<List<Product>>> operation) {
        long startTime = System.currentTimeMillis();

        //1. Verificar si existe en cach√© y no ha expirado
        CacheEntry<List<Product>> entry = this.cache.get(cacheKey);
        if (entry != null && !entry.isExpired()) {
            long duration = System.currentTimeMillis() - startTime;
            log.info("Cache HIT. Datos recuperados desde cach√© en {} ms", duration);
            return new CacheResult<>(entry.getData(), true, duration);
        }

        //2. Si no existe o ha expirado, llamamos al servicio real
        log.info("Cache MISS. Consultando el servicio real");
        CacheResult<List<Product>> result = operation.get();

        //3. Guardando el resultado en cach√©
        this.cache.put(cacheKey, new CacheEntry<>(result.data(), this.ttlMinutes));
        log.info("Resultado guardado en cach√©");

        return result;
    }

    private String generateKey(String... parts) {
        return String.join(":", parts);
    }
}
````

### üåê Controller ‚Äî ProductController

Esta clase expone endpoints REST que permiten consultar productos aplicando el `patr√≥n Proxy con cach√©`.
El controlador no conoce si los datos provienen del servicio real (`ProductServiceImpl`) o del Proxy con cach√©
(`ProductServiceCacheProxy`) ‚Äî esto ocurre de manera transparente gracias a la inyecci√≥n de dependencias de Spring.

````java

@Slf4j
@RestController
@RequestMapping(path = "/api/v1/products/cache")
public class ProductController {

    private final ProductService productService;


    public ProductController(@Qualifier("productServiceCacheProxy") ProductService productService) {
        this.productService = productService;
    }

    @GetMapping(path = "/category/{category}")
    public ResponseEntity<ApiResponse<List<ProductDTO>>> findByCategory(@PathVariable String category) {
        return this.response(this.productService.findByCategory(category, 1));
    }

    @GetMapping(path = "/related/{productId}")
    public ResponseEntity<ApiResponse<List<ProductDTO>>> getRelatedProducts(@PathVariable Long productId) {
        return this.response(this.productService.getRelatedProducts(productId));
    }

    @GetMapping(path = "/filter")
    public ResponseEntity<ApiResponse<List<ProductDTO>>> getRelatedProducts(@RequestParam String category,
                                                                            @RequestParam BigDecimal minPrice,
                                                                            @RequestParam BigDecimal maxPrice) {
        return this.response(this.productService.searchWithFilters(category, minPrice, maxPrice));
    }

    private ResponseEntity<ApiResponse<List<ProductDTO>>> response(CacheResult<List<Product>> result) {
        List<ProductDTO> productDTOList = result.data().stream()
                .map(p -> new ProductDTO(p.getId(), p.getName(), p.getCategory(), p.getPrice(), p.getRating(), p.getBrand()))
                .toList();
        var response = ApiResponse.create(true, "Productos recuperados correctamente", productDTOList, result.cacheHit(), result.executionTimeMs());
        return ResponseEntity.ok(response);
    }
}
````

### üì§ Probando aplicaci√≥n

### Primera llamada (Cache MISS)

````bash
$ curl -v http://localhost:8080/api/v1/products/cache/category/Electronics | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:14:13 GMT
<
--:--:-- 0:00:02 --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "category": "Electronics",
      "price": 1200.00,
      "rating": 4.5,
      "brand": "Apple"
    },
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    },
    {
      "id": 3,
      "name": "MacBook Pro",
      "category": "Electronics",
      "price": 2500.00,
      "rating": 4.7,
      "brand": "Apple"
    },
    {
      "id": 4,
      "name": "Dell XPS 13",
      "category": "Electronics",
      "price": 1800.00,
      "rating": 4.4,
      "brand": "Dell"
    },
    {
      "id": 5,
      "name": "AirPods Pro",
      "category": "Electronics",
      "price": 250.00,
      "rating": 4.6,
      "brand": "Apple"
    }
  ],
  "cacheHit": false,
  "executionTimeMs": 2512,
  "timestamp": "2025-10-05T19:14:13.6716223"
}
````

````bash
...ProductServiceCacheProxy : Cache MISS. Consultando el servicio real
...ProductServiceImpl       : Ejecutando consulta cara por categor√≠a...
...ProductServiceCacheProxy : Resultado guardado en cach√© 
````

### Segunda llamada inmediata (Cache HIT)

````bash
$ curl -v http://localhost:8080/api/v1/products/cache/category/Electronics | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:15:40 GMT
<
--:--:-- --:--:-- --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "category": "Electronics",
      "price": 1200.00,
      "rating": 4.5,
      "brand": "Apple"
    },
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    },
    {
      "id": 3,
      "name": "MacBook Pro",
      "category": "Electronics",
      "price": 2500.00,
      "rating": 4.7,
      "brand": "Apple"
    },
    {
      "id": 4,
      "name": "Dell XPS 13",
      "category": "Electronics",
      "price": 1800.00,
      "rating": 4.4,
      "brand": "Dell"
    },
    {
      "id": 5,
      "name": "AirPods Pro",
      "category": "Electronics",
      "price": 250.00,
      "rating": 4.6,
      "brand": "Apple"
    }
  ],
  "cacheHit": true,
  "executionTimeMs": 0,
  "timestamp": "2025-10-05T19:15:40.9170728"
}
````

````bash
...ProductServiceCacheProxy : Cache HIT. Datos recuperados desde cach√© en 0 ms
````

### Primera llamada (Cache MISS)

````bash
$ curl -v -G --data "category=Electronics&minPrice=100&maxPrice=1500" http://localhost:8080/api/v1/products/cache/filter | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:17:06 GMT
<
--:--:--  0:00:02 --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "category": "Electronics",
      "price": 1200.00,
      "rating": 4.5,
      "brand": "Apple"
    },
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    },
    {
      "id": 5,
      "name": "AirPods Pro",
      "category": "Electronics",
      "price": 250.00,
      "rating": 4.6,
      "brand": "Apple"
    }
  ],
  "cacheHit": false,
  "executionTimeMs": 2511,
  "timestamp": "2025-10-05T19:17:06.9870158"
}
````

````bash
...ProductServiceCacheProxy : Cache MISS. Consultando el servicio real
...ProductServiceImpl       : Ejecutando consulta cara con m√∫ltiples filtros...
...ProductServiceCacheProxy : Resultado guardado en cach√© 
````

### Segunda llamada inmediata (Cache HIT)

````bash
$ curl -v -G --data "category=Electronics&minPrice=100&maxPrice=1500" http://localhost:8080/api/v1/products/cache/filter | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:18:11 GMT
<
--:--:-- --:--:-- --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 1,
      "name": "iPhone 15",
      "category": "Electronics",
      "price": 1200.00,
      "rating": 4.5,
      "brand": "Apple"
    },
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    },
    {
      "id": 5,
      "name": "AirPods Pro",
      "category": "Electronics",
      "price": 250.00,
      "rating": 4.6,
      "brand": "Apple"
    }
  ],
  "cacheHit": true,
  "executionTimeMs": 0,
  "timestamp": "2025-10-05T19:18:11.8363459"
} 
````

````bash
...ProductServiceCacheProxy : Cache HIT. Datos recuperados desde cach√© en 0 ms 
````

### Primera llamada (Cache MISS)

````bash
$ curl -v http://localhost:8080/api/v1/products/cache/related/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:19:57 GMT
<
--:--:--  0:00:02 --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    }
  ],
  "cacheHit": false,
  "executionTimeMs": 2513,
  "timestamp": "2025-10-05T19:19:57.3481329"
}
````

````bash
...ProductServiceCacheProxy : Cache MISS. Consultando el servicio real
...ProductServiceImpl       : Ejecutando consulta cara para productos relacionados...
...ProductServiceCacheProxy : Resultado guardado en cach√©
````

### Segunda llamada inmediata (Cache HIT)

````bash
$ curl -v http://localhost:8080/api/v1/products/cache/related/1 | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 06 Oct 2025 00:21:36 GMT
<
--:--:-- --:--:-- --:--:--
{
  "success": true,
  "message": "Productos recuperados correctamente",
  "data": [
    {
      "id": 2,
      "name": "Samsung Galaxy S24",
      "category": "Electronics",
      "price": 1100.00,
      "rating": 4.3,
      "brand": "Samsung"
    }
  ],
  "cacheHit": true,
  "executionTimeMs": 0,
  "timestamp": "2025-10-05T19:21:36.0500225"
}
````

````bash
...ProductServiceCacheProxy : Cache HIT. Datos recuperados desde cach√© en 0 ms
````
