# üß≠ Gu√≠a UML para Patrones de Dise√±o: Flechas y Traducci√≥n a C√≥digo Java

Los diagramas de clases UML son esenciales para visualizar las estructuras y relaciones entre clases en los patrones de
dise√±o. Cada flecha o s√≠mbolo indica un tipo de relaci√≥n sem√°ntica entre elementos, y cada una tiene su equivalente en
c√≥digo Java. A continuaci√≥n, revisamos las m√°s importantes.

**Referencias**

- [**UML Class Diagram Arrows Guide**](https://paulrumyancev.medium.com/uml-class-diagram-arrows-guide-37e4b1bb11e)
- [**UML Cheatsheet | Class Diagram Resource**](https://khalilstemmler.com/articles/uml-cheatsheet/)

---

## üîó Asociaci√≥n

La `asociaci√≥n` en UML representa una relaci√≥n estructural entre dos clases, en la cual `una clase conoce a otra` o
tiene una `referencia a ella`.

Se traduce en el c√≥digo cuando `una clase tiene un campo cuyo tipo es otra clase`.

### üìò Asociaci√≥n Unidireccional

El siguiente diagrama muestra la relaci√≥n de `Asociaci√≥n Unidireccional`, donde `Player` puede llamar a las
propiedades y/o m√©todos de `HealthBar` pero no al rev√©s.

![01.png](assets/01/01.png)

### üíª C√≥digo Java equivalente

````java
public class Player {

    private HealthBar healthBar;  // Asociaci√≥n pura: solo referencia, no propiedad

    public Player(HealthBar healthBar) {
        this.healthBar = healthBar;  // Inyectado desde afuera
    }

    public void onHealthChanged(float health) {
        this.healthBar.setHealth(health);
    }

    public void update() {
        this.healthBar.display();
    }
}
````

````java
public class HealthBar {
    private float health;

    public void setHealth(float health) {
        this.health = health;
    }

    public void display() {
        System.out.println("Health: " + health);
    }
}
````

üß™ Uso externo (clase de prueba)

````java
public class Game {
    public static void main(String[] args) {
        HealthBar healthBar = new HealthBar();       // Se crea fuera de Player
        Player player = new Player(healthBar);       // Se inyecta al constructor

        player.onHealthChanged(85.5f);
        player.update();                             // Imprime: Health: 85.5
    }
}
````

### üìå An√°lisis: ¬øPor qu√© es asociaci√≥n pura?

- `Player` no crea el `HealthBar` ‚Üí lo recibe ya creado.
- `Player` simplemente lo conoce y usa.
- No hay control del ciclo de vida: `HealthBar` puede seguir existiendo despu√©s de eliminar `Player`, o puede ser
  compartido por otro objeto.
- Es una `relaci√≥n d√©bil`, `no de propiedad`.

### üîÑ Asociaci√≥n Bidireccional

Otra variante de esta asociaci√≥n es la `Asociaci√≥n bidireccional`. Una `asociaci√≥n bidireccional` es aquella en la que
dos clases se conocen mutuamente. Cada clase mantiene una `referencia expl√≠cita` a la otra, lo que permite la
`comunicaci√≥n en ambos sentidos`.

UML lo representa con una `l√≠nea continua sin flechas` o con `flechas en ambos extremos` si se quiere destacar la
direccionalidad.

![02.png](assets/01/02.png)

### üíª C√≥digo Java equivalente

Simplemente agregando una referencia en ambas clases:

````java
public class Player {
    private HealthBar healthBar;
}

public class HealthBar {
    private Player player;
}
````

Pero adem√°s de eso, hay que establecer la referencia en ambos lados, lo cual debes manejar cuidadosamente para evitar
inconsistencias:

````java
public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        HealthBar healthBar = new HealthBar();

        player.setHealthBar(healthBar);
        healthBar.setPlayer(player);
    }
}
````

### üìå An√°lisis

- La `asociaci√≥n bidireccional` es v√°lida y √∫til en ciertos contextos, especialmente cuando la l√≥gica del dominio lo
  exige.
- Sin embargo, es mejor evitarla por defecto, a menos que haya una necesidad clara.
- En la mayor√≠a de casos, una `asociaci√≥n unidireccional` bien definida o incluso una `dependencia temporal` (como
  veremos m√°s adelante) ser√° m√°s flexible y mantenible.

### üìù Nota previa sobre Asociaci√≥n, Composici√≥n y Agregaci√≥n

La `asociaci√≥n` es la relaci√≥n m√°s general entre clases: `una clase conoce o utiliza a otra`.

Tanto la `composici√≥n` como la `agregaci√≥n` `son formas especializadas de asociaci√≥n`, con una sem√°ntica m√°s precisa
respecto
al ciclo de vida y el nivel de dependencia entre los objetos involucrados.

- La `agregaci√≥n` indica una relaci√≥n de `tiene un`, pero `sin propiedad fuerte`.
- La `composici√≥n`, en cambio, representa una relaci√≥n de `propiedad total`, donde la clase contenedora posee y gestiona
  completamente a la otra.

Estas variantes `se usan dependiendo del nivel de acoplamiento` que deseas expresar entre tus entidades.
Por tanto, en un diagrama UML, puedes optar por una u otra seg√∫n el detalle y la intenci√≥n sem√°ntica de la relaci√≥n.

