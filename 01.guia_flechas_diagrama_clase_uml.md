# ğŸ§­ GuÃ­a UML para Patrones de DiseÃ±o: Flechas y TraducciÃ³n a CÃ³digo Java

Los diagramas de clases UML son esenciales para visualizar las estructuras y relaciones entre clases en los patrones de
diseÃ±o. Cada flecha o sÃ­mbolo indica un tipo de relaciÃ³n semÃ¡ntica entre elementos, y cada una tiene su equivalente en
cÃ³digo Java. A continuaciÃ³n, revisamos las mÃ¡s importantes.

**Referencias**

- [**UML Class Diagram Arrows Guide**](https://paulrumyancev.medium.com/uml-class-diagram-arrows-guide-37e4b1bb11e)
- [**UML Cheatsheet | Class Diagram Resource**](https://khalilstemmler.com/articles/uml-cheatsheet/)

---

## ğŸ”— AsociaciÃ³n

La `asociaciÃ³n` en UML representa una relaciÃ³n estructural entre dos clases, en la cual `una clase conoce a otra` o
tiene una `referencia a ella`.

Se traduce en el cÃ³digo cuando `una clase tiene un campo cuyo tipo es otra clase`.

### ğŸ“˜ AsociaciÃ³n Unidireccional

El siguiente diagrama muestra la relaciÃ³n de `AsociaciÃ³n Unidireccional`, donde `Player` puede llamar a las
propiedades y/o mÃ©todos de `HealthBar` pero no al revÃ©s.

![01.png](assets/01/01.png)

### ğŸ’» CÃ³digo Java equivalente

````java
public class Player {

    private HealthBar healthBar;  // AsociaciÃ³n pura: solo referencia, no propiedad

    public Player(HealthBar healthBar) {
        this.healthBar = healthBar;  // Inyectado desde afuera
    }

    public void onHealthChanged(float health) {
        this.healthBar.setHealth(health);
    }

    public void update() {
        this.healthBar.display();
    }
}
````

````java
public class HealthBar {
    private float health;

    public void setHealth(float health) {
        this.health = health;
    }

    public void display() {
        System.out.println("Health: " + health);
    }
}
````

ğŸ§ª Uso externo

````java
public class Game {
    public static void main(String[] args) {
        HealthBar healthBar = new HealthBar();       // Se crea fuera de Player
        Player player = new Player(healthBar);       // Se inyecta al constructor

        player.onHealthChanged(85.5f);
        player.update();                             // Imprime: Health: 85.5
    }
}
````

### ğŸ“Œ AnÃ¡lisis: Â¿Por quÃ© es asociaciÃ³n pura?

- `Player` no crea el `HealthBar` â†’ lo recibe ya creado.
- `Player` simplemente lo conoce y usa.
- No hay control del ciclo de vida: `HealthBar` puede seguir existiendo despuÃ©s de eliminar `Player`, o puede ser
  compartido por otro objeto.
- Es una `relaciÃ³n dÃ©bil`, `no de propiedad`.

### ğŸ”„ AsociaciÃ³n Bidireccional

Otra variante de esta asociaciÃ³n es la `AsociaciÃ³n bidireccional`. Una `asociaciÃ³n bidireccional` es aquella en la que
dos clases se conocen mutuamente. Cada clase mantiene una `referencia explÃ­cita` a la otra, lo que permite la
`comunicaciÃ³n en ambos sentidos`.

UML lo representa con una `lÃ­nea continua sin flechas` o con `flechas en ambos extremos` si se quiere destacar la
direccionalidad.

![02.png](assets/01/02.png)

### ğŸ’» CÃ³digo Java equivalente

Simplemente agregando una referencia en ambas clases:

````java
public class Player {
    private HealthBar healthBar;
}

public class HealthBar {
    private Player player;
}
````

Pero ademÃ¡s de eso, hay que establecer la referencia en ambos lados, lo cual debes manejar cuidadosamente para evitar
inconsistencias:

````java
public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        HealthBar healthBar = new HealthBar();

        player.setHealthBar(healthBar);
        healthBar.setPlayer(player);
    }
}
````

### ğŸ“Œ AnÃ¡lisis

- La `asociaciÃ³n bidireccional` es vÃ¡lida y Ãºtil en ciertos contextos, especialmente cuando la lÃ³gica del dominio lo
  exige.
- Sin embargo, es mejor evitarla por defecto, a menos que haya una necesidad clara.
- En la mayorÃ­a de casos, una `asociaciÃ³n unidireccional` bien definida o incluso una `dependencia temporal` (como
  veremos mÃ¡s adelante) serÃ¡ mÃ¡s flexible y mantenible.

### ğŸ“ Nota previa sobre AsociaciÃ³n, ComposiciÃ³n y AgregaciÃ³n

La `asociaciÃ³n` es la relaciÃ³n mÃ¡s general entre clases: `una clase conoce o utiliza a otra`.

Tanto la `composiciÃ³n` como la `agregaciÃ³n` `son formas especializadas de asociaciÃ³n`, con una semÃ¡ntica mÃ¡s precisa
respecto
al ciclo de vida y el nivel de dependencia entre los objetos involucrados.

- La `agregaciÃ³n` indica una relaciÃ³n de `tiene un`, pero `sin propiedad fuerte`.
- La `composiciÃ³n`, en cambio, representa una relaciÃ³n de `propiedad total`, donde la clase contenedora posee y gestiona
  completamente a la otra.

Estas variantes `se usan dependiendo del nivel de acoplamiento` que deseas expresar entre tus entidades.
Por tanto, en un diagrama UML, puedes optar por una u otra segÃºn el detalle y la intenciÃ³n semÃ¡ntica de la relaciÃ³n.

## ğŸ”— AgregaciÃ³n

La `agregaciÃ³n` `es un tipo especializado de asociaciÃ³n` que representa una `relaciÃ³n de contenciÃ³n dÃ©bil`. Indica que
una clase `"tiene"` o `"estÃ¡ compuesta por"` `una o varias instancias` de otra clase,
`pero sin ser dueÃ±a del ciclo de vida` de esas instancias.

### ğŸ“˜ NotaciÃ³n UML

En una relaciÃ³n de agregaciÃ³n, los lados se denominan `todo` (contenedor) y `parte` (contenido).
La `parte` puede existir independientemente del `todo`.

![03.png](assets/01/03.png)

- El `rombo blanco (â—‡)` indica agregaciÃ³n y siempre apunta hacia el `todo`.
- La relaciÃ³n conecta al contenedor (`todo`) con los elementos contenidos (`parte`).
- Se sigue usando una lÃ­nea continua como en la asociaciÃ³n, pero con el rombo en el extremo del contenedor.

### ğŸ§  Â¿CÃ³mo se diferencia de una asociaciÃ³n simple?

- En una asociaciÃ³n simple, una clase solo conoce a otra.
- En una agregaciÃ³n, una clase contiene a otra, pero no la controla totalmente.
- El objeto agregado puede existir independientemente del contenedor.

### ğŸ’» CÃ³digo Java equivalente

````java
import java.util.List;

public class Team {
    private List<Player> players;  // AgregaciÃ³n: Team contiene Player, pero no los crea ni destruye

    public Team(List<Player> players) {
        this.players = players;
    }

    public void printTeam() {
        for (Player p : players) {
            System.out.println(p.getName());
        }
    }
}
````

````java
public class Player {
    private String name;

    public Player(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
````

ğŸ§ª Uso externo

````java
public class Game {
    public static void main(String[] args) {
        Player p1 = new Player("Luis");
        Player p2 = new Player("Ana");

        List<Player> roster = List.of(p1, p2);  // Los jugadores existen antes del equipo

        Team team = new Team(roster);
        team.printTeam();                       // Imprime: Luis, Ana
    }
}
````

### ğŸ“Œ AnÃ¡lisis

- El `Team` tiene a los `Player`, pero no los crea ni destruye.
- Los `Player` pueden existir antes, fuera o incluso despuÃ©s del `Team`.
- La relaciÃ³n entre `Team` y `Player` es de tipo `"tiene un grupo de"`, sin propiedad fuerte.
- Si destruyes el `Team`, los `Player` no se ven afectados.

> â—`Recuerda`: la agregaciÃ³n no depende de cuÃ¡ntos elementos haya, sino del ciclo de vida y la responsabilidad sobre el
> objeto contenido.
>
> Es decir, lo que define una agregaciÃ³n no es si el objeto contenedor tiene uno o varios elementos, sino si las
> "partes" pueden existir de forma independiente del "todo".
>
> La clase que actÃºa como contenedora conoce y utiliza al objeto contenido, pero no lo posee ni controla su existencia.
> En otras palabras, el objeto contenido no muere cuando el contenedor desaparece, y puede ser compartido o utilizado
> por otras clases.
>
> La agregaciÃ³n expresa una relaciÃ³n de tipo â€œtiene unâ€ o â€œestÃ¡ formado porâ€, pero sin implicar propiedad exclusiva ni
> responsabilidad total sobre sus componentes.

---

## ğŸ¯ Diferencia entre AsociaciÃ³n Pura y AgregaciÃ³n: Â¿QuÃ© las distingue realmente?

En Java, tanto una `asociaciÃ³n pura` como una `agregaciÃ³n` pueden representarse de forma muy similar en cÃ³digo:

````java
public class A {
    private B b;

    public A(B b) {
        this.b = b;
    }
}
````

Pero lo que determina si esa relaciÃ³n es una `asociaciÃ³n simple` o una `agregaciÃ³n` no es la forma del cÃ³digo,
sino la intenciÃ³n semÃ¡ntica del modelo de dominio.

### ğŸ“˜ Entonces, Â¿quÃ© las diferencia?

| Criterio                           | AsociaciÃ³n Pura                        | AgregaciÃ³n (â—‡)                   |
|------------------------------------|----------------------------------------|----------------------------------|
| Â¿A conoce a B?                     | âœ… SÃ­                                   | âœ… SÃ­                             |
| Â¿A contiene a B como parte lÃ³gica? | âŒ No                                   | âœ… SÃ­                             |
| Â¿B depende estructuralmente de A?  | âŒ No                                   | âŒ No                             |
| Â¿QuiÃ©n controla el ciclo de vida?  | Externo o neutro                       | Externo o neutro (â‰  composiciÃ³n) |
| Â¿CÃ³digo tÃ­pico en Java?            | Se inyecta la dependencia desde afuera | TambiÃ©n se inyecta desde afuera  |
| Â¿Ejemplo tÃ­pico?                   | `Player` usa `HealthBar`               | `Team` contiene `Player`         |

### ğŸ§  Nota importante

Aunque el cÃ³digo fuente puede ser idÃ©ntico, el tipo de relaciÃ³n UML depende del significado en el dominio.

- Si una clase simplemente usa a otra â†’ asociaciÃ³n pura.
- Si una clase representa una parte estructural del todo â†’ agregaciÃ³n.

Aunque en cÃ³digo Java una `asociaciÃ³n pura` y una `agregaciÃ³n` pueden verse iguales (por ejemplo, al inyectar una clase
por constructor), lo que las diferencia es la intenciÃ³n del modelo: si la clase contenida representa una
`"parte del todo"`, hablamos de `agregaciÃ³n`. Si solo es una `relaciÃ³n de uso o conocimiento`, se trata de
`asociaciÃ³n pura`.

La `composiciÃ³n`, en cambio, `suele implicar que el objeto "parte" se crea y gestiona dentro del contenedor`, por lo
que su representaciÃ³n en cÃ³digo es distinta y `no aplica en este caso comparativo`.

---

## ğŸ”— ComposiciÃ³n

La `composiciÃ³n` es un tipo de `asociaciÃ³n mÃ¡s fuerte` que la agregaciÃ³n. Representa una `relaciÃ³n de propiedad total`,
donde el objeto `"todo"` es el dueÃ±o absoluto del objeto `"parte"`.

- Si el objeto `"todo"` se destruye, la `"parte"` tambiÃ©n desaparece.
- El objeto contenido `no puede existir sin el contenedor`.
- Se considera una `relaciÃ³n de ciclo de vida compartido`.

### ğŸ“˜ NotaciÃ³n UML

![04.png](assets/01/04.png)

- El rombo negro (â—†) indica composiciÃ³n.
- La flecha va del contenedor (`todo`) a la `parte`.
- Se representa con una lÃ­nea continua con el rombo negro en el extremo del contenedor.

### ğŸ’» CÃ³digo Java equivalente

ğŸ§± Parte 1: La clase contenida (Room)

````java
public class Room {
    private String name;

    public Room(String name) {
        this.name = name;
    }

    public void describe() {
        System.out.println("Room: " + name);
    }
}
````

ğŸ  Parte 2: El contenedor (House)

````java
import java.util.ArrayList;
import java.util.List;

public class House {
    private List<Room> rooms = new ArrayList<>(); // ComposiciÃ³n: House crea y gestiona Rooms

    public House() {
        this.rooms.add(new Room("Living Room"));
        this.rooms.add(new Room("Kitchen"));
        this.rooms.add(new Room("Bedroom"));
    }

    public void showRooms() {
        for (Room room : rooms) {
            room.describe();
        }
    }
}
````

ğŸ§ª Uso externo

````java
public class City {
    public static void main(String[] args) {
        House house = new House();
        house.showRooms();
    }
}
````

### âœ… Â¿Por quÃ© es una composiciÃ³n?

- House crea internamente las instancias de Room.
- Los Room no se comparten con otros objetos externos.
- No se pueden reutilizar ni inyectar desde fuera.
- Si se elimina House, sus Room tambiÃ©n desaparecen automÃ¡ticamente.

### ğŸ“Œ Recordatorio importante

- ComposiciÃ³n no depende de listas o cantidades.
- Lo importante es que el objeto contenido:
    - Se crea dentro del contenedor
    - Su ciclo de vida estÃ¡ completamente ligado
    - No se comparte con otros

## ğŸ”— Dependencia

Una `dependencia` representa una relaciÃ³n `temporal` y `dÃ©bil` entre dos clases: una clase usa a otra para realizar
cierta tarea, pero no la posee ni la contiene.

- La clase A `depende` de la clase B si `invoca sus mÃ©todos`, `crea instancias temporales` o la `recibe como parÃ¡metro`.
- La dependencia puede ocurrir en:
    - Un mÃ©todo,
    - Un constructor,
    - O incluso en una sola lÃ­nea de cÃ³digo.

### ğŸ“˜ NotaciÃ³n UML

![05.png](assets/01/05.png)

- Se representa con una lÃ­nea discontinua con una flecha (`- - - - >`)
- Apunta de la clase que usa a la clase que es utilizada.

### ğŸ’» CÃ³digo Java equivalente

````java
public class Customer {
    public void placeOrder() {
        System.out.println("Order placed.");
    }
}
````

````java
public class Order {
    public void processOrder() {
        Customer customer = new Customer(); // â† Dependencia: uso temporal
        customer.placeOrder();
    }
}
````

> ğŸ’¡ `Nota`: Declarar una clase dentro de un mÃ©todo (como `new Customer()` en `processOrder()`) es una forma comÃºn de
> `dependencia local`: la clase que depende la utiliza solo en ese contexto puntual, sin mantener ninguna relaciÃ³n
> duradera.



ğŸ§ª Uso externo

````java
public class Main {
    public static void main(String[] args) {
        Order order = new Order();
        order.processOrder();
    }
}
````

### âœ… Â¿Por quÃ© es una dependencia?

- `Order` no tiene una referencia de clase a `Customer` como atributo.
- `Customer` es usado de manera puntual, solo en el contexto del mÃ©todo `processOrder()`.
- La relaciÃ³n es temporal, dÃ©bil y acotada al contexto de uso.

### ğŸ”„ Otras formas comunes de dependencia

ğŸ“Œ Por parÃ¡metro

````java
public void register(Customer customer) {
    customer.placeOrder();
}
````

ğŸ“Œ Por retorno de mÃ©todo

````java
public Customer getCustomer() {
    return new Customer();
}
````

### ğŸ§  CaracterÃ­sticas clave

| Aspecto               | Dependencia                                               |
|-----------------------|-----------------------------------------------------------|
| Tipo de relaciÃ³n      | â€œUsa-aâ€ (uso temporal, no propiedad)                      |
| Control de ciclo      | âœ… Controla `temporalmente` la instancia durante el mÃ©todo |
| Persistencia          | âŒ No persiste despuÃ©s del mÃ©todo                          |
| RepresentaciÃ³n UML    | LÃ­nea discontinua con flecha `- - - >`                    |
| Frecuencia de uso     | Muy alta (en servicios, controladores, etc.)              |
| Nivel de acoplamiento | Bajo                                                      |

En una relaciÃ³n de dependencia, la clase puede crear y usar una instancia de otra clase, pero
`esa instancia solo vive dentro del alcance del mÃ©todo`. Por eso decimos que hay un
`control temporal del ciclo de vida`, pero `no un control estructural` como ocurre en composiciÃ³n o incluso en
agregaciÃ³n.

### ğŸ”¸ Dependencia hacia mÃ©todos estÃ¡ticos

Una clase tambiÃ©n puede depender de otra **sin crear una instancia**, utilizando sus
**mÃ©todos estÃ¡ticos o constantes**. Este tipo de dependencia sigue considerÃ¡ndose vÃ¡lida en UML, ya que existe un
vÃ­nculo funcional entre ambas clases.

Aunque no se cree un objeto de tipo `B`, la clase `A` sigue dependiendo funcionalmente de `B` para cumplir una tarea.
Esto significa que si por alguna razÃ³n `B` cambia (por ejemplo, cambia la firma del mÃ©todo estÃ¡tico), `A` se ve
afectada.

Y ese es justamente el criterio de UML para decir que hay dependencia:

> ğŸ’¡ "Una clase depende de otra si un cambio en la segunda podrÃ­a afectar a la primera."

````java
public class Validator {
    public static boolean isEmailValid(String email) {
        return email != null && email.contains("@");
    }
}
````

````java
public class UserService {
    public void register(String email) {
        if (!Validator.isEmailValid(email)) {
            throw new IllegalArgumentException("Invalid email");
        }
        // continÃºa...
    }
}
````

- âœ… AquÃ­ `UserService` depende de `Validator`, aunque no cree una instancia.
- Sigue siendo una dependencia (`- - - >`).
- La dependencia no requiere instancia; puede ser:
    - por invocaciÃ³n estÃ¡tica,
    - por uso como `parÃ¡metro` o `retorno`,
    - o por uso local con `new`.

> ğŸ’¡ `Nota`: Incluso si una clase no mantiene una instancia de otra, el simple hecho de usar sus mÃ©todos estÃ¡ticos o
> constantes tambiÃ©n representa una `relaciÃ³n de dependencia`.
>
> Esto se debe a que existe un `acoplamiento funcional`: un cambio en la clase utilizada afectarÃ­a al funcionamiento de
> la clase dependiente.
