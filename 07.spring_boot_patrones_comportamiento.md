# Patrones de comportamiento aplicados en Spring Boot

---

# Strategy

## üéØ Ejemplo 01: Estrategias de pago

En este ejemplo, estamos construyendo un sistema flexible para manejar diferentes m√©todos de pago, utilizando el
`patr√≥n Strategy`. Para ello, definimos una `interfaz com√∫n` para las solicitudes de pago y varios record que
representan las distintas formas de pago. Aqu√≠ analizamos las decisiones clave:

### ‚úÖ Uso de record en lugar de clases tradicionales

Se opt√≥ por utilizar record para definir los objetos de solicitud de pago (`DTOs`). Los record son una caracter√≠stica
introducida en Java 14 (estable en Java 16) que permite crear clases inmutables y concisas, ideales para transportar
datos sin necesidad de escribir constructores, getters o m√©todos como `toString()`, `equals()` o `hashCode()`
manualmente.

Cada forma de pago cuenta con su propio record, el cual encapsula los datos espec√≠ficos que requiere ese m√©todo. Por
ejemplo:

- `PayPalPaymentRequest` incluye email y contrase√±a.
- `BankTransferPaymentRequest` contiene datos bancarios como el titular, nombre del banco y el n√∫mero de cuenta.
- `CreditCardPaymentRequest` define los datos de la tarjeta de cr√©dito como n√∫mero, vencimiento y c√≥digo de seguridad
  (CVV).

````java
public record PayPalPaymentRequest(String orderId,
                                   double amount,
                                   String currency,
                                   String paypalEmail,
                                   String password) implements PaymentRequest {
}
````

````java
public record BankTransferPaymentRequest(String orderId,
                                         double amount,
                                         String currency,
                                         String accountHolder,
                                         String bankName,
                                         String accountNumber) implements PaymentRequest {
}
````

````java
public record CreditCardPaymentRequest(String orderId,
                                       double amount,
                                       String currency,
                                       String cardNumber,
                                       String expiryDate,
                                       String cvv) implements PaymentRequest {

}
````

### üí° Por qu√© se usa una interfaz (PaymentRequest) en lugar de una clase abstracta

Una `limitaci√≥n importante de los record` en Java es que `no pueden extender clases (ni abstractas ni concretas)`.
Todos los record extienden impl√≠citamente `java.lang.Record` como superclase final. Por ello:

> No es posible crear una jerarqu√≠a como `abstract class PaymentRequest { ... }` y que los record la extiendan.

La soluci√≥n correcta en este caso es definir una `interfaz`, como `PaymentRequest`, que los record s√≠ pueden
implementar. Esto permite que todas las solicitudes de pago compartan una estructura com√∫n (como `orderId`, `amount` y
`currency`), y puedan ser tratadas de forma polim√≥rfica. Por ejemplo:

````java
void processPayment(PaymentRequest request);
````

Esto facilita la implementaci√≥n del `patr√≥n Strategy` m√°s adelante, ya que cada estrategia puede operar sobre su tipo
espec√≠fico, pero tambi√©n podemos validar o enrutar por la interfaz base.

### üì¶ Detalle de la interfaz PaymentRequest

Esta interfaz define tres m√©todos comunes a todas las solicitudes de pago:

````java
public interface PaymentRequest {
    String orderId();

    double amount();

    String currency();
}
````

Al ser implementada por cada record, garantiza que todas las solicitudes posean esos campos fundamentales.

### üì§ PaymentResponse

Finalmente, tambi√©n definimos un record llamado `PaymentResponse`, que encapsula la respuesta com√∫n que devuelve
cualquier estrategia de pago:

- `success`: indica si el pago fue exitoso.
- `transactionId`: un identificador √∫nico de la transacci√≥n.
- `message`: mensaje opcional para retroalimentaci√≥n.

Este DTO tambi√©n sigue el mismo enfoque inmutable, claro y orientado a datos.

````java
public record PaymentResponse(boolean success,
                              String transactionId,
                              String message) {
}
````

### Interfaz gen√©rica `PaymentStrategy<T extends PaymentRequest>`

Esta interfaz define el contrato que toda estrategia de pago debe cumplir. Es decir, cualquier clase que implemente
esta interfaz deber√° proporcionar l√≥gica para:

- Validar los datos de la solicitud de pago.
- Ejecutar el proceso de pago y devolver una respuesta.

````java
public interface PaymentStrategy<T extends PaymentRequest> {
    boolean validatePayment(T request);

    PaymentResponse pay(T request);
}
````

### üéØ Uso de gen√©ricos: `<T extends PaymentRequest>`

El uso de `generics` en esta interfaz permite que cada implementaci√≥n est√© especializada en un tipo espec√≠fico de
solicitud de pago (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).

Veamos qu√© significa esta parte:

````bash
<T extends PaymentRequest>
````

- `T` es un `par√°metro de tipo` que puede variar seg√∫n la implementaci√≥n concreta.
- `extends PaymentRequest` indica que `T` `debe ser una subclase o implementaci√≥n de PaymentRequest` (en este caso, un
  record que implementa la interfaz).
- Esto garantiza que cualquier objeto `T` usado como par√°metro tenga al menos los m√©todos definidos en `PaymentRequest`
  (`orderId()`, `amount()`, `currency()`).

### ‚úÖ Ventajas de usar generics aqu√≠

1. `Seguridad de tipo en tiempo de compilaci√≥n`. Cada estrategia concreta puede trabajar con su tipo espec√≠fico sin
   necesidad de hacer casting:
    ````java
    public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest>{/*code*/}
    ````
2. `Mayor claridad y cohesi√≥n`. La estrategia queda claramente ligada a su tipo de request. Esto facilita el
   mantenimiento y evita errores al procesar datos que no corresponden.
3. `Reutilizaci√≥n y escalabilidad`. Puedes crear f√°cilmente nuevas estrategias para otros m√©todos de pago
   (e.g.,`CryptoPaymentRequest`) sin modificar la interfaz base.

### üß© Relaci√≥n con los record y el patr√≥n Strategy

Como vimos antes, los distintos record (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.) implementan la
interfaz `PaymentRequest`. Gracias a eso, se pueden usar como tipo `T` en esta interfaz gen√©rica.

Esto forma la base del `patr√≥n Strategy`, ya que cada implementaci√≥n concreta de `PaymentStrategy<T>` define c√≥mo
manejar su tipo de pago particular, respetando la misma estructura com√∫n (validar y pagar).

### Estrategias concretas de pago

Cada una de las clases que veremos a continuaci√≥n representa una estrategia concreta dentro del patr√≥n Strategy. Todas
implementan la interfaz gen√©rica PaymentStrategy<T>, que exige dos m√©todos:

- `validatePayment(T request)`: realiza validaciones sobre la solicitud de pago.
- `pay(T request)`: ejecuta la l√≥gica de pago y devuelve un PaymentResponse.

Estas clases se anotan con @Component para que Spring las detecte y gestione como beans, y adem√°s con @Slf4j para
permitir el uso de logging con log.info(), log.error(), etc.

Veamos cada implementaci√≥n.

### üìå PayPalPaymentStrategy

````java

@Slf4j
@Component("payPal")
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {
    @Override
    public boolean validatePayment(PayPalPaymentRequest request) {
        if (Objects.isNull(request.paypalEmail()) || !request.paypalEmail().contains("@")) {
            log.error("Email de PayPal inv√°lido");
            return false;
        }

        if (Objects.isNull(request.password()) || request.password().length() < 6) {
            log.error("Contrase√±a debe tener al menos 6 caracteres");
            return false;
        }

        log.info("Datos de la cuenta de PayPal validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(PayPalPaymentRequest request) {
        log.info("Procesando pago S/{} con PayPal para el usuario {}", request.amount(), request.paypalEmail());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "PP-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con PayPal");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con PayPal");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia concreta se encarga de procesar pagos mediante cuentas PayPal.

- Validaci√≥n:
    - Verifica que el email tenga formato v√°lido (contenga @).
    - La contrase√±a debe tener al menos 6 caracteres.

- Proceso de pago:
    - Simula una espera (Thread.sleep) para representar el tiempo de procesamiento.
    - Genera un transactionId con prefijo PP-.
    - Retorna un PaymentResponse exitoso.

> üìå `Nota t√©cnica`: El identificador del bean en el contenedor de Spring es `"payPal`", ya que as√≠ se defini√≥
> expl√≠citamente con `@Component("payPal")`. Esto ser√° importante al momento de recuperar din√°micamente las estrategias.

### üìå BankTransferPaymentStrategy

````java

@Slf4j
@Component("bankTransfer")
public class BankTransferPaymentStrategy implements PaymentStrategy<BankTransferPaymentRequest> {

    @Override
    public boolean validatePayment(BankTransferPaymentRequest request) {
        if (Objects.isNull(request.accountHolder()) || request.accountHolder().isBlank()) {
            log.error("Titular de la cuenta es requerido");
            return false;
        }

        if (Objects.isNull(request.bankName()) || request.bankName().isBlank()) {
            log.error("El nombre del banco es requerido");
            return false;
        }

        if (Objects.isNull(request.accountNumber()) || request.accountNumber().isBlank()) {
            log.error("N√∫mero de cuenta es requerido");
            return false;
        }

        log.info("Datos para la transferencia bancaria validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(BankTransferPaymentRequest request) {
        log.info("Pagando S/{} mediante transferencia bancaria al banco {}", request.amount(), request.bankName());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "BT-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con Transferencia Bancaria");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con Transferencia Bancaria");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia implementa pagos mediante transferencia bancaria.

- Validaci√≥n:
    - Todos los campos relevantes deben estar presentes: titular de cuenta, nombre del banco y n√∫mero de cuenta.

- Proceso de pago:
    - Simula un retardo para reflejar el tiempo de procesamiento.
    - Genera un `transactionId` con prefijo `BT-`.
    - Retorna una respuesta de √©xito.

> üìå `Buenas pr√°cticas`:
> Los campos se validan con `Objects.isNull()` y `isBlank()`, garantizando que no se procesen datos incompletos o
> err√≥neos.

### üìå CreditCardPaymentStrategy

````java

@Slf4j
@Component("creditCard")
public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest> {

    @Override
    public boolean validatePayment(CreditCardPaymentRequest request) {
        if (Objects.isNull(request.cardNumber()) || request.cardNumber().trim().length() < 16) {
            log.error("N√∫mero de tarjeta inv√°lido");
            return false;
        }

        if (Objects.isNull(request.expiryDate()) || request.expiryDate().isBlank()) {
            log.error("Fecha de expiraci√≥n requerida");
            return false;
        }

        if (Objects.isNull(request.cvv()) || request.cvv().trim().length() != 3) {
            log.error("Cvv inv√°lido");
            return false;
        }

        log.info("Datos de la tarjeta cr√©dito validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(CreditCardPaymentRequest request) {
        log.info("Procesando pago S/{} con tarjeta de cr√©dito {}", request.amount(), request.cardNumber());
        try {
            Thread.sleep(Duration.ofSeconds(1));
            String transactionId = "CC-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con tarjeta");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con tarjeta");
            throw new RuntimeException(e);
        }
    }
}
````

Esta clase maneja los pagos con tarjeta de cr√©dito.

- Validaci√≥n:
    - El n√∫mero de tarjeta debe tener al menos 16 caracteres.
    - La fecha de expiraci√≥n no puede estar vac√≠a.
    - El CVV debe tener exactamente 3 d√≠gitos.

- Proceso de pago:
    - Simula la espera con Thread.sleep(1000ms).
    - Genera un identificador con prefijo `CC-`.
    - Retorna un PaymentResponse indicando √©xito.

> üìå `Observaci√≥n`: En un sistema real, estas validaciones ser√≠an mucho m√°s rigurosas e incluir√≠an cifrado, tokens de
> sesi√≥n, y comunicaci√≥n con una pasarela de pagos (como Stripe, PayPal SDK, etc.). Sin embargo, este ejemplo est√°
> dise√±ado con fines pedag√≥gicos.

### üß† Consideraciones sobre el uso de gen√©ricos

Cada clase implementa la interfaz Strategy de forma tipada, como por ejemplo:

````java
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {/*code*/
}
````

Esto tiene dos beneficios importantes:

1. `Tipo seguro en tiempo de compilaci√≥n`: El m√©todo `pay()` s√≥lo aceptar√° objetos del tipo correspondiente
   (`PayPalPaymentRequest`, por ejemplo). No es necesario hacer cast ni validaciones adicionales.
2. `Separaci√≥n clara de responsabilidades`: Cada estrategia solo conoce y manipula su propio tipo de solicitud de pago,
   manteniendo bajo acoplamiento y alta cohesi√≥n.

Este enfoque ser√° especialmente √∫til cuando expliquemos el uso de `Map<String, PaymentStrategy<?>>` en la f√°brica de
estrategias, donde se gestionan de forma din√°mica.

### üè≠ PaymentStrategyFactory: Resolviendo estrategias din√°micamente

La clase `PaymentStrategyFactory` act√∫a como un punto centralizado para obtener la estrategia adecuada seg√∫n el tipo de
pago solicitado. Permite desacoplar la l√≥gica de selecci√≥n de estrategia del resto del sistema, haciendo que el c√≥digo
sea m√°s limpio, extensible y abierto a nuevas formas de pago sin modificar c√≥digo existente.

### üéØ Prop√≥sito

Esta clase permite, por ejemplo, que al recibir el tipo de pago `payPal`, devuelva la instancia correspondiente de
`PayPalPaymentStrategy`, lista para ser usada.

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class PaymentStrategyFactory {

    private final Map<String, PaymentStrategy<? extends PaymentRequest>> paymentStrategies;

    @SuppressWarnings("unchecked")
    public <T extends PaymentRequest> PaymentStrategy<T> getPaymentStrategy(String paymentType) {
        PaymentStrategy<? extends PaymentRequest> strategy = this.paymentStrategies.get(paymentType);
        if (Objects.isNull(strategy)) {
            throw new IllegalArgumentException("Estrategia no soportada: " + paymentType);
        }
        return (PaymentStrategy<T>) strategy;
    }

    public List<String> getSupportedPaymentTypes() {
        return this.paymentStrategies.keySet().stream().sorted().toList();
    }
}
````

### üîÅ Inyecci√≥n de estrategias como `Map<String, PaymentStrategy<? extends PaymentRequest>>`

`Spring Boot` es capaz de inyectar autom√°ticamente todas las implementaciones de
`PaymentStrategy<? extends PaymentRequest>` registradas como `@Component` en el contexto de la aplicaci√≥n,
organiz√°ndolas en un Map, donde:

- `Key`: es el nombre del bean (`payPal`, `creditCard`, etc.), definido con `@Component("nombre")`.
- `Value`: es la instancia concreta de la estrategia (`PaymentStrategy<PayPalPaymentRequest>`, por ejemplo).

Esto evita tener que usar `@Qualifier` uno por uno o manejar condicionales expl√≠citos como `if (...)`.

### üß† ¬øPor qu√© `? extends PaymentRequest`?

El tipo gen√©rico `? extends PaymentRequest` permite que el Map almacene `estrategias con diferentes tipos espec√≠ficos`,
siempre que esos tipos `extiendan` de `PaymentRequest`. As√≠ se garantiza flexibilidad y compatibilidad con las
estrategias concretas definidas anteriormente.

En t√©rminos pr√°cticos, esto permite almacenar en un solo Map:

````bash
PaymentStrategy<PayPalPaymentRequest>,
PaymentStrategy<CreditCardPaymentRequest>,
PaymentStrategy<BankTransferPaymentRequest> 
````

Todos ellos son v√°lidos porque sus `T` cumplen `T extends PaymentRequest`.

### ‚öôÔ∏è M√©todo getPaymentStrategy(...)

Este m√©todo recupera la estrategia deseada a partir del tipo de pago (`paymentType`), realizando un cast controlado al
tipo gen√©rico correcto `(PaymentStrategy<T>)`.

- El cast es seguro en la pr√°ctica porque el dise√±o de la aplicaci√≥n garantiza que el `paymentType` mapea al tipo
  correcto de estrategia.
- La anotaci√≥n `@SuppressWarnings("unchecked")` es necesaria porque el compilador no puede verificar completamente este
  cast en tiempo de compilaci√≥n debido a la borradura de tipos en Java.

Este m√©todo es una `pieza clave para la integraci√≥n polim√≥rfica y flexible del patr√≥n Strategy` en el servicio
principal.

### üìö M√©todo auxiliar: getSupportedPaymentTypes()

Este m√©todo devuelve una lista ordenada de los identificadores de los m√©todos de pago disponibles. Es √∫til para:

- Documentar o mostrar en una UI qu√© opciones de pago est√°n habilitadas.
- Validaciones previas.
- Tests automatizados.

### ‚úÖ Ventajas de este enfoque

- `Abierto a extensi√≥n`: agregar una nueva estrategia s√≥lo requiere crear una clase con `@Component("nuevoTipo")`, sin
  modificar la f√°brica.
- `Elimina condicionales`: se evita el uso de switch, if-else, o inyecciones manuales.
- `Seguridad de tipos con flexibilidad`: el uso de gen√©ricos y `? extends` permite mantener la seguridad de tipo sin
  sacrificar dinamismo.
- `Centraliza el acceso a las estrategias`: si se necesita aplicar reglas o validaciones adicionales, pueden colocarse
  aqu√≠.

### üì• RawPaymentRequest: Entrada gen√©rica desde el cliente

Este record representa la solicitud gen√©rica de pago enviada desde un cliente externo, como por ejemplo una API REST o
una interfaz gr√°fica. Es una estructura flexible y din√°mica, ya que encapsula tanto los datos comunes como los
espec√≠ficos del m√©todo de pago.

````java
public record RawPaymentRequest(@NotBlank(message = "El Id del pedido es obligatorio")
                                String orderId,

                                @NotNull(message = "El monto no puede ser nulo")
                                @Positive(message = "El monto debe ser mayor que cero")
                                Double amount,

                                @NotBlank(message = "La moneda es obligatoria")
                                String currency,

                                @NotBlank(message = "El tipo de pago es obligatorio")
                                String paymentType,

                                @NotNull(message = "Los datos de pago son obligatorios")
                                Map<String, Object> paymentData) {
}
````

üîë Campos

- `orderId`: identificador del pedido.
- `amount`: monto del pago.
- `currency`: moneda (USD, PEN, etc.).
- `paymentType`: tipo de m√©todo de pago (`creditCard`, `payPal`, etc.).
- `paymentData`: mapa de datos espec√≠ficos del m√©todo de pago (por ejemplo, `cardNumber`, `cvv`).

‚úÖ Validaciones

- Se usan anotaciones de `Bean Validation` (JSR-380):
- `@NotBlank`, `@NotNull`, `@Positive`: aseguran que los datos requeridos no est√©n vac√≠os o sean inv√°lidos.
- Estas validaciones se aplican autom√°ticamente al recibir la petici√≥n en un `@RestController` cuando se usa `@Valid`.

üìå Ventaja clave

Al representar los datos como un `Map<String, Object>`, `RawPaymentRequest` permite modelar una estructura flexible y
extensible sin acoplarse desde el inicio a una estrategia concreta. Esto facilita la separaci√≥n entre:

- Lo que env√≠a el cliente.
- Lo que necesita el sistema internamente para procesar el pago.

### üîÑ PaymentRequestConverter: Adaptador din√°mico de datos

Esta clase se encarga de convertir un `RawPaymentRequest` en una instancia concreta de `PaymentRequest`. Esto es un
ejemplo del `patr√≥n Adapter`, donde se traduce una estructura flexible en un tipo fuerte, que el sistema puede procesar
de forma segura.

Se usa un `switch` sobre el campo `paymentType` para determinar qu√© tipo de `PaymentRequest` construir. Esto mantiene
el c√≥digo legible y f√°cilmente ampliable.

> üìå Nota: Este switch est√° encapsulado aqu√≠ a prop√≥sito. Aunque el `patr√≥n Strategy` evita condicionales en la l√≥gica
> de negocio, aqu√≠ es aceptable y necesario porque:
>
> - El sistema necesita saber qu√© tipo de DTO construir antes de aplicar una estrategia.
> - Este es el √∫nico punto donde se reconoce el tipo concreto antes del polimorfismo.

````java

@Slf4j
@Component
public class PaymentRequestConverter {

    public PaymentRequest createPaymentRequest(RawPaymentRequest rawRequest) {
        log.info("Convirtiendo RawPaymentRequest a {}", rawRequest.paymentType());
        return switch (rawRequest.paymentType()) {
            case "bankTransfer" -> this.createBankTransferRequest(rawRequest);
            case "creditCard" -> this.createCreditCardRequest(rawRequest);
            case "payPal" -> this.createPayPalRequest(rawRequest);
            default -> throw new IllegalArgumentException("Tipo de pago no soportado: " + rawRequest.paymentType());
        };
    }

    private CreditCardPaymentRequest createCreditCardRequest(RawPaymentRequest rawRequest) {
        return new CreditCardPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "cardNumber"),
                this.getTypedValue(rawRequest.paymentData(), "expiryDate"),
                this.getTypedValue(rawRequest.paymentData(), "cvv"));
    }

    private PayPalPaymentRequest createPayPalRequest(RawPaymentRequest rawRequest) {
        return new PayPalPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "paypalEmail"),
                this.getTypedValue(rawRequest.paymentData(), "password"));
    }

    private BankTransferPaymentRequest createBankTransferRequest(RawPaymentRequest rawRequest) {
        return new BankTransferPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "accountHolder"),
                this.getTypedValue(rawRequest.paymentData(), "bankName"),
                this.getTypedValue(rawRequest.paymentData(), "accountNumber"));
    }

    private String getTypedValue(Map<String, Object> data, String key) {
        return data != null ? (String) data.get(key) : null;
    }
}
````

### ‚úÖ Ventajas del dise√±o

- `Separaci√≥n de responsabilidades`: esta clase se encarga solo de traducir la entrada, no de procesar pagos.
- `Centralizaci√≥n del mapeo`: evita que la l√≥gica de construcci√≥n de DTOs est√© dispersa en otras partes del sistema.
- `Extensibilidad`: agregar un nuevo m√©todo de pago solo requiere un nuevo case en el switch y un m√©todo de construcci√≥n
  correspondiente.

### üß† PaymentService y PaymentServiceImpl: Cliente del patr√≥n Strategy

En el contexto del `patr√≥n Strategy`, el cliente es quien solicita que se aplique una estrategia en particular, sin
saber c√≥mo funciona internamente. En este dise√±o, `PaymentServiceImpl` cumple ese rol, permitiendo que la l√≥gica de
negocio se mantenga limpia, desacoplada y extensible.

````java
public interface PaymentService {
    PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest);

    List<String> getSupportedPaymentTypes();
}
````

Define las operaciones p√∫blicas que el servicio expone:

- `processPayment(...)`: proceso principal para ejecutar un pago.
- `getSupportedPaymentTypes()`: obtiene todos los tipos de pago que el sistema soporta, a partir de las estrategias
  registradas.

Esta interfaz permite aplicar el principio de `Inversi√≥n de Dependencias (I de SOLID)`, desacoplando el controller
de la implementaci√≥n concreta (`PaymentServiceImpl`).

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class PaymentServiceImpl implements PaymentService {

    private final PaymentStrategyFactory strategyFactory;
    private final PaymentRequestConverter requestConverter;

    @Override
    public PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest) {
        PaymentRequest paymentRequest = this.requestConverter.createPaymentRequest(rawPaymentRequest);
        return this.applyPaymentStrategy(rawPaymentRequest.paymentType(), paymentRequest);
    }

    @Override
    public List<String> getSupportedPaymentTypes() {
        return this.strategyFactory.getSupportedPaymentTypes();
    }

    private <T extends PaymentRequest> PaymentResponse applyPaymentStrategy(String paymentType, T request) {
        PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType);
        log.info("Estrategia obtenida {}", strategy.getClass().getSimpleName());

        if (!strategy.validatePayment(request)) {
            log.error("Error al validar el pago");
            throw new IllegalArgumentException("No se pudo procesar el pago");
        }

        return strategy.pay(request);
    }
}
````

- El objeto `strategyFactory` se encarga de resolver la estrategia adecuada en base al tipo de pago.
- El objeto `requestConverter` convierte el `RawPaymentRequest` (solicitud gen√©rica del cliente) en una implementaci√≥n
  concreta de `PaymentRequest` (como `PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).
- El m√©todo `applyPaymentStrategy(String paymentType, T request)` es la clave del comportamiento din√°mico del
  `patr√≥n Strategy`. Explicamos por partes:
    - ‚úÖ Uso de `<T extends PaymentRequest>`
        - Permite que este m√©todo funcione con cualquier tipo de solicitud concreta (`T`) que implemente
          `PaymentRequest`.
        - Gracias a esto, se puede trabajar con tipos seguros como` PaymentStrategy<CreditCardPaymentRequest>`, sin
          necesidad de hacer cast expl√≠cito fuera de la f√°brica.
        - En el siguiente c√≥digo `PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType)`
          Se resuelve el bean correspondiente usando la clave `payPal`, `creditCard`, etc.
    - Este m√©todo encapsula la l√≥gica completa de aplicar una estrategia. Adem√°s, mantiene el c√≥digo polim√≥rfico y
      seguro en tiempo de compilaci√≥n.

### ‚úÖ Ventajas de este dise√±o

- `Desacoplamiento total`: el servicio no conoce las clases concretas como `CreditCardPaymentStrategy`. Solo trabaja
  con la interfaz `PaymentStrategy<T>`.
- `Extensibilidad`: agregar un nuevo m√©todo de pago no requiere modificar este servicio.
- `Centralizaci√≥n de la l√≥gica de validaci√≥n y pago`: se maneja todo a trav√©s de la estrategia concreta, permitiendo
  pruebas y mantenimiento m√°s sencillos.

### üåê PaymentController: Punto de entrada REST

Esta clase es un controlador REST que expone la funcionalidad del sistema de pagos al exterior. Utiliza la capa de
servicio (`PaymentService`) para delegar la l√≥gica de negocio, siguiendo el principio de responsabilidad √∫nica
(SRP de SOLID).

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/payments")
public class PaymentController {

    private final PaymentService paymentService;

    @GetMapping(path = "/supported-types")
    public ResponseEntity<List<String>> getSupportedPaymentTypes() {
        return ResponseEntity.ok(this.paymentService.getSupportedPaymentTypes());
    }

    @PostMapping
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody RawPaymentRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(this.paymentService.processPayment(request));
    }
}
````

### üìã GET `/api/v1/payments/supported-types`: Tipos de pago disponibles

Este endpoint expone una lista de los tipos de pago actualmente habilitados en el sistema. Esta informaci√≥n es √∫til
para:

- Interfaces de usuario que deben listar los m√©todos disponibles.
- Validaciones previas en clientes externos.
- Pruebas de integraci√≥n automatizadas.

Se obtiene a trav√©s del m√©todo `getSupportedPaymentTypes()` de `PaymentService`, que a su vez lo delega a la f√°brica de
estrategias.

### üì• POST `/api/v1/payments`: Procesar un pago

Este endpoint permite recibir una solicitud de pago en formato JSON y procesarla utilizando la estrategia adecuada.

- `@RequestBody`: indica que el cuerpo de la solicitud se mapea autom√°ticamente a un objeto Java (`RawPaymentRequest`).
- `@Valid`: activa las validaciones declaradas en los campos del record, como `@NotBlank`, `@Positive`, etc.
- Retorna una respuesta `201 Created` con el cuerpo `PaymentResponse`, que indica el resultado del procesamiento.

### ‚úÖ Buenas pr√°cticas aplicadas

- `Delegaci√≥n total al servicio`: el controlador no contiene l√≥gica de negocio.
- `Validaci√≥n autom√°tica`: se aprovecha Bean Validation con `@Valid` en el DTO de entrada.
- `Uso de ResponseEntity`: permite controlar el c√≥digo HTTP de retorno y el cuerpo de la respuesta.
- `Cohesi√≥n`: todas las operaciones est√°n relacionadas con pagos y agrupadas bajo la misma URL base
  (`/api/v1/payments`).

### Realizando pruebas

Listamos los m√©todos de pago soportados.

````bash
$ curl -v http://localhost:8080/api/v1/payments/supported-types | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Jul 2025 23:37:35 GMT
<
[
  "bankTransfer",
  "creditCard",
  "payPal"
]
````

Realizando pago con tarjeta de cr√©dito.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"creditCard\", \"paymentData\": {\"cardNumber\": \"1234567890123456\", \"expiryDate\": \"12/25\", \"cvv\": \"123\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 04:59:15 GMT
<
{
  "success": true,
  "transactionId": "CC-1752728355233",
  "message": "Pago procesado exitosamente con tarjeta"
}
````

Realizando pago con paypal.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martin@gmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:01:08 GMT
<
{
  "success": true,
  "transactionId": "PP-1752728468436",
  "message": "Pago procesado exitosamente con PayPal"
}
````

Realizando pago con transferencia bancaria.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"bankTransfer\", \"paymentData\": {\"accountHolder\": \"Milagros\", \"bankName\": \"BCP\", \"accountNumber\": \"789-256325632587\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:03:24 GMT
<
{
  "success": true,
  "transactionId": "BT-1752728604942",
  "message": "Pago procesado exitosamente con Transferencia Bancaria"
}
````

Verificando validaci√≥n de campos.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martingmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 500
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:07:49 GMT
< Connection: close
<

{
  "timestamp": "2025-07-17T05:07:49.512+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "No se pudo procesar el pago",
  "path": "/api/v1/payments"
} 
````
````bash
2025-07-17T00:07:49.498-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.c.PaymentRequestConverter  : Convirtiendo RawPaymentRequest a payPal
2025-07-17T00:07:49.500-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Estrategia obtenida PayPalPaymentStrategy
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PayPalPaymentStrategy    : Email de PayPal inv√°lido
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Error al validar el pago
2025-07-17T00:07:49.502-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.IllegalArgumentException: No se pudo procesar el pago] with root cause

java.lang.IllegalArgumentException: No se pudo procesar el pago
````
