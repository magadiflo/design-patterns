# Patrones de comportamiento aplicados en Spring Boot

---

# Strategy

## üéØ Ejemplo 01: Estrategias de pago

En este ejemplo, estamos construyendo un sistema flexible para manejar diferentes m√©todos de pago, utilizando el
`patr√≥n Strategy`. Para ello, definimos una `interfaz com√∫n` para las solicitudes de pago y varios record que
representan las distintas formas de pago. Aqu√≠ analizamos las decisiones clave:

### ‚úÖ Uso de record en lugar de clases tradicionales

Se opt√≥ por utilizar record para definir los objetos de solicitud de pago (`DTOs`). Los record son una caracter√≠stica
introducida en Java 14 (estable en Java 16) que permite crear clases inmutables y concisas, ideales para transportar
datos sin necesidad de escribir constructores, getters o m√©todos como `toString()`, `equals()` o `hashCode()`
manualmente.

Cada forma de pago cuenta con su propio record, el cual encapsula los datos espec√≠ficos que requiere ese m√©todo. Por
ejemplo:

- `PayPalPaymentRequest` incluye email y contrase√±a.
- `BankTransferPaymentRequest` contiene datos bancarios como el titular, nombre del banco y el n√∫mero de cuenta.
- `CreditCardPaymentRequest` define los datos de la tarjeta de cr√©dito como n√∫mero, vencimiento y c√≥digo de seguridad
  (CVV).

````java
public record PayPalPaymentRequest(String orderId,
                                   double amount,
                                   String currency,
                                   String paypalEmail,
                                   String password) implements PaymentRequest {
}
````

````java
public record BankTransferPaymentRequest(String orderId,
                                         double amount,
                                         String currency,
                                         String accountHolder,
                                         String bankName,
                                         String accountNumber) implements PaymentRequest {
}
````

````java
public record CreditCardPaymentRequest(String orderId,
                                       double amount,
                                       String currency,
                                       String cardNumber,
                                       String expiryDate,
                                       String cvv) implements PaymentRequest {

}
````

### üí° Por qu√© se usa una interfaz (PaymentRequest) en lugar de una clase abstracta

Una `limitaci√≥n importante de los record` en Java es que `no pueden extender clases (ni abstractas ni concretas)`.
Todos los record extienden impl√≠citamente `java.lang.Record` como superclase final. Por ello:

> No es posible crear una jerarqu√≠a como `abstract class PaymentRequest { ... }` y que los record la extiendan.

La soluci√≥n correcta en este caso es definir una `interfaz`, como `PaymentRequest`, que los record s√≠ pueden
implementar. Esto permite que todas las solicitudes de pago compartan una estructura com√∫n (como `orderId`, `amount` y
`currency`), y puedan ser tratadas de forma polim√≥rfica. Por ejemplo:

````java
void processPayment(PaymentRequest request);
````

Esto facilita la implementaci√≥n del `patr√≥n Strategy` m√°s adelante, ya que cada estrategia puede operar sobre su tipo
espec√≠fico, pero tambi√©n podemos validar o enrutar por la interfaz base.

### üì¶ Detalle de la interfaz PaymentRequest

Esta interfaz define tres m√©todos comunes a todas las solicitudes de pago:

````java
public interface PaymentRequest {
    String orderId();

    double amount();

    String currency();
}
````

Al ser implementada por cada record, garantiza que todas las solicitudes posean esos campos fundamentales.

### üì§ PaymentResponse

Finalmente, tambi√©n definimos un record llamado `PaymentResponse`, que encapsula la respuesta com√∫n que devuelve
cualquier estrategia de pago:

- `success`: indica si el pago fue exitoso.
- `transactionId`: un identificador √∫nico de la transacci√≥n.
- `message`: mensaje opcional para retroalimentaci√≥n.

Este DTO tambi√©n sigue el mismo enfoque inmutable, claro y orientado a datos.

````java
public record PaymentResponse(boolean success,
                              String transactionId,
                              String message) {
}
````

### Interfaz gen√©rica `PaymentStrategy<T extends PaymentRequest>`

Esta interfaz define el contrato que toda estrategia de pago debe cumplir. Es decir, cualquier clase que implemente
esta interfaz deber√° proporcionar l√≥gica para:

- Validar los datos de la solicitud de pago.
- Ejecutar el proceso de pago y devolver una respuesta.

````java
public interface PaymentStrategy<T extends PaymentRequest> {
    boolean validatePayment(T request);

    PaymentResponse pay(T request);
}
````

### üéØ Uso de gen√©ricos: `<T extends PaymentRequest>`

El uso de `generics` en esta interfaz permite que cada implementaci√≥n est√© especializada en un tipo espec√≠fico de
solicitud de pago (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).

Veamos qu√© significa esta parte:

````bash
<T extends PaymentRequest>
````

- `T` es un `par√°metro de tipo` que puede variar seg√∫n la implementaci√≥n concreta.
- `extends PaymentRequest` indica que `T` `debe ser una subclase o implementaci√≥n de PaymentRequest` (en este caso, un
  record que implementa la interfaz).
- Esto garantiza que cualquier objeto `T` usado como par√°metro tenga al menos los m√©todos definidos en `PaymentRequest`
  (`orderId()`, `amount()`, `currency()`).

### ‚úÖ Ventajas de usar generics aqu√≠

1. `Seguridad de tipo en tiempo de compilaci√≥n`. Cada estrategia concreta puede trabajar con su tipo espec√≠fico sin
   necesidad de hacer casting:
    ````java
    public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest>{/*code*/}
    ````
2. `Mayor claridad y cohesi√≥n`. La estrategia queda claramente ligada a su tipo de request. Esto facilita el
   mantenimiento y evita errores al procesar datos que no corresponden.
3. `Reutilizaci√≥n y escalabilidad`. Puedes crear f√°cilmente nuevas estrategias para otros m√©todos de pago
   (e.g.,`CryptoPaymentRequest`) sin modificar la interfaz base.

### üß© Relaci√≥n con los record y el patr√≥n Strategy

Como vimos antes, los distintos record (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.) implementan la
interfaz `PaymentRequest`. Gracias a eso, se pueden usar como tipo `T` en esta interfaz gen√©rica.

Esto forma la base del `patr√≥n Strategy`, ya que cada implementaci√≥n concreta de `PaymentStrategy<T>` define c√≥mo
manejar su tipo de pago particular, respetando la misma estructura com√∫n (validar y pagar).

### Estrategias concretas de pago

Cada una de las clases que veremos a continuaci√≥n representa una estrategia concreta dentro del patr√≥n Strategy. Todas
implementan la interfaz gen√©rica PaymentStrategy<T>, que exige dos m√©todos:

- `validatePayment(T request)`: realiza validaciones sobre la solicitud de pago.
- `pay(T request)`: ejecuta la l√≥gica de pago y devuelve un PaymentResponse.

Estas clases se anotan con @Component para que Spring las detecte y gestione como beans, y adem√°s con @Slf4j para
permitir el uso de logging con log.info(), log.error(), etc.

Veamos cada implementaci√≥n.

### üìå PayPalPaymentStrategy

````java

@Slf4j
@Component("payPal")
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {
    @Override
    public boolean validatePayment(PayPalPaymentRequest request) {
        if (Objects.isNull(request.paypalEmail()) || !request.paypalEmail().contains("@")) {
            log.error("Email de PayPal inv√°lido");
            return false;
        }

        if (Objects.isNull(request.password()) || request.password().length() < 6) {
            log.error("Contrase√±a debe tener al menos 6 caracteres");
            return false;
        }

        log.info("Datos de la cuenta de PayPal validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(PayPalPaymentRequest request) {
        log.info("Procesando pago S/{} con PayPal para el usuario {}", request.amount(), request.paypalEmail());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "PP-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con PayPal");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con PayPal");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia concreta se encarga de procesar pagos mediante cuentas PayPal.

- Validaci√≥n:
    - Verifica que el email tenga formato v√°lido (contenga @).
    - La contrase√±a debe tener al menos 6 caracteres.

- Proceso de pago:
    - Simula una espera (Thread.sleep) para representar el tiempo de procesamiento.
    - Genera un transactionId con prefijo PP-.
    - Retorna un PaymentResponse exitoso.

> üìå `Nota t√©cnica`: El identificador del bean en el contenedor de Spring es `"payPal`", ya que as√≠ se defini√≥
> expl√≠citamente con `@Component("payPal")`. Esto ser√° importante al momento de recuperar din√°micamente las estrategias.

### üìå BankTransferPaymentStrategy

````java

@Slf4j
@Component("bankTransfer")
public class BankTransferPaymentStrategy implements PaymentStrategy<BankTransferPaymentRequest> {

    @Override
    public boolean validatePayment(BankTransferPaymentRequest request) {
        if (Objects.isNull(request.accountHolder()) || request.accountHolder().isBlank()) {
            log.error("Titular de la cuenta es requerido");
            return false;
        }

        if (Objects.isNull(request.bankName()) || request.bankName().isBlank()) {
            log.error("El nombre del banco es requerido");
            return false;
        }

        if (Objects.isNull(request.accountNumber()) || request.accountNumber().isBlank()) {
            log.error("N√∫mero de cuenta es requerido");
            return false;
        }

        log.info("Datos para la transferencia bancaria validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(BankTransferPaymentRequest request) {
        log.info("Pagando S/{} mediante transferencia bancaria al banco {}", request.amount(), request.bankName());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "BT-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con Transferencia Bancaria");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con Transferencia Bancaria");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia implementa pagos mediante transferencia bancaria.

- Validaci√≥n:
    - Todos los campos relevantes deben estar presentes: titular de cuenta, nombre del banco y n√∫mero de cuenta.

- Proceso de pago:
    - Simula un retardo para reflejar el tiempo de procesamiento.
    - Genera un `transactionId` con prefijo `BT-`.
    - Retorna una respuesta de √©xito.

> üìå `Buenas pr√°cticas`:
> Los campos se validan con `Objects.isNull()` y `isBlank()`, garantizando que no se procesen datos incompletos o
> err√≥neos.

### üìå CreditCardPaymentStrategy

````java

@Slf4j
@Component("creditCard")
public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest> {

    @Override
    public boolean validatePayment(CreditCardPaymentRequest request) {
        if (Objects.isNull(request.cardNumber()) || request.cardNumber().trim().length() < 16) {
            log.error("N√∫mero de tarjeta inv√°lido");
            return false;
        }

        if (Objects.isNull(request.expiryDate()) || request.expiryDate().isBlank()) {
            log.error("Fecha de expiraci√≥n requerida");
            return false;
        }

        if (Objects.isNull(request.cvv()) || request.cvv().trim().length() != 3) {
            log.error("Cvv inv√°lido");
            return false;
        }

        log.info("Datos de la tarjeta cr√©dito validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(CreditCardPaymentRequest request) {
        log.info("Procesando pago S/{} con tarjeta de cr√©dito {}", request.amount(), request.cardNumber());
        try {
            Thread.sleep(Duration.ofSeconds(1));
            String transactionId = "CC-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con tarjeta");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con tarjeta");
            throw new RuntimeException(e);
        }
    }
}
````

Esta clase maneja los pagos con tarjeta de cr√©dito.

- Validaci√≥n:
    - El n√∫mero de tarjeta debe tener al menos 16 caracteres.
    - La fecha de expiraci√≥n no puede estar vac√≠a.
    - El CVV debe tener exactamente 3 d√≠gitos.

- Proceso de pago:
    - Simula la espera con Thread.sleep(1000ms).
    - Genera un identificador con prefijo `CC-`.
    - Retorna un PaymentResponse indicando √©xito.

> üìå `Observaci√≥n`: En un sistema real, estas validaciones ser√≠an mucho m√°s rigurosas e incluir√≠an cifrado, tokens de
> sesi√≥n, y comunicaci√≥n con una pasarela de pagos (como Stripe, PayPal SDK, etc.). Sin embargo, este ejemplo est√°
> dise√±ado con fines pedag√≥gicos.

### üß† Consideraciones sobre el uso de gen√©ricos

Cada clase implementa la interfaz Strategy de forma tipada, como por ejemplo:

````java
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {/*code*/
}
````

Esto tiene dos beneficios importantes:

1. `Tipo seguro en tiempo de compilaci√≥n`: El m√©todo `pay()` s√≥lo aceptar√° objetos del tipo correspondiente
   (`PayPalPaymentRequest`, por ejemplo). No es necesario hacer cast ni validaciones adicionales.
2. `Separaci√≥n clara de responsabilidades`: Cada estrategia solo conoce y manipula su propio tipo de solicitud de pago,
   manteniendo bajo acoplamiento y alta cohesi√≥n.

Este enfoque ser√° especialmente √∫til cuando expliquemos el uso de `Map<String, PaymentStrategy<?>>` en la f√°brica de
estrategias, donde se gestionan de forma din√°mica.

### üè≠ PaymentStrategyFactory: Resolviendo estrategias din√°micamente

La clase `PaymentStrategyFactory` act√∫a como un punto centralizado para obtener la estrategia adecuada seg√∫n el tipo de
pago solicitado. Permite desacoplar la l√≥gica de selecci√≥n de estrategia del resto del sistema, haciendo que el c√≥digo
sea m√°s limpio, extensible y abierto a nuevas formas de pago sin modificar c√≥digo existente.

### üéØ Prop√≥sito

Esta clase permite, por ejemplo, que al recibir el tipo de pago `payPal`, devuelva la instancia correspondiente de
`PayPalPaymentStrategy`, lista para ser usada.

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class PaymentStrategyFactory {

    private final Map<String, PaymentStrategy<? extends PaymentRequest>> paymentStrategies;

    @SuppressWarnings("unchecked")
    public <T extends PaymentRequest> PaymentStrategy<T> getPaymentStrategy(String paymentType) {
        PaymentStrategy<? extends PaymentRequest> strategy = this.paymentStrategies.get(paymentType);
        if (Objects.isNull(strategy)) {
            throw new IllegalArgumentException("Estrategia no soportada: " + paymentType);
        }
        return (PaymentStrategy<T>) strategy;
    }

    public List<String> getSupportedPaymentTypes() {
        return this.paymentStrategies.keySet().stream().sorted().toList();
    }
}
````

### üîÅ Inyecci√≥n de estrategias como `Map<String, PaymentStrategy<? extends PaymentRequest>>`

`Spring Boot` es capaz de inyectar autom√°ticamente todas las implementaciones de
`PaymentStrategy<? extends PaymentRequest>` registradas como `@Component` en el contexto de la aplicaci√≥n,
organiz√°ndolas en un Map, donde:

- `Key`: es el nombre del bean (`payPal`, `creditCard`, etc.), definido con `@Component("nombre")`.
- `Value`: es la instancia concreta de la estrategia (`PaymentStrategy<PayPalPaymentRequest>`, por ejemplo).

Esto evita tener que usar `@Qualifier` uno por uno o manejar condicionales expl√≠citos como `if (...)`.

### üß† ¬øPor qu√© `? extends PaymentRequest`?

El tipo gen√©rico `? extends PaymentRequest` permite que el Map almacene `estrategias con diferentes tipos espec√≠ficos`,
siempre que esos tipos `extiendan` de `PaymentRequest`. As√≠ se garantiza flexibilidad y compatibilidad con las
estrategias concretas definidas anteriormente.

En t√©rminos pr√°cticos, esto permite almacenar en un solo Map:

````bash
PaymentStrategy<PayPalPaymentRequest>,
PaymentStrategy<CreditCardPaymentRequest>,
PaymentStrategy<BankTransferPaymentRequest> 
````

Todos ellos son v√°lidos porque sus `T` cumplen `T extends PaymentRequest`.

### ‚öôÔ∏è M√©todo getPaymentStrategy(...)

Este m√©todo recupera la estrategia deseada a partir del tipo de pago (`paymentType`), realizando un cast controlado al
tipo gen√©rico correcto `(PaymentStrategy<T>)`.

- El cast es seguro en la pr√°ctica porque el dise√±o de la aplicaci√≥n garantiza que el `paymentType` mapea al tipo
  correcto de estrategia.
- La anotaci√≥n `@SuppressWarnings("unchecked")` es necesaria porque el compilador no puede verificar completamente este
  cast en tiempo de compilaci√≥n debido a la borradura de tipos en Java.

Este m√©todo es una `pieza clave para la integraci√≥n polim√≥rfica y flexible del patr√≥n Strategy` en el servicio
principal.

### üìö M√©todo auxiliar: getSupportedPaymentTypes()

Este m√©todo devuelve una lista ordenada de los identificadores de los m√©todos de pago disponibles. Es √∫til para:

- Documentar o mostrar en una UI qu√© opciones de pago est√°n habilitadas.
- Validaciones previas.
- Tests automatizados.

### ‚úÖ Ventajas de este enfoque

- `Abierto a extensi√≥n`: agregar una nueva estrategia s√≥lo requiere crear una clase con `@Component("nuevoTipo")`, sin
  modificar la f√°brica.
- `Elimina condicionales`: se evita el uso de switch, if-else, o inyecciones manuales.
- `Seguridad de tipos con flexibilidad`: el uso de gen√©ricos y `? extends` permite mantener la seguridad de tipo sin
  sacrificar dinamismo.
- `Centraliza el acceso a las estrategias`: si se necesita aplicar reglas o validaciones adicionales, pueden colocarse
  aqu√≠.

### üì• RawPaymentRequest: Entrada gen√©rica desde el cliente

Este record representa la solicitud gen√©rica de pago enviada desde un cliente externo, como por ejemplo una API REST o
una interfaz gr√°fica. Es una estructura flexible y din√°mica, ya que encapsula tanto los datos comunes como los
espec√≠ficos del m√©todo de pago.

````java
public record RawPaymentRequest(@NotBlank(message = "El Id del pedido es obligatorio")
                                String orderId,

                                @NotNull(message = "El monto no puede ser nulo")
                                @Positive(message = "El monto debe ser mayor que cero")
                                Double amount,

                                @NotBlank(message = "La moneda es obligatoria")
                                String currency,

                                @NotBlank(message = "El tipo de pago es obligatorio")
                                String paymentType,

                                @NotNull(message = "Los datos de pago son obligatorios")
                                Map<String, Object> paymentData) {
}
````

üîë Campos

- `orderId`: identificador del pedido.
- `amount`: monto del pago.
- `currency`: moneda (USD, PEN, etc.).
- `paymentType`: tipo de m√©todo de pago (`creditCard`, `payPal`, etc.).
- `paymentData`: mapa de datos espec√≠ficos del m√©todo de pago (por ejemplo, `cardNumber`, `cvv`).

‚úÖ Validaciones

- Se usan anotaciones de `Bean Validation` (JSR-380):
- `@NotBlank`, `@NotNull`, `@Positive`: aseguran que los datos requeridos no est√©n vac√≠os o sean inv√°lidos.
- Estas validaciones se aplican autom√°ticamente al recibir la petici√≥n en un `@RestController` cuando se usa `@Valid`.

üìå Ventaja clave

Al representar los datos como un `Map<String, Object>`, `RawPaymentRequest` permite modelar una estructura flexible y
extensible sin acoplarse desde el inicio a una estrategia concreta. Esto facilita la separaci√≥n entre:

- Lo que env√≠a el cliente.
- Lo que necesita el sistema internamente para procesar el pago.

### üîÑ PaymentRequestConverter: Adaptador din√°mico de datos

Esta clase se encarga de convertir un `RawPaymentRequest` en una instancia concreta de `PaymentRequest`. Esto es un
ejemplo del `patr√≥n Adapter`, donde se traduce una estructura flexible en un tipo fuerte, que el sistema puede procesar
de forma segura.

Se usa un `switch` sobre el campo `paymentType` para determinar qu√© tipo de `PaymentRequest` construir. Esto mantiene
el c√≥digo legible y f√°cilmente ampliable.

> üìå Nota: Este switch est√° encapsulado aqu√≠ a prop√≥sito. Aunque el `patr√≥n Strategy` evita condicionales en la l√≥gica
> de negocio, aqu√≠ es aceptable y necesario porque:
>
> - El sistema necesita saber qu√© tipo de DTO construir antes de aplicar una estrategia.
> - Este es el √∫nico punto donde se reconoce el tipo concreto antes del polimorfismo.

````java

@Slf4j
@Component
public class PaymentRequestConverter {

    public PaymentRequest createPaymentRequest(RawPaymentRequest rawRequest) {
        log.info("Convirtiendo RawPaymentRequest a {}", rawRequest.paymentType());
        return switch (rawRequest.paymentType()) {
            case "bankTransfer" -> this.createBankTransferRequest(rawRequest);
            case "creditCard" -> this.createCreditCardRequest(rawRequest);
            case "payPal" -> this.createPayPalRequest(rawRequest);
            default -> throw new IllegalArgumentException("Tipo de pago no soportado: " + rawRequest.paymentType());
        };
    }

    private CreditCardPaymentRequest createCreditCardRequest(RawPaymentRequest rawRequest) {
        return new CreditCardPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "cardNumber"),
                this.getTypedValue(rawRequest.paymentData(), "expiryDate"),
                this.getTypedValue(rawRequest.paymentData(), "cvv"));
    }

    private PayPalPaymentRequest createPayPalRequest(RawPaymentRequest rawRequest) {
        return new PayPalPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "paypalEmail"),
                this.getTypedValue(rawRequest.paymentData(), "password"));
    }

    private BankTransferPaymentRequest createBankTransferRequest(RawPaymentRequest rawRequest) {
        return new BankTransferPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "accountHolder"),
                this.getTypedValue(rawRequest.paymentData(), "bankName"),
                this.getTypedValue(rawRequest.paymentData(), "accountNumber"));
    }

    private String getTypedValue(Map<String, Object> data, String key) {
        return data != null ? (String) data.get(key) : null;
    }
}
````

### ‚úÖ Ventajas del dise√±o

- `Separaci√≥n de responsabilidades`: esta clase se encarga solo de traducir la entrada, no de procesar pagos.
- `Centralizaci√≥n del mapeo`: evita que la l√≥gica de construcci√≥n de DTOs est√© dispersa en otras partes del sistema.
- `Extensibilidad`: agregar un nuevo m√©todo de pago solo requiere un nuevo case en el switch y un m√©todo de construcci√≥n
  correspondiente.

### üß† PaymentServiceImpl: Cliente y Contexto del patr√≥n Strategy

En el contexto del `patr√≥n Strategy`, normalmente se distingue entre dos roles:

- `Cliente`: decide qu√© estrategia usar seg√∫n cierta l√≥gica externa.
- `Contexto`: mantiene una referencia a la estrategia y se encarga de ejecutarla.

Sin embargo, en esta implementaci√≥n en `Spring Boot`, la clase `PaymentServiceImpl` combina ambos roles de manera
efectiva:

- Como `cliente`, decide qu√© estrategia aplicar, utilizando la clase `PaymentStrategyFactory` para obtener la
  implementaci√≥n adecuada en tiempo de ejecuci√≥n, bas√°ndose en el tipo de pago (`paymentType`).


- Como `contexto`, ejecuta los m√©todos `validatePayment(...)` y `pay(...)` de la estrategia seleccionada, encapsulando
  as√≠ el comportamiento variable.

Esta fusi√≥n de roles es completamente v√°lida y muy com√∫n en aplicaciones modernas. Se evita la creaci√≥n de una clase
adicional como `PaymentContext`, manteniendo el dise√±o m√°s simple, cohesionado y enfocado en la funcionalidad real.

üëâ Esta decisi√≥n de dise√±o respeta el `patr√≥n Strategy` y al mismo tiempo adapta su estructura a un contexto pragm√°tico,
donde el uso de gen√©ricos y la inyecci√≥n de dependencias de Spring permiten implementar el patr√≥n de forma m√°s fluida y
eficiente.

````java
public interface PaymentService {
    PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest);

    List<String> getSupportedPaymentTypes();
}
````

Define las operaciones p√∫blicas que el servicio expone:

- `processPayment(...)`: proceso principal para ejecutar un pago.
- `getSupportedPaymentTypes()`: obtiene todos los tipos de pago que el sistema soporta, a partir de las estrategias
  registradas.

Esta interfaz permite aplicar el principio de `Inversi√≥n de Dependencias (I de SOLID)`, desacoplando el controller
de la implementaci√≥n concreta (`PaymentServiceImpl`).

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class PaymentServiceImpl implements PaymentService {

    private final PaymentStrategyFactory strategyFactory;
    private final PaymentRequestConverter requestConverter;

    @Override
    public PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest) {
        PaymentRequest paymentRequest = this.requestConverter.createPaymentRequest(rawPaymentRequest);
        return this.applyPaymentStrategy(rawPaymentRequest.paymentType(), paymentRequest);
    }

    @Override
    public List<String> getSupportedPaymentTypes() {
        return this.strategyFactory.getSupportedPaymentTypes();
    }

    private <T extends PaymentRequest> PaymentResponse applyPaymentStrategy(String paymentType, T request) {
        PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType);
        log.info("Estrategia obtenida {}", strategy.getClass().getSimpleName());

        if (!strategy.validatePayment(request)) {
            log.error("Error al validar el pago");
            throw new IllegalArgumentException("No se pudo procesar el pago");
        }

        return strategy.pay(request);
    }
}
````

- El objeto `strategyFactory` se encarga de resolver la estrategia adecuada en base al tipo de pago.
- El objeto `requestConverter` convierte el `RawPaymentRequest` (solicitud gen√©rica del cliente) en una implementaci√≥n
  concreta de `PaymentRequest` (como `PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).
- El m√©todo `applyPaymentStrategy(String paymentType, T request)` es la clave del comportamiento din√°mico del
  `patr√≥n Strategy`. Explicamos por partes:
    - ‚úÖ Uso de `<T extends PaymentRequest>`
        - Permite que este m√©todo funcione con cualquier tipo de solicitud concreta (`T`) que implemente
          `PaymentRequest`.
        - Gracias a esto, se puede trabajar con tipos seguros como` PaymentStrategy<CreditCardPaymentRequest>`, sin
          necesidad de hacer cast expl√≠cito fuera de la f√°brica.
        - En el siguiente c√≥digo `PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType)`
          Se resuelve el bean correspondiente usando la clave `payPal`, `creditCard`, etc.
    - Este m√©todo encapsula la l√≥gica completa de aplicar una estrategia. Adem√°s, mantiene el c√≥digo polim√≥rfico y
      seguro en tiempo de compilaci√≥n.

### ‚úÖ Ventajas de este dise√±o

- `Desacoplamiento total`: el servicio no conoce las clases concretas como `CreditCardPaymentStrategy`. Solo trabaja
  con la interfaz `PaymentStrategy<T>`.
- `Extensibilidad`: agregar un nuevo m√©todo de pago no requiere modificar este servicio.
- `Centralizaci√≥n de la l√≥gica de validaci√≥n y pago`: se maneja todo a trav√©s de la estrategia concreta, permitiendo
  pruebas y mantenimiento m√°s sencillos.

### üåê PaymentController: Punto de entrada REST

Esta clase es un controlador REST que expone la funcionalidad del sistema de pagos al exterior. Utiliza la capa de
servicio (`PaymentService`) para delegar la l√≥gica de negocio, siguiendo el principio de responsabilidad √∫nica
(SRP de SOLID).

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/payments")
public class PaymentController {

    private final PaymentService paymentService;

    @GetMapping(path = "/supported-types")
    public ResponseEntity<List<String>> getSupportedPaymentTypes() {
        return ResponseEntity.ok(this.paymentService.getSupportedPaymentTypes());
    }

    @PostMapping
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody RawPaymentRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(this.paymentService.processPayment(request));
    }
}
````

### üìã GET `/api/v1/payments/supported-types`: Tipos de pago disponibles

Este endpoint expone una lista de los tipos de pago actualmente habilitados en el sistema. Esta informaci√≥n es √∫til
para:

- Interfaces de usuario que deben listar los m√©todos disponibles.
- Validaciones previas en clientes externos.
- Pruebas de integraci√≥n automatizadas.

Se obtiene a trav√©s del m√©todo `getSupportedPaymentTypes()` de `PaymentService`, que a su vez lo delega a la f√°brica de
estrategias.

### üì• POST `/api/v1/payments`: Procesar un pago

Este endpoint permite recibir una solicitud de pago en formato JSON y procesarla utilizando la estrategia adecuada.

- `@RequestBody`: indica que el cuerpo de la solicitud se mapea autom√°ticamente a un objeto Java (`RawPaymentRequest`).
- `@Valid`: activa las validaciones declaradas en los campos del record, como `@NotBlank`, `@Positive`, etc.
- Retorna una respuesta `201 Created` con el cuerpo `PaymentResponse`, que indica el resultado del procesamiento.

### ‚úÖ Buenas pr√°cticas aplicadas

- `Delegaci√≥n total al servicio`: el controlador no contiene l√≥gica de negocio.
- `Validaci√≥n autom√°tica`: se aprovecha Bean Validation con `@Valid` en el DTO de entrada.
- `Uso de ResponseEntity`: permite controlar el c√≥digo HTTP de retorno y el cuerpo de la respuesta.
- `Cohesi√≥n`: todas las operaciones est√°n relacionadas con pagos y agrupadas bajo la misma URL base
  (`/api/v1/payments`).

### Realizando pruebas

Listamos los m√©todos de pago soportados.

````bash
$ curl -v http://localhost:8080/api/v1/payments/supported-types | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Jul 2025 23:37:35 GMT
<
[
  "bankTransfer",
  "creditCard",
  "payPal"
]
````

Realizando pago con tarjeta de cr√©dito.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"creditCard\", \"paymentData\": {\"cardNumber\": \"1234567890123456\", \"expiryDate\": \"12/25\", \"cvv\": \"123\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 04:59:15 GMT
<
{
  "success": true,
  "transactionId": "CC-1752728355233",
  "message": "Pago procesado exitosamente con tarjeta"
}
````

Realizando pago con paypal.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martin@gmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:01:08 GMT
<
{
  "success": true,
  "transactionId": "PP-1752728468436",
  "message": "Pago procesado exitosamente con PayPal"
}
````

Realizando pago con transferencia bancaria.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"bankTransfer\", \"paymentData\": {\"accountHolder\": \"Milagros\", \"bankName\": \"BCP\", \"accountNumber\": \"789-256325632587\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:03:24 GMT
<
{
  "success": true,
  "transactionId": "BT-1752728604942",
  "message": "Pago procesado exitosamente con Transferencia Bancaria"
}
````

Verificando validaci√≥n de campos.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martingmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 500
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:07:49 GMT
< Connection: close
<

{
  "timestamp": "2025-07-17T05:07:49.512+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "No se pudo procesar el pago",
  "path": "/api/v1/payments"
} 
````

````bash
2025-07-17T00:07:49.498-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.c.PaymentRequestConverter  : Convirtiendo RawPaymentRequest a payPal
2025-07-17T00:07:49.500-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Estrategia obtenida PayPalPaymentStrategy
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PayPalPaymentStrategy    : Email de PayPal inv√°lido
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Error al validar el pago
2025-07-17T00:07:49.502-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.IllegalArgumentException: No se pudo procesar el pago] with root cause

java.lang.IllegalArgumentException: No se pudo procesar el pago
````

## üéØ Resumen de roles del patr√≥n Strategy en el proyecto: Estrategias de pago

| Rol del patr√≥n        | Clase que lo representa                                           |
|-----------------------|-------------------------------------------------------------------|
| **Strategy**          | `PaymentStrategy<T extends PaymentRequest>`                       |
| **ConcreteStrategy**  | `CreditCardPaymentStrategy`, `PayPalPaymentStrategy`, etc.        |
| **Context**           | `PaymentServiceImpl` (ejecuta la estrategia)                      |
| **Cliente**           | `PaymentServiceImpl` (decide qu√© estrategia usar)                 |
| **Invocador externo** | `PaymentController` (invoca el servicio, sin conocer estrategias) |

### ‚úÖ Observaci√≥n final

`PaymentServiceImpl` cumple con dos responsabilidades del patr√≥n Strategy, de forma intencional y v√°lida:

- `Cliente` ‚Üí decide qu√© estrategia usar (usando `PaymentStrategyFactory`).
- `Contexto` ‚Üí ejecuta la estrategia seleccionada.

Este enfoque es limpio, flexible y fiel al patr√≥n, con una adaptaci√≥n pragm√°tica para aplicaciones modernas usando
`Spring Boot`.

### üß© ¬øC√≥mo ser√≠a un contexto expl√≠cito (PaymentContext)?

Veamos c√≥mo ser√≠a una implementaci√≥n fiel al `patr√≥n Strategy cl√°sico` en `Spring Boot`, incluyendo un `Contexto`
expl√≠cito, es decir, una clase `PaymentContext` que separe claramente los roles de `cliente` y `contexto`.

````java
public class PaymentContext<T extends PaymentRequest> {
    private final PaymentStrategy<T> strategy;

    public PaymentContext(PaymentStrategy<T> strategy) {
        this.strategy = strategy;
    }

    public PaymentResponse execute(T request) {
        if (!strategy.validatePayment(request)) {
            throw new IllegalArgumentException("No se pudo validar el pago");
        }
        return strategy.pay(request);
    }
}
````

Donde la clase `PaymentContext`:

- Mantiene una referencia a una estrategia concreta (`PaymentStrategy<T>`).
- Expone un m√©todo gen√©rico para ejecutar la estrategia (`validatePayment(...)` y `pay(...)`).
- Es utilizada por el `PaymentServiceImpl` (`cliente`), que decide cu√°l estrategia usar y se la pasa al `contexto`.

> üëâ Importante: La clase `PaymentContext` no debe ser `@Component` ni singleton, ya que mantener la estrategia como
> estado interno (por `constructor` o `setter`) puede causar condiciones de carrera en entornos concurrentes.
>
> Si `PaymentContext` es singleton y la estrategia se establece por setter, un hilo podr√≠a cambiar la estrategia
> mientras otro la est√° usando, generando comportamiento incorrecto o inestable.

El servicio `PaymentServiceImpl` como cliente quedar√≠a m√°s o menos as√≠:

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class PaymentServiceImpl implements PaymentService {

    private final PaymentStrategyFactory strategyFactory;

    @Override
    public <T extends PaymentRequest> PaymentResponse processPayment(String paymentType, T request) {
        PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType);

        //La clase PaymentContext no puede ser singleton, y por tanto, no debe tener @Component.
        PaymentContext<T> context = new PaymentContext<>(strategy);
        return context.execute(request);
    }
}
````

### üìå Nota final

> En aplicaciones reales con `Spring Boot`, evitar una clase `PaymentContext` (como contexto) expl√≠cita mejora la
> eficiencia, ya que de otro modo se requerir√≠a crear una nueva instancia por cada solicitud. Adem√°s, delegar la
> ejecuci√≥n directamente al servicio permite mantenerlo como un `@Service singleton` seguro y sin estado mutable.

---

# Template Method

## üéØ Ejemplo 01: T√≠tulo del ejemplo

Tema introductorio de lo que trata este ejemplo

### üì¶ DTOs y estructuras auxiliares del sistema

En este m√≥dulo se definen los objetos de transferencia de datos (DTOs) que encapsulan la informaci√≥n necesaria durante
todo el proceso de carga, validaci√≥n, conversi√≥n y resultado del procesamiento de archivos. Estas estructuras permiten
mantener una separaci√≥n clara entre la l√≥gica del negocio y los datos manejados.

El DTO `ProcessResult` representa el resultado final del procesamiento de un archivo. Encapsula tanto los casos
exitosos como los fallidos e incluye metadatos relevantes.

> üìå `Observaci√≥n`: El uso de `@JsonInclude.NON_NULL` permite omitir campos nulos durante la serializaci√≥n JSON,
> haciendo m√°s clara la respuesta del `API REST`.

````java

@JsonInclude(JsonInclude.Include.NON_NULL)
public record ProcessResult(String batchId,
                            boolean success,
                            String errorMessage,
                            int totalRecords,
                            int processedRecords,
                            int invalidRecords,
                            FileStorageInfo sourceInfo) {

    public static ProcessResult success(String batchId, int total, int processed, int invalid, FileStorageInfo sourceInfo) {
        return new ProcessResult(batchId, true, null, total, processed, invalid, sourceInfo);
    }

    public static ProcessResult failure(String batchId, String errorMessage, FileStorageInfo sourceInfo) {
        return new ProcessResult(batchId, false, errorMessage, 0, 0, 0, sourceInfo);
    }
}
````

El `FileStorageInfo` contiene informaci√≥n sobre la ubicaci√≥n y origen del archivo procesado. Este objeto permite
desacoplar la l√≥gica de procesamiento del mecanismo de carga de archivos.

````java
public record FileStorageInfo(String location,
                              String filename,
                              StorageType storageType) {

    public static FileStorageInfo create(String location, String filename, StorageType storageType) {
        return new FileStorageInfo(location, filename, storageType);
    }
}
````

El `BusinessValidationResult<T extends ParsedRecord>` agrupa los resultados de validaci√≥n a nivel de lote. Es decir,
representa el resultado de la validaci√≥n de todos los registros de un archivo:

````java
public record BusinessValidationResult<T extends ParsedRecord>(List<T> validRecords,
                                                               int invalidCount) {
}
````

El `ValidationResult` representa el resultado de la validaci√≥n individual de un registro.

````java
public record ValidationResult(boolean valid,
                               String errorMessage) {

    public static ValidationResult success() {
        return new ValidationResult(true, null);
    }

    public static ValidationResult failure(String errorMessage) {
        return new ValidationResult(false, errorMessage);
    }
}
````

El `TxtRecord` es una implementaci√≥n concreta de `ParsedRecord` para representar registros provenientes de archivos
`.txt` delimitados.

````java
public record TxtRecord(String id,
                        String accountNumber,
                        double amount,
                        LocalDateTime transactionDate,
                        String description) implements ParsedRecord {
}
````

### Detalle de la interfaz ParsedRecord

Es una `interfaz marcador` (marker interface), sin m√©todos, utilizada para establecer un contrato com√∫n entre todos los
tipos de registros parseados desde archivos.

Su uso permite que el sistema maneje gen√©ricamente registros de distintos formatos (`TxtRecord`, `CsvRecord`, etc.) sin
acoplarse a un tipo concreto.

````java
public interface ParsedRecord {
}
````

üìå En resumen

> Estos DTOs permiten mantener tipado fuerte, flexibilidad y claridad estructural en todo el flujo del patr√≥n
> `Template Method`. Separan claramente los datos, la l√≥gica de validaci√≥n, y el resultado final del procesamiento,
> aline√°ndose con los principios de dise√±o limpio y abierto para extensi√≥n, cerrado para modificaci√≥n (`OCP`).

### ‚öôÔ∏è Clases auxiliares y enums del sistema

Estas clases complementarias proporcionan la infraestructura necesaria para el manejo de excepciones, tipos de archivos
y mecanismos de almacenamiento. Aunque no forman parte directa del patr√≥n `Template Method`, habilitan su
funcionamiento ordenado y extensible.

La clase `FileProcessorException` es una excepci√≥n personalizada utilizada para representar errores internos en el
procesamiento de archivos. Hereda de `RuntimeException`, lo cual la hace `unchecked` (no requiere manejo obligatorio
con `try-catch`).

````java
public class FileProcessorException extends RuntimeException {
    public FileProcessorException(String message) {
        super(message);
    }
}
````

El `StorageType` es un enum que representa los diferentes tipos de almacenamiento de un archivo. Este valor se encapsula
dentro del DTO `FileStorageInfo` para tener trazabilidad del origen del archivo y aplicar l√≥gica especializada si se
necesitara.

````java
public enum StorageType {
    LOCAL,
    S3,
    AZURE_BLOB
}
````

El `FileType` es un enum que modela los tipos de archivo reconocidos por el sistema, junto con sus extensiones y MIME
types asociados.

````java

@Getter
public enum FileType {

    TXT("txt", "text/plain"),
    CSV("csv", "text/csv"),
    JSON("json", "application/json"),
    XML("xml", "application/xml");

    private final String extension;
    private final String mimeType;

    FileType(String extension, String mimeType) {
        this.extension = extension;
        this.mimeType = mimeType;
    }

    public static Optional<FileType> fromExtension(String extension) {
        return Arrays.stream(FileType.values())
                .filter(fileType -> fileType.getExtension().equalsIgnoreCase(extension))
                .findFirst();
    }

    public static Optional<FileType> fromMimeType(String mimeType) {
        return Arrays.stream(FileType.values())
                .filter(fileType -> fileType.getMimeType().equalsIgnoreCase(mimeType))
                .findFirst();
    }

}
````

üìò Resumen
> Aunque estas clases no son parte directa del patr√≥n `Template Method`, funcionan como soporte esencial para la
> robustez, extensibilidad y claridad del sistema. Separar conceptos como tipo de archivo, origen del almacenamiento y
> errores espec√≠ficos permite que el sistema sea mantenible, abierto a nuevos formatos y preparado para escenarios
> reales de uso.

### üß∞ FileUtils ‚Äì Utilidades para el manejo de archivos temporales

La clase `FileUtils` encapsula operaciones auxiliares relacionadas con el manejo de archivos durante el procesamiento.
No pertenece al patr√≥n `Template Method` en s√≠, pero ofrece funcionalidades de soporte necesarias para su implementaci√≥n
fluida.

````java

@Slf4j
@UtilityClass
public class FileUtils {

    public static Path retrieveAsTempFile(InputStream inputStream, String filename) {
        try (InputStream is = inputStream) {
            Path tempDir = Files.createTempDirectory("file_processor");
            Path fullPathTempFile = tempDir.resolve(filename);
            Files.copy(is, fullPathTempFile, StandardCopyOption.REPLACE_EXISTING);
            return fullPathTempFile;
        } catch (IOException e) {
            throw new FileProcessorException("Error al recuperar archivo temporal: " + e.getMessage());
        }
    }

    public static void deleteTempFile(Path path) {
        if (Objects.isNull(path)) {
            log.warn("El path es null. No hay archivo temporal qu√© eliminar");
            return;
        }

        Path parentTempDir = path.getParent();
        if (Objects.isNull(parentTempDir) || !Files.exists(parentTempDir)) {
            log.warn("El directorio temporal no existe: {}", parentTempDir);
            return;
        }

        try {
            Files.walk(parentTempDir)
                    .sorted(Comparator.reverseOrder()) // Elimina primero los archivos, luego los directorios
                    .forEach(pathTemp -> {
                        try {
                            Files.delete(pathTemp);
                            log.info("Eliminado: {}", pathTemp);
                        } catch (IOException e) {
                            log.warn("No se pudo eliminar: {}", pathTemp, e);
                        }
                    });
        } catch (IOException e) {
            log.warn("Error al recorrer/eliminar el directorio temporal: {}", parentTempDir, e);
        }
    }

    public static String generateFilename(String extension, String batchId) {
        return "%s_%d.%s".formatted(batchId, System.currentTimeMillis(), extension);
    }

    public static String getFileExtension(MultipartFile multipartFile) {
        String filename = multipartFile.getOriginalFilename();
        if (Objects.isNull(filename) || filename.isBlank() || hasNoExtension(filename)) {
            throw new FileProcessorException("El archivo no tiene un nombre o extensi√≥n v√°lida");
        }
        return filename.substring(filename.lastIndexOf(".") + 1);
    }

    public static boolean hasNoExtension(String filename) {
        return !Pattern.matches(".+\\.[a-zA-Z0-9]+", filename);
    }
}
````

üìò Resumen
> `FileUtils` es una clase auxiliar que abstrae la l√≥gica relacionada con la gesti√≥n de archivos temporales, generaci√≥n
> de nombres √∫nicos, y validaci√≥n de extensiones. Esta separaci√≥n refuerza el `principio de responsabilidad √∫nica`
> (`SRP`), mantiene limpio el flujo de procesamiento y favorece la reutilizaci√≥n.

### üóÉÔ∏è Servicio de almacenamiento de archivos: FileStorageService y LocalFileStorageService

Este componente encapsula la l√≥gica de almacenamiento y recuperaci√≥n de archivos antes de ser procesados. Aunque no
pertenece al n√∫cleo del patr√≥n `Template Method`, juega un rol esencial en su funcionamiento, ya que permite abstraer la
fuente y destino de los archivos, haciendo que el flujo de procesamiento se mantenga desacoplado del mecanismo f√≠sico de
almacenamiento.

````java
public interface FileStorageService {
    FileStorageInfo storeFile(MultipartFile multipartFile, String batchId);

    InputStream retrieveFileContent(FileStorageInfo info);
}
````

Esta interfaz define el contrato general para cualquier servicio de almacenamiento que permita:

1. `Guardar` un archivo recibido desde el cliente (`MultipartFile`) con un identificador de lote (`batchId`).
2. `Recuperar` su contenido como un `InputStream`, necesario para leer y procesar su contenido.

> üìå Ventaja de dise√±o: Permite seguir el `principio de inversi√≥n de dependencias (DIP)`. La clase `FileProcessor`
> depende de una abstracci√≥n (`FileStorageService`) y no de una implementaci√≥n concreta, facilitando pruebas,
> mantenimiento y extensibilidad (por ejemplo, para `S3` o `Azure Blob Storage`).

````java

@Slf4j
@Service
public class LocalFileStorageService implements FileStorageService {

    @Override
    public FileStorageInfo storeFile(MultipartFile multipartFile, String batchId) {
        try {
            Path storagePath = Path.of("M:", "temp_files");
            Files.createDirectories(storagePath);

            String extension = FileUtils.getFileExtension(multipartFile);
            String filename = FileUtils.generateFilename(extension, batchId);

            Path fullPath = storagePath.resolve(filename);
            Files.copy(multipartFile.getInputStream(), fullPath, StandardCopyOption.REPLACE_EXISTING);

            return FileStorageInfo.create(fullPath.toString(), filename, StorageType.LOCAL);
        } catch (IOException e) {
            log.error("Error al almacenar el archivo en local: {}", e.getMessage(), e);
            throw new FileProcessorException("Error al almacenar el archivo en local: %s".formatted(e.getMessage()));
        }
    }

    @Override
    public InputStream retrieveFileContent(FileStorageInfo info) {
        try {
            Path path = Path.of(info.location());
            return Files.newInputStream(path);
        } catch (IOException e) {
            log.error("No se pudo leer archivo local: {}", e.getMessage(), e);
            throw new FileProcessorException("No se pudo leer archivo local: " + e.getMessage());
        }
    }
}
````

Es la implementaci√≥n local del servicio de almacenamiento, basada en el sistema de archivos del servidor.

#### üîê M√©todo: storeFile(...)

Guarda f√≠sicamente el archivo en el disco dentro de un directorio temporal configurado (`M:/temp_files`). Utiliza
utilidades previamente definidas para:

- Obtener la extensi√≥n del archivo.
- Generar un nombre √∫nico usando el batchId.
- Copiar el contenido del MultipartFile al disco.

Devuelve un objeto `FileStorageInfo` con los metadatos del archivo (ubicaci√≥n, nombre, tipo de almacenamiento).

#### üîç M√©todo: retrieveFileContent(...)

Recibe un `FileStorageInfo` y abre un `InputStream` desde el path donde fue almacenado el archivo.

> üìå Importante: Este dise√±o desacopla completamente el lugar de almacenamiento del resto de la l√≥gica de
> procesamiento. Si ma√±ana decides usar `S3` o `Azure`, solo debes implementar otra clase que extienda
> `FileStorageService`.

üìò Resumen
> El servicio de almacenamiento act√∫a como una abstracci√≥n de la fuente de archivos, permitiendo que el sistema de
> procesamiento se mantenga independiente del origen f√≠sico. Este dise√±o sigue el
> `principio de Inversi√≥n de Dependencias` (`DIP`) y prepara al sistema para futuras extensiones sin necesidad de
> modificar la l√≥gica central.

### üß© Clase base abstracta: `FileProcessor<T extends ParsedRecord>`

La clase `FileProcessor<T>` es la plantilla base que implementa el patr√≥n de dise√±o `Template Method` en este sistema
de procesamiento de archivos. Su prop√≥sito es definir una secuencia fija de pasos que todos los procesadores de archivos
deben seguir, permitiendo a las subclases especializar solo aquellos pasos que var√≠an seg√∫n el tipo de archivo.

### üéØ Rol en el patr√≥n Template Method

Define el esqueleto del algoritmo de procesamiento de archivos en el m√©todo `processFile(...)`, delegando pasos
personalizables a m√©todos abstractos que deben ser implementados por subclases concretas (`TxtDelimitedProcessor`,
`CsvDelimitedProcessor`, etc.).

El m√©todo `processFile(...)` es el `template method` en s√≠. Es un m√©todo `final` (no se puede sobrescribir), que
implementa paso a paso el flujo completo de procesamiento de un archivo. Cada etapa se encuentra bien delimitada y est√°
acompa√±ada por registros de logs para trazabilidad.

````java

@Slf4j
@RequiredArgsConstructor
public abstract class FileProcessor<T extends ParsedRecord> {

    private final FileStorageService fileStorageService;

    public final ProcessResult processFile(MultipartFile multipartFile, String batchId) {
        log.info("=== Iniciando procesamiento de archivo ===");
        log.info("Archivo: {} - Batch ID: {} - Tama√±o: {}", multipartFile.getOriginalFilename(), batchId, multipartFile.getSize());
        Path pathTempFile = null;

        try {
            // Paso 1: Validar archivo a procesar (lanza excepci√≥n si falla)
            this.validateMultipartFile(multipartFile);
            log.info("Archivo {} validado correctamente", multipartFile.getOriginalFilename());

            // Paso 2: Almacenar el archivo y generar uno temporal
            FileStorageInfo fileStorageInfo = this.fileStorageService.storeFile(multipartFile, batchId);
            log.info("Archivo {} guardado con √©xito como {}", multipartFile.getOriginalFilename(), fileStorageInfo.filename());

            InputStream inputStream = this.fileStorageService.retrieveFileContent(fileStorageInfo);
            pathTempFile = FileUtils.retrieveAsTempFile(inputStream, fileStorageInfo.filename());
            log.info("Procesando archivo desde: {}", pathTempFile);

            // Paso 3: Validar estructura del archivo (ProcessResult si falla)
            ValidationResult structureValidation = this.validateFileStructure(pathTempFile);
            if (!structureValidation.valid()) {
                log.warn("Validaci√≥n de estructura fallida: {}", structureValidation.errorMessage());
                return ProcessResult.failure(batchId, "Validaci√≥n de estructura fallida: " + structureValidation.errorMessage(), fileStorageInfo);
            }

            // Paso 4: Procesar contenido l√≠nea por l√≠nea (ProcessResult si falla)
            List<T> parsedRecords = this.parseFileContent(pathTempFile);
            if (parsedRecords.isEmpty()) {
                log.warn("El archivo no contiene registros procesables");
                return ProcessResult.failure(batchId, "El archivo est√° vac√≠o o no contiene registros procesables", fileStorageInfo);
            }
            int totalRecords = parsedRecords.size();
            log.info("Se parsearon {} registros del archivo", totalRecords);

            // Paso 5: Validar datos del negocio (ProcessResult con advertencias)
            BusinessValidationResult<T> businessValidationResult = this.validateBusinessRules(parsedRecords);
            List<T> validRecords = businessValidationResult.validRecords();
            int invalidCount = businessValidationResult.invalidCount();

            if (invalidCount > 0) {
                log.warn("Se encontraron {} registros inv√°lidos de {}", invalidCount, totalRecords);
            }

            // Paso 6: Persistir en base de datos (ProcessResult si falla)
            ProcessResult result;
            if (!validRecords.isEmpty()) {
                log.info("Persistiendo {} registros v√°lidos en base de datos", validRecords.size());
                int processedRecords = this.storeRecords(validRecords, batchId);
                result = ProcessResult.success(batchId, totalRecords, processedRecords, invalidCount, fileStorageInfo);
                log.info("Se persistieron {} registros exitosamente", processedRecords);
            } else {
                log.warn("No se encontraron registros v√°lidos para almacenar");
                result = ProcessResult.failure(batchId, "No se encontraron registros v√°lidos para almacenar.", fileStorageInfo);
            }

            // Paso 7: Generar notificaci√≥n final
            this.generateProcessingReport(result, multipartFile);

            if (result.success()) {
                log.info("Procesamiento finalizado exitosamente. Registros procesados: {}", result.processedRecords());
            } else {
                log.warn("Procesamiento finalizado con errores. Motivo: {}", result.errorMessage());
            }
            return result;
        } finally {
            // Paso 8: Eliminar archivo temporal
            if (pathTempFile != null) {
                log.info("Limpiando archivo temporal: {}", pathTempFile);
                FileUtils.deleteTempFile(pathTempFile);
            }
        }
    }

    // ============== M√âTODOS CONCRETOS (comunes a todos los tipos) ==============
    protected void validateMultipartFile(MultipartFile multipartFile) {
        if (Objects.isNull(multipartFile) || multipartFile.isEmpty()) {
            throw new FileProcessorException("El archivo est√° vac√≠o o no fue enviado");
        }

        String filename = multipartFile.getOriginalFilename();
        if (Objects.isNull(filename) || filename.isBlank()) {
            throw new FileProcessorException("El nombre del archivo es inv√°lido");
        }

        if (FileUtils.hasNoExtension(filename)) {
            throw new FileProcessorException("El archivo no tiene una extensi√≥n v√°lida");
        }

        if (!this.expectedFileType().getExtension().equalsIgnoreCase(FileUtils.getFileExtension(multipartFile))) {
            throw new FileProcessorException("Se esperaba un archivo con extensi√≥n: " + this.expectedFileType().getExtension());
        }
    }

    protected void generateProcessingReport(ProcessResult result, MultipartFile multipartFile) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(formatter);

        String extension = FileUtils.getFileExtension(multipartFile);
        String status = this.determineProcessingStatus(result);

        StringBuilder report = new StringBuilder("=== REPORTE DE PROCESAMIENTO %s ===".formatted(extension));
        report.append("\n");
        report.append("Archivo Original: ").append(multipartFile.getOriginalFilename()).append("\n");
        report.append("Archivo Almacenado: ").append(result.sourceInfo().filename()).append("\n");
        report.append("Ubicaci√≥n: ").append(result.sourceInfo().location()).append("\n");
        report.append("Storage Type: ").append(result.sourceInfo().storageType()).append("\n");
        report.append("Batch ID: ").append(result.batchId()).append("\n");
        report.append("Fecha/Hora: ").append(timestamp).append("\n");
        report.append("Processor: ").append(this.getClass().getSimpleName()).append("\n");
        report.append("Total registros: ").append(result.totalRecords()).append("\n");
        report.append("Registros procesados: ").append(result.processedRecords()).append("\n");
        report.append("Registros inv√°lidos: ").append(result.invalidRecords()).append("\n");
        report.append("Estado: ").append(status);

        log.info("REPORTE {}:\n{}", extension, report);
    }

    // ============== M√âTODOS ABSTRACTOS (espec√≠ficos por tipo de archivo) ==============
    public abstract FileType expectedFileType();

    protected abstract ValidationResult validateFileStructure(Path path);

    protected abstract List<T> parseFileContent(Path path);

    protected abstract BusinessValidationResult<T> validateBusinessRules(List<T> parsedRecords);

    protected abstract int storeRecords(List<T> validRecords, String batchId);

    // ============== M√âTODOS PRIVADOS ==============
    private String determineProcessingStatus(ProcessResult result) {
        if (!result.success()) {
            return "Error";
        } else if (result.invalidRecords() > 0) {
            return "Exitoso con advertencias";
        } else {
            return "Exitoso";
        }
    }
}
````

üìò Resumen
> Esta clase base define el algoritmo gen√©rico para procesar cualquier tipo de archivo estructurado, desacoplando las
> partes invariantes de las variables. Gracias al patr√≥n `Template Method`, se garantiza un flujo uniforme y controlado,
> donde las diferencias de formato (`TXT`, `CSV`, `JSON`, etc.) se encapsulan en subclases concretas que implementan los
> m√©todos abstractos.

Adem√°s:

- Se promueve el `principio de Inversi√≥n de Dependencias (DIP)` al depender de la interfaz `FileStorageService`.
- Se favorece el `principio de Responsabilidad √önica (SRP)`: esta clase solo orquesta el proceso, mientras que el
  parseo, validaci√≥n y almacenamiento est√°n delegados.
- Es `abierta a extensi√≥n (para nuevos formatos) y cerrada a modificaci√≥n`, cumpliendo con el `principio OCP`.
