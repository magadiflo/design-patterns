# Patrones de comportamiento aplicados en Spring Boot

---

# Strategy

## üéØ Ejemplo 01: Estrategias de pago

En este ejemplo, estamos construyendo un sistema flexible para manejar diferentes m√©todos de pago, utilizando el
`patr√≥n Strategy`. Para ello, definimos una `interfaz com√∫n` para las solicitudes de pago y varios record que
representan las distintas formas de pago. Aqu√≠ analizamos las decisiones clave:

### ‚úÖ Uso de record en lugar de clases tradicionales

Se opt√≥ por utilizar record para definir los objetos de solicitud de pago (`DTOs`). Los record son una caracter√≠stica
introducida en Java 14 (estable en Java 16) que permite crear clases inmutables y concisas, ideales para transportar
datos sin necesidad de escribir constructores, getters o m√©todos como `toString()`, `equals()` o `hashCode()`
manualmente.

Cada forma de pago cuenta con su propio record, el cual encapsula los datos espec√≠ficos que requiere ese m√©todo. Por
ejemplo:

- `PayPalPaymentRequest` incluye email y contrase√±a.
- `BankTransferPaymentRequest` contiene datos bancarios como el titular, nombre del banco y el n√∫mero de cuenta.
- `CreditCardPaymentRequest` define los datos de la tarjeta de cr√©dito como n√∫mero, vencimiento y c√≥digo de seguridad
  (CVV).

````java
public record PayPalPaymentRequest(String orderId,
                                   double amount,
                                   String currency,
                                   String paypalEmail,
                                   String password) implements PaymentRequest {
}
````

````java
public record BankTransferPaymentRequest(String orderId,
                                         double amount,
                                         String currency,
                                         String accountHolder,
                                         String bankName,
                                         String accountNumber) implements PaymentRequest {
}
````

````java
public record CreditCardPaymentRequest(String orderId,
                                       double amount,
                                       String currency,
                                       String cardNumber,
                                       String expiryDate,
                                       String cvv) implements PaymentRequest {

}
````

### üí° Por qu√© se usa una interfaz (PaymentRequest) en lugar de una clase abstracta

Una `limitaci√≥n importante de los record` en Java es que `no pueden extender clases (ni abstractas ni concretas)`.
Todos los record extienden impl√≠citamente `java.lang.Record` como superclase final. Por ello:

> No es posible crear una jerarqu√≠a como `abstract class PaymentRequest { ... }` y que los record la extiendan.

La soluci√≥n correcta en este caso es definir una `interfaz`, como `PaymentRequest`, que los record s√≠ pueden
implementar. Esto permite que todas las solicitudes de pago compartan una estructura com√∫n (como `orderId`, `amount` y
`currency`), y puedan ser tratadas de forma polim√≥rfica. Por ejemplo:

````java
void processPayment(PaymentRequest request);
````

Esto facilita la implementaci√≥n del `patr√≥n Strategy` m√°s adelante, ya que cada estrategia puede operar sobre su tipo
espec√≠fico, pero tambi√©n podemos validar o enrutar por la interfaz base.

### üì¶ Detalle de la interfaz PaymentRequest

Esta interfaz define tres m√©todos comunes a todas las solicitudes de pago:

````java
public interface PaymentRequest {
    String orderId();

    double amount();

    String currency();
}
````

Al ser implementada por cada record, garantiza que todas las solicitudes posean esos campos fundamentales.

### üì§ PaymentResponse

Finalmente, tambi√©n definimos un record llamado `PaymentResponse`, que encapsula la respuesta com√∫n que devuelve
cualquier estrategia de pago:

- `success`: indica si el pago fue exitoso.
- `transactionId`: un identificador √∫nico de la transacci√≥n.
- `message`: mensaje opcional para retroalimentaci√≥n.

Este DTO tambi√©n sigue el mismo enfoque inmutable, claro y orientado a datos.

````java
public record PaymentResponse(boolean success,
                              String transactionId,
                              String message) {
}
````

### Interfaz gen√©rica `PaymentStrategy<T extends PaymentRequest>`

Esta interfaz define el contrato que toda estrategia de pago debe cumplir. Es decir, cualquier clase que implemente
esta interfaz deber√° proporcionar l√≥gica para:

- Validar los datos de la solicitud de pago.
- Ejecutar el proceso de pago y devolver una respuesta.

````java
public interface PaymentStrategy<T extends PaymentRequest> {
    boolean validatePayment(T request);

    PaymentResponse pay(T request);
}
````

### üéØ Uso de gen√©ricos: `<T extends PaymentRequest>`

El uso de `generics` en esta interfaz permite que cada implementaci√≥n est√© especializada en un tipo espec√≠fico de
solicitud de pago (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).

Veamos qu√© significa esta parte:

````bash
<T extends PaymentRequest>
````

- `T` es un `par√°metro de tipo` que puede variar seg√∫n la implementaci√≥n concreta.
- `extends PaymentRequest` indica que `T` `debe ser una subclase o implementaci√≥n de PaymentRequest` (en este caso, un
  record que implementa la interfaz).
- Esto garantiza que cualquier objeto `T` usado como par√°metro tenga al menos los m√©todos definidos en `PaymentRequest`
  (`orderId()`, `amount()`, `currency()`).

### ‚úÖ Ventajas de usar generics aqu√≠

1. `Seguridad de tipo en tiempo de compilaci√≥n`. Cada estrategia concreta puede trabajar con su tipo espec√≠fico sin
   necesidad de hacer casting:
    ````java
    public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest>{/*code*/}
    ````
2. `Mayor claridad y cohesi√≥n`. La estrategia queda claramente ligada a su tipo de request. Esto facilita el
   mantenimiento y evita errores al procesar datos que no corresponden.
3. `Reutilizaci√≥n y escalabilidad`. Puedes crear f√°cilmente nuevas estrategias para otros m√©todos de pago
   (e.g.,`CryptoPaymentRequest`) sin modificar la interfaz base.

### üß© Relaci√≥n con los record y el patr√≥n Strategy

Como vimos antes, los distintos record (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.) implementan la
interfaz `PaymentRequest`. Gracias a eso, se pueden usar como tipo `T` en esta interfaz gen√©rica.

Esto forma la base del `patr√≥n Strategy`, ya que cada implementaci√≥n concreta de `PaymentStrategy<T>` define c√≥mo
manejar su tipo de pago particular, respetando la misma estructura com√∫n (validar y pagar).

### Estrategias concretas de pago

Cada una de las clases que veremos a continuaci√≥n representa una estrategia concreta dentro del patr√≥n Strategy. Todas
implementan la interfaz gen√©rica PaymentStrategy<T>, que exige dos m√©todos:

- `validatePayment(T request)`: realiza validaciones sobre la solicitud de pago.
- `pay(T request)`: ejecuta la l√≥gica de pago y devuelve un PaymentResponse.

Estas clases se anotan con @Component para que Spring las detecte y gestione como beans, y adem√°s con @Slf4j para
permitir el uso de logging con log.info(), log.error(), etc.

Veamos cada implementaci√≥n.

### üìå PayPalPaymentStrategy

````java

@Slf4j
@Component("payPal")
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {
    @Override
    public boolean validatePayment(PayPalPaymentRequest request) {
        if (Objects.isNull(request.paypalEmail()) || !request.paypalEmail().contains("@")) {
            log.error("Email de PayPal inv√°lido");
            return false;
        }

        if (Objects.isNull(request.password()) || request.password().length() < 6) {
            log.error("Contrase√±a debe tener al menos 6 caracteres");
            return false;
        }

        log.info("Datos de la cuenta de PayPal validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(PayPalPaymentRequest request) {
        log.info("Procesando pago S/{} con PayPal para el usuario {}", request.amount(), request.paypalEmail());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "PP-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con PayPal");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con PayPal");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia concreta se encarga de procesar pagos mediante cuentas PayPal.

- Validaci√≥n:
    - Verifica que el email tenga formato v√°lido (contenga @).
    - La contrase√±a debe tener al menos 6 caracteres.

- Proceso de pago:
    - Simula una espera (Thread.sleep) para representar el tiempo de procesamiento.
    - Genera un transactionId con prefijo PP-.
    - Retorna un PaymentResponse exitoso.

> üìå `Nota t√©cnica`: El identificador del bean en el contenedor de Spring es `"payPal`", ya que as√≠ se defini√≥
> expl√≠citamente con `@Component("payPal")`. Esto ser√° importante al momento de recuperar din√°micamente las estrategias.

### üìå BankTransferPaymentStrategy

````java

@Slf4j
@Component("bankTransfer")
public class BankTransferPaymentStrategy implements PaymentStrategy<BankTransferPaymentRequest> {

    @Override
    public boolean validatePayment(BankTransferPaymentRequest request) {
        if (Objects.isNull(request.accountHolder()) || request.accountHolder().isBlank()) {
            log.error("Titular de la cuenta es requerido");
            return false;
        }

        if (Objects.isNull(request.bankName()) || request.bankName().isBlank()) {
            log.error("El nombre del banco es requerido");
            return false;
        }

        if (Objects.isNull(request.accountNumber()) || request.accountNumber().isBlank()) {
            log.error("N√∫mero de cuenta es requerido");
            return false;
        }

        log.info("Datos para la transferencia bancaria validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(BankTransferPaymentRequest request) {
        log.info("Pagando S/{} mediante transferencia bancaria al banco {}", request.amount(), request.bankName());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "BT-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con Transferencia Bancaria");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con Transferencia Bancaria");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia implementa pagos mediante transferencia bancaria.

- Validaci√≥n:
    - Todos los campos relevantes deben estar presentes: titular de cuenta, nombre del banco y n√∫mero de cuenta.

- Proceso de pago:
    - Simula un retardo para reflejar el tiempo de procesamiento.
    - Genera un `transactionId` con prefijo `BT-`.
    - Retorna una respuesta de √©xito.

> üìå `Buenas pr√°cticas`:
> Los campos se validan con `Objects.isNull()` y `isBlank()`, garantizando que no se procesen datos incompletos o
> err√≥neos.

### üìå CreditCardPaymentStrategy

````java

@Slf4j
@Component("creditCard")
public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest> {

    @Override
    public boolean validatePayment(CreditCardPaymentRequest request) {
        if (Objects.isNull(request.cardNumber()) || request.cardNumber().trim().length() < 16) {
            log.error("N√∫mero de tarjeta inv√°lido");
            return false;
        }

        if (Objects.isNull(request.expiryDate()) || request.expiryDate().isBlank()) {
            log.error("Fecha de expiraci√≥n requerida");
            return false;
        }

        if (Objects.isNull(request.cvv()) || request.cvv().trim().length() != 3) {
            log.error("Cvv inv√°lido");
            return false;
        }

        log.info("Datos de la tarjeta cr√©dito validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(CreditCardPaymentRequest request) {
        log.info("Procesando pago S/{} con tarjeta de cr√©dito {}", request.amount(), request.cardNumber());
        try {
            Thread.sleep(Duration.ofSeconds(1));
            String transactionId = "CC-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con tarjeta");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con tarjeta");
            throw new RuntimeException(e);
        }
    }
}
````

Esta clase maneja los pagos con tarjeta de cr√©dito.

- Validaci√≥n:
    - El n√∫mero de tarjeta debe tener al menos 16 caracteres.
    - La fecha de expiraci√≥n no puede estar vac√≠a.
    - El CVV debe tener exactamente 3 d√≠gitos.

- Proceso de pago:
    - Simula la espera con Thread.sleep(1000ms).
    - Genera un identificador con prefijo `CC-`.
    - Retorna un PaymentResponse indicando √©xito.

> üìå `Observaci√≥n`: En un sistema real, estas validaciones ser√≠an mucho m√°s rigurosas e incluir√≠an cifrado, tokens de
> sesi√≥n, y comunicaci√≥n con una pasarela de pagos (como Stripe, PayPal SDK, etc.). Sin embargo, este ejemplo est√°
> dise√±ado con fines pedag√≥gicos.

### üß† Consideraciones sobre el uso de gen√©ricos

Cada clase implementa la interfaz Strategy de forma tipada, como por ejemplo:

````java
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {/*code*/
}
````

Esto tiene dos beneficios importantes:

1. `Tipo seguro en tiempo de compilaci√≥n`: El m√©todo `pay()` s√≥lo aceptar√° objetos del tipo correspondiente
   (`PayPalPaymentRequest`, por ejemplo). No es necesario hacer cast ni validaciones adicionales.
2. `Separaci√≥n clara de responsabilidades`: Cada estrategia solo conoce y manipula su propio tipo de solicitud de pago,
   manteniendo bajo acoplamiento y alta cohesi√≥n.

Este enfoque ser√° especialmente √∫til cuando expliquemos el uso de `Map<String, PaymentStrategy<?>>` en la f√°brica de
estrategias, donde se gestionan de forma din√°mica.

### üè≠ PaymentStrategyFactory: Resolviendo estrategias din√°micamente

La clase `PaymentStrategyFactory` act√∫a como un punto centralizado para obtener la estrategia adecuada seg√∫n el tipo de
pago solicitado. Permite desacoplar la l√≥gica de selecci√≥n de estrategia del resto del sistema, haciendo que el c√≥digo
sea m√°s limpio, extensible y abierto a nuevas formas de pago sin modificar c√≥digo existente.

### üéØ Prop√≥sito

Esta clase permite, por ejemplo, que al recibir el tipo de pago `payPal`, devuelva la instancia correspondiente de
`PayPalPaymentStrategy`, lista para ser usada.

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class PaymentStrategyFactory {

    private final Map<String, PaymentStrategy<? extends PaymentRequest>> paymentStrategies;

    @SuppressWarnings("unchecked")
    public <T extends PaymentRequest> PaymentStrategy<T> getPaymentStrategy(String paymentType) {
        PaymentStrategy<? extends PaymentRequest> strategy = this.paymentStrategies.get(paymentType);
        if (Objects.isNull(strategy)) {
            throw new IllegalArgumentException("Estrategia no soportada: " + paymentType);
        }
        return (PaymentStrategy<T>) strategy;
    }

    public List<String> getSupportedPaymentTypes() {
        return this.paymentStrategies.keySet().stream().sorted().toList();
    }
}
````

### üîÅ Inyecci√≥n de estrategias como `Map<String, PaymentStrategy<? extends PaymentRequest>>`

`Spring Boot` es capaz de inyectar autom√°ticamente todas las implementaciones de
`PaymentStrategy<? extends PaymentRequest>` registradas como `@Component` en el contexto de la aplicaci√≥n,
organiz√°ndolas en un Map, donde:

- `Key`: es el nombre del bean (`payPal`, `creditCard`, etc.), definido con `@Component("nombre")`.
- `Value`: es la instancia concreta de la estrategia (`PaymentStrategy<PayPalPaymentRequest>`, por ejemplo).

Esto evita tener que usar `@Qualifier` uno por uno o manejar condicionales expl√≠citos como `if (...)`.

### üß† ¬øPor qu√© `? extends PaymentRequest`?

El tipo gen√©rico `? extends PaymentRequest` permite que el Map almacene `estrategias con diferentes tipos espec√≠ficos`,
siempre que esos tipos `extiendan` de `PaymentRequest`. As√≠ se garantiza flexibilidad y compatibilidad con las
estrategias concretas definidas anteriormente.

En t√©rminos pr√°cticos, esto permite almacenar en un solo Map:

````bash
PaymentStrategy<PayPalPaymentRequest>,
PaymentStrategy<CreditCardPaymentRequest>,
PaymentStrategy<BankTransferPaymentRequest> 
````

Todos ellos son v√°lidos porque sus `T` cumplen `T extends PaymentRequest`.

### ‚öôÔ∏è M√©todo getPaymentStrategy(...)

Este m√©todo recupera la estrategia deseada a partir del tipo de pago (`paymentType`), realizando un cast controlado al
tipo gen√©rico correcto `(PaymentStrategy<T>)`.

- El cast es seguro en la pr√°ctica porque el dise√±o de la aplicaci√≥n garantiza que el `paymentType` mapea al tipo
  correcto de estrategia.
- La anotaci√≥n `@SuppressWarnings("unchecked")` es necesaria porque el compilador no puede verificar completamente este
  cast en tiempo de compilaci√≥n debido a la borradura de tipos en Java.

Este m√©todo es una `pieza clave para la integraci√≥n polim√≥rfica y flexible del patr√≥n Strategy` en el servicio
principal.

### üìö M√©todo auxiliar: getSupportedPaymentTypes()

Este m√©todo devuelve una lista ordenada de los identificadores de los m√©todos de pago disponibles. Es √∫til para:

- Documentar o mostrar en una UI qu√© opciones de pago est√°n habilitadas.
- Validaciones previas.
- Tests automatizados.

### ‚úÖ Ventajas de este enfoque

- `Abierto a extensi√≥n`: agregar una nueva estrategia s√≥lo requiere crear una clase con `@Component("nuevoTipo")`, sin
  modificar la f√°brica.
- `Elimina condicionales`: se evita el uso de switch, if-else, o inyecciones manuales.
- `Seguridad de tipos con flexibilidad`: el uso de gen√©ricos y `? extends` permite mantener la seguridad de tipo sin
  sacrificar dinamismo.
- `Centraliza el acceso a las estrategias`: si se necesita aplicar reglas o validaciones adicionales, pueden colocarse
  aqu√≠.
