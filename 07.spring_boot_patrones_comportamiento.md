# Patrones de comportamiento aplicados en Spring Boot

---

# Strategy

## üéØ Ejemplo 01: Estrategias de pago

En este ejemplo, estamos construyendo un sistema flexible para manejar diferentes m√©todos de pago, utilizando el
`patr√≥n Strategy`. Para ello, definimos una `interfaz com√∫n` para las solicitudes de pago y varios record que
representan las distintas formas de pago. Aqu√≠ analizamos las decisiones clave:

### ‚úÖ Uso de record en lugar de clases tradicionales

Se opt√≥ por utilizar record para definir los objetos de solicitud de pago (`DTOs`). Los record son una caracter√≠stica
introducida en Java 14 (estable en Java 16) que permite crear clases inmutables y concisas, ideales para transportar
datos sin necesidad de escribir constructores, getters o m√©todos como `toString()`, `equals()` o `hashCode()`
manualmente.

Cada forma de pago cuenta con su propio record, el cual encapsula los datos espec√≠ficos que requiere ese m√©todo. Por
ejemplo:

- `PayPalPaymentRequest` incluye email y contrase√±a.
- `BankTransferPaymentRequest` contiene datos bancarios como el titular, nombre del banco y el n√∫mero de cuenta.
- `CreditCardPaymentRequest` define los datos de la tarjeta de cr√©dito como n√∫mero, vencimiento y c√≥digo de seguridad
  (CVV).

````java
public record PayPalPaymentRequest(String orderId,
                                   double amount,
                                   String currency,
                                   String paypalEmail,
                                   String password) implements PaymentRequest {
}
````

````java
public record BankTransferPaymentRequest(String orderId,
                                         double amount,
                                         String currency,
                                         String accountHolder,
                                         String bankName,
                                         String accountNumber) implements PaymentRequest {
}
````

````java
public record CreditCardPaymentRequest(String orderId,
                                       double amount,
                                       String currency,
                                       String cardNumber,
                                       String expiryDate,
                                       String cvv) implements PaymentRequest {

}
````

### üí° Por qu√© se usa una interfaz (PaymentRequest) en lugar de una clase abstracta

Una `limitaci√≥n importante de los record` en Java es que `no pueden extender clases (ni abstractas ni concretas)`.
Todos los record extienden impl√≠citamente `java.lang.Record` como superclase final. Por ello:

> No es posible crear una jerarqu√≠a como `abstract class PaymentRequest { ... }` y que los record la extiendan.

La soluci√≥n correcta en este caso es definir una `interfaz`, como `PaymentRequest`, que los record s√≠ pueden
implementar. Esto permite que todas las solicitudes de pago compartan una estructura com√∫n (como `orderId`, `amount` y
`currency`), y puedan ser tratadas de forma polim√≥rfica. Por ejemplo:

````java
void processPayment(PaymentRequest request);
````

Esto facilita la implementaci√≥n del `patr√≥n Strategy` m√°s adelante, ya que cada estrategia puede operar sobre su tipo
espec√≠fico, pero tambi√©n podemos validar o enrutar por la interfaz base.

### üì¶ Detalle de la interfaz PaymentRequest

Esta interfaz define tres m√©todos comunes a todas las solicitudes de pago:

````java
public interface PaymentRequest {
    String orderId();

    double amount();

    String currency();
}
````

Al ser implementada por cada record, garantiza que todas las solicitudes posean esos campos fundamentales.

### üì§ PaymentResponse

Finalmente, tambi√©n definimos un record llamado `PaymentResponse`, que encapsula la respuesta com√∫n que devuelve
cualquier estrategia de pago:

- `success`: indica si el pago fue exitoso.
- `transactionId`: un identificador √∫nico de la transacci√≥n.
- `message`: mensaje opcional para retroalimentaci√≥n.

Este DTO tambi√©n sigue el mismo enfoque inmutable, claro y orientado a datos.

````java
public record PaymentResponse(boolean success,
                              String transactionId,
                              String message) {
}
````

### Interfaz gen√©rica `PaymentStrategy<T extends PaymentRequest>`

Esta interfaz define el contrato que toda estrategia de pago debe cumplir. Es decir, cualquier clase que implemente
esta interfaz deber√° proporcionar l√≥gica para:

- Validar los datos de la solicitud de pago.
- Ejecutar el proceso de pago y devolver una respuesta.

````java
public interface PaymentStrategy<T extends PaymentRequest> {
    boolean validatePayment(T request);

    PaymentResponse pay(T request);
}
````

### üéØ Uso de gen√©ricos: `<T extends PaymentRequest>`

El uso de `generics` en esta interfaz permite que cada implementaci√≥n est√© especializada en un tipo espec√≠fico de
solicitud de pago (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).

Veamos qu√© significa esta parte:

````bash
<T extends PaymentRequest>
````

- `T` es un `par√°metro de tipo` que puede variar seg√∫n la implementaci√≥n concreta.
- `extends PaymentRequest` indica que `T` `debe ser una subclase o implementaci√≥n de PaymentRequest` (en este caso, un
  record que implementa la interfaz).
- Esto garantiza que cualquier objeto `T` usado como par√°metro tenga al menos los m√©todos definidos en `PaymentRequest`
  (`orderId()`, `amount()`, `currency()`).

### ‚úÖ Ventajas de usar generics aqu√≠

1. `Seguridad de tipo en tiempo de compilaci√≥n`. Cada estrategia concreta puede trabajar con su tipo espec√≠fico sin
   necesidad de hacer casting:
    ````java
    public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest>{/*code*/}
    ````
2. `Mayor claridad y cohesi√≥n`. La estrategia queda claramente ligada a su tipo de request. Esto facilita el
   mantenimiento y evita errores al procesar datos que no corresponden.
3. `Reutilizaci√≥n y escalabilidad`. Puedes crear f√°cilmente nuevas estrategias para otros m√©todos de pago
   (e.g.,`CryptoPaymentRequest`) sin modificar la interfaz base.

### üß© Relaci√≥n con los record y el patr√≥n Strategy

Como vimos antes, los distintos record (`PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.) implementan la
interfaz `PaymentRequest`. Gracias a eso, se pueden usar como tipo `T` en esta interfaz gen√©rica.

Esto forma la base del `patr√≥n Strategy`, ya que cada implementaci√≥n concreta de `PaymentStrategy<T>` define c√≥mo
manejar su tipo de pago particular, respetando la misma estructura com√∫n (validar y pagar).

### Estrategias concretas de pago

Cada una de las clases que veremos a continuaci√≥n representa una estrategia concreta dentro del patr√≥n Strategy. Todas
implementan la interfaz gen√©rica PaymentStrategy<T>, que exige dos m√©todos:

- `validatePayment(T request)`: realiza validaciones sobre la solicitud de pago.
- `pay(T request)`: ejecuta la l√≥gica de pago y devuelve un PaymentResponse.

Estas clases se anotan con @Component para que Spring las detecte y gestione como beans, y adem√°s con @Slf4j para
permitir el uso de logging con log.info(), log.error(), etc.

Veamos cada implementaci√≥n.

### üìå PayPalPaymentStrategy

````java

@Slf4j
@Component("payPal")
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {
    @Override
    public boolean validatePayment(PayPalPaymentRequest request) {
        if (Objects.isNull(request.paypalEmail()) || !request.paypalEmail().contains("@")) {
            log.error("Email de PayPal inv√°lido");
            return false;
        }

        if (Objects.isNull(request.password()) || request.password().length() < 6) {
            log.error("Contrase√±a debe tener al menos 6 caracteres");
            return false;
        }

        log.info("Datos de la cuenta de PayPal validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(PayPalPaymentRequest request) {
        log.info("Procesando pago S/{} con PayPal para el usuario {}", request.amount(), request.paypalEmail());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "PP-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con PayPal");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con PayPal");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia concreta se encarga de procesar pagos mediante cuentas PayPal.

- Validaci√≥n:
    - Verifica que el email tenga formato v√°lido (contenga @).
    - La contrase√±a debe tener al menos 6 caracteres.

- Proceso de pago:
    - Simula una espera (Thread.sleep) para representar el tiempo de procesamiento.
    - Genera un transactionId con prefijo PP-.
    - Retorna un PaymentResponse exitoso.

> üìå `Nota t√©cnica`: El identificador del bean en el contenedor de Spring es `"payPal`", ya que as√≠ se defini√≥
> expl√≠citamente con `@Component("payPal")`. Esto ser√° importante al momento de recuperar din√°micamente las estrategias.

### üìå BankTransferPaymentStrategy

````java

@Slf4j
@Component("bankTransfer")
public class BankTransferPaymentStrategy implements PaymentStrategy<BankTransferPaymentRequest> {

    @Override
    public boolean validatePayment(BankTransferPaymentRequest request) {
        if (Objects.isNull(request.accountHolder()) || request.accountHolder().isBlank()) {
            log.error("Titular de la cuenta es requerido");
            return false;
        }

        if (Objects.isNull(request.bankName()) || request.bankName().isBlank()) {
            log.error("El nombre del banco es requerido");
            return false;
        }

        if (Objects.isNull(request.accountNumber()) || request.accountNumber().isBlank()) {
            log.error("N√∫mero de cuenta es requerido");
            return false;
        }

        log.info("Datos para la transferencia bancaria validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(BankTransferPaymentRequest request) {
        log.info("Pagando S/{} mediante transferencia bancaria al banco {}", request.amount(), request.bankName());
        try {
            Thread.sleep(Duration.ofMillis(800));
            String transactionId = "BT-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con Transferencia Bancaria");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con Transferencia Bancaria");
            throw new RuntimeException(e);
        }
    }
}
````

Esta estrategia implementa pagos mediante transferencia bancaria.

- Validaci√≥n:
    - Todos los campos relevantes deben estar presentes: titular de cuenta, nombre del banco y n√∫mero de cuenta.

- Proceso de pago:
    - Simula un retardo para reflejar el tiempo de procesamiento.
    - Genera un `transactionId` con prefijo `BT-`.
    - Retorna una respuesta de √©xito.

> üìå `Buenas pr√°cticas`:
> Los campos se validan con `Objects.isNull()` y `isBlank()`, garantizando que no se procesen datos incompletos o
> err√≥neos.

### üìå CreditCardPaymentStrategy

````java

@Slf4j
@Component("creditCard")
public class CreditCardPaymentStrategy implements PaymentStrategy<CreditCardPaymentRequest> {

    @Override
    public boolean validatePayment(CreditCardPaymentRequest request) {
        if (Objects.isNull(request.cardNumber()) || request.cardNumber().trim().length() < 16) {
            log.error("N√∫mero de tarjeta inv√°lido");
            return false;
        }

        if (Objects.isNull(request.expiryDate()) || request.expiryDate().isBlank()) {
            log.error("Fecha de expiraci√≥n requerida");
            return false;
        }

        if (Objects.isNull(request.cvv()) || request.cvv().trim().length() != 3) {
            log.error("Cvv inv√°lido");
            return false;
        }

        log.info("Datos de la tarjeta cr√©dito validados correctamente");
        return true;
    }

    @Override
    public PaymentResponse pay(CreditCardPaymentRequest request) {
        log.info("Procesando pago S/{} con tarjeta de cr√©dito {}", request.amount(), request.cardNumber());
        try {
            Thread.sleep(Duration.ofSeconds(1));
            String transactionId = "CC-" + System.currentTimeMillis();
            return new PaymentResponse(true, transactionId, "Pago procesado exitosamente con tarjeta");
        } catch (InterruptedException e) {
            log.error("Error en el procesamiento de pago con tarjeta");
            throw new RuntimeException(e);
        }
    }
}
````

Esta clase maneja los pagos con tarjeta de cr√©dito.

- Validaci√≥n:
    - El n√∫mero de tarjeta debe tener al menos 16 caracteres.
    - La fecha de expiraci√≥n no puede estar vac√≠a.
    - El CVV debe tener exactamente 3 d√≠gitos.

- Proceso de pago:
    - Simula la espera con Thread.sleep(1000ms).
    - Genera un identificador con prefijo `CC-`.
    - Retorna un PaymentResponse indicando √©xito.

> üìå `Observaci√≥n`: En un sistema real, estas validaciones ser√≠an mucho m√°s rigurosas e incluir√≠an cifrado, tokens de
> sesi√≥n, y comunicaci√≥n con una pasarela de pagos (como Stripe, PayPal SDK, etc.). Sin embargo, este ejemplo est√°
> dise√±ado con fines pedag√≥gicos.

### üß† Consideraciones sobre el uso de gen√©ricos

Cada clase implementa la interfaz Strategy de forma tipada, como por ejemplo:

````java
public class PayPalPaymentStrategy implements PaymentStrategy<PayPalPaymentRequest> {/*code*/
}
````

Esto tiene dos beneficios importantes:

1. `Tipo seguro en tiempo de compilaci√≥n`: El m√©todo `pay()` s√≥lo aceptar√° objetos del tipo correspondiente
   (`PayPalPaymentRequest`, por ejemplo). No es necesario hacer cast ni validaciones adicionales.
2. `Separaci√≥n clara de responsabilidades`: Cada estrategia solo conoce y manipula su propio tipo de solicitud de pago,
   manteniendo bajo acoplamiento y alta cohesi√≥n.

Este enfoque ser√° especialmente √∫til cuando expliquemos el uso de `Map<String, PaymentStrategy<?>>` en la f√°brica de
estrategias, donde se gestionan de forma din√°mica.

### üè≠ PaymentStrategyFactory: Resolviendo estrategias din√°micamente

La clase `PaymentStrategyFactory` act√∫a como un punto centralizado para obtener la estrategia adecuada seg√∫n el tipo de
pago solicitado. Permite desacoplar la l√≥gica de selecci√≥n de estrategia del resto del sistema, haciendo que el c√≥digo
sea m√°s limpio, extensible y abierto a nuevas formas de pago sin modificar c√≥digo existente.

### üéØ Prop√≥sito

Esta clase permite, por ejemplo, que al recibir el tipo de pago `payPal`, devuelva la instancia correspondiente de
`PayPalPaymentStrategy`, lista para ser usada.

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class PaymentStrategyFactory {

    private final Map<String, PaymentStrategy<? extends PaymentRequest>> paymentStrategies;

    @SuppressWarnings("unchecked")
    public <T extends PaymentRequest> PaymentStrategy<T> getPaymentStrategy(String paymentType) {
        PaymentStrategy<? extends PaymentRequest> strategy = this.paymentStrategies.get(paymentType);
        if (Objects.isNull(strategy)) {
            throw new IllegalArgumentException("Estrategia no soportada: " + paymentType);
        }
        return (PaymentStrategy<T>) strategy;
    }

    public List<String> getSupportedPaymentTypes() {
        return this.paymentStrategies.keySet().stream().sorted().toList();
    }
}
````

### üîÅ Inyecci√≥n de estrategias como `Map<String, PaymentStrategy<? extends PaymentRequest>>`

`Spring Boot` es capaz de inyectar autom√°ticamente todas las implementaciones de
`PaymentStrategy<? extends PaymentRequest>` registradas como `@Component` en el contexto de la aplicaci√≥n,
organiz√°ndolas en un Map, donde:

- `Key`: es el nombre del bean (`payPal`, `creditCard`, etc.), definido con `@Component("nombre")`.
- `Value`: es la instancia concreta de la estrategia (`PaymentStrategy<PayPalPaymentRequest>`, por ejemplo).

Esto evita tener que usar `@Qualifier` uno por uno o manejar condicionales expl√≠citos como `if (...)`.

### üß† ¬øPor qu√© `? extends PaymentRequest`?

El tipo gen√©rico `? extends PaymentRequest` permite que el Map almacene `estrategias con diferentes tipos espec√≠ficos`,
siempre que esos tipos `extiendan` de `PaymentRequest`. As√≠ se garantiza flexibilidad y compatibilidad con las
estrategias concretas definidas anteriormente.

En t√©rminos pr√°cticos, esto permite almacenar en un solo Map:

````bash
PaymentStrategy<PayPalPaymentRequest>,
PaymentStrategy<CreditCardPaymentRequest>,
PaymentStrategy<BankTransferPaymentRequest> 
````

Todos ellos son v√°lidos porque sus `T` cumplen `T extends PaymentRequest`.

### ‚öôÔ∏è M√©todo getPaymentStrategy(...)

Este m√©todo recupera la estrategia deseada a partir del tipo de pago (`paymentType`), realizando un cast controlado al
tipo gen√©rico correcto `(PaymentStrategy<T>)`.

- El cast es seguro en la pr√°ctica porque el dise√±o de la aplicaci√≥n garantiza que el `paymentType` mapea al tipo
  correcto de estrategia.
- La anotaci√≥n `@SuppressWarnings("unchecked")` es necesaria porque el compilador no puede verificar completamente este
  cast en tiempo de compilaci√≥n debido a la borradura de tipos en Java.

Este m√©todo es una `pieza clave para la integraci√≥n polim√≥rfica y flexible del patr√≥n Strategy` en el servicio
principal.

### üìö M√©todo auxiliar: getSupportedPaymentTypes()

Este m√©todo devuelve una lista ordenada de los identificadores de los m√©todos de pago disponibles. Es √∫til para:

- Documentar o mostrar en una UI qu√© opciones de pago est√°n habilitadas.
- Validaciones previas.
- Tests automatizados.

### ‚úÖ Ventajas de este enfoque

- `Abierto a extensi√≥n`: agregar una nueva estrategia s√≥lo requiere crear una clase con `@Component("nuevoTipo")`, sin
  modificar la f√°brica.
- `Elimina condicionales`: se evita el uso de switch, if-else, o inyecciones manuales.
- `Seguridad de tipos con flexibilidad`: el uso de gen√©ricos y `? extends` permite mantener la seguridad de tipo sin
  sacrificar dinamismo.
- `Centraliza el acceso a las estrategias`: si se necesita aplicar reglas o validaciones adicionales, pueden colocarse
  aqu√≠.

### üì• RawPaymentRequest: Entrada gen√©rica desde el cliente

Este record representa la solicitud gen√©rica de pago enviada desde un cliente externo, como por ejemplo una API REST o
una interfaz gr√°fica. Es una estructura flexible y din√°mica, ya que encapsula tanto los datos comunes como los
espec√≠ficos del m√©todo de pago.

````java
public record RawPaymentRequest(@NotBlank(message = "El Id del pedido es obligatorio")
                                String orderId,

                                @NotNull(message = "El monto no puede ser nulo")
                                @Positive(message = "El monto debe ser mayor que cero")
                                Double amount,

                                @NotBlank(message = "La moneda es obligatoria")
                                String currency,

                                @NotBlank(message = "El tipo de pago es obligatorio")
                                String paymentType,

                                @NotNull(message = "Los datos de pago son obligatorios")
                                Map<String, Object> paymentData) {
}
````

üîë Campos

- `orderId`: identificador del pedido.
- `amount`: monto del pago.
- `currency`: moneda (USD, PEN, etc.).
- `paymentType`: tipo de m√©todo de pago (`creditCard`, `payPal`, etc.).
- `paymentData`: mapa de datos espec√≠ficos del m√©todo de pago (por ejemplo, `cardNumber`, `cvv`).

‚úÖ Validaciones

- Se usan anotaciones de `Bean Validation` (JSR-380):
- `@NotBlank`, `@NotNull`, `@Positive`: aseguran que los datos requeridos no est√©n vac√≠os o sean inv√°lidos.
- Estas validaciones se aplican autom√°ticamente al recibir la petici√≥n en un `@RestController` cuando se usa `@Valid`.

üìå Ventaja clave

Al representar los datos como un `Map<String, Object>`, `RawPaymentRequest` permite modelar una estructura flexible y
extensible sin acoplarse desde el inicio a una estrategia concreta. Esto facilita la separaci√≥n entre:

- Lo que env√≠a el cliente.
- Lo que necesita el sistema internamente para procesar el pago.

### üîÑ PaymentRequestConverter: Adaptador din√°mico de datos

Esta clase se encarga de convertir un `RawPaymentRequest` en una instancia concreta de `PaymentRequest`. Esto es un
ejemplo del `patr√≥n Adapter`, donde se traduce una estructura flexible en un tipo fuerte, que el sistema puede procesar
de forma segura.

Se usa un `switch` sobre el campo `paymentType` para determinar qu√© tipo de `PaymentRequest` construir. Esto mantiene
el c√≥digo legible y f√°cilmente ampliable.

> üìå Nota: Este switch est√° encapsulado aqu√≠ a prop√≥sito. Aunque el `patr√≥n Strategy` evita condicionales en la l√≥gica
> de negocio, aqu√≠ es aceptable y necesario porque:
>
> - El sistema necesita saber qu√© tipo de DTO construir antes de aplicar una estrategia.
> - Este es el √∫nico punto donde se reconoce el tipo concreto antes del polimorfismo.

````java

@Slf4j
@Component
public class PaymentRequestConverter {

    public PaymentRequest createPaymentRequest(RawPaymentRequest rawRequest) {
        log.info("Convirtiendo RawPaymentRequest a {}", rawRequest.paymentType());
        return switch (rawRequest.paymentType()) {
            case "bankTransfer" -> this.createBankTransferRequest(rawRequest);
            case "creditCard" -> this.createCreditCardRequest(rawRequest);
            case "payPal" -> this.createPayPalRequest(rawRequest);
            default -> throw new IllegalArgumentException("Tipo de pago no soportado: " + rawRequest.paymentType());
        };
    }

    private CreditCardPaymentRequest createCreditCardRequest(RawPaymentRequest rawRequest) {
        return new CreditCardPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "cardNumber"),
                this.getTypedValue(rawRequest.paymentData(), "expiryDate"),
                this.getTypedValue(rawRequest.paymentData(), "cvv"));
    }

    private PayPalPaymentRequest createPayPalRequest(RawPaymentRequest rawRequest) {
        return new PayPalPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "paypalEmail"),
                this.getTypedValue(rawRequest.paymentData(), "password"));
    }

    private BankTransferPaymentRequest createBankTransferRequest(RawPaymentRequest rawRequest) {
        return new BankTransferPaymentRequest(
                rawRequest.orderId(),
                rawRequest.amount(),
                rawRequest.currency(),
                this.getTypedValue(rawRequest.paymentData(), "accountHolder"),
                this.getTypedValue(rawRequest.paymentData(), "bankName"),
                this.getTypedValue(rawRequest.paymentData(), "accountNumber"));
    }

    private String getTypedValue(Map<String, Object> data, String key) {
        return data != null ? (String) data.get(key) : null;
    }
}
````

### ‚úÖ Ventajas del dise√±o

- `Separaci√≥n de responsabilidades`: esta clase se encarga solo de traducir la entrada, no de procesar pagos.
- `Centralizaci√≥n del mapeo`: evita que la l√≥gica de construcci√≥n de DTOs est√© dispersa en otras partes del sistema.
- `Extensibilidad`: agregar un nuevo m√©todo de pago solo requiere un nuevo case en el switch y un m√©todo de construcci√≥n
  correspondiente.

### üß† PaymentServiceImpl: Cliente y Contexto del patr√≥n Strategy

En el contexto del `patr√≥n Strategy`, normalmente se distingue entre dos roles:

- `Cliente`: decide qu√© estrategia usar seg√∫n cierta l√≥gica externa.
- `Contexto`: mantiene una referencia a la estrategia y se encarga de ejecutarla.

Sin embargo, en esta implementaci√≥n en `Spring Boot`, la clase `PaymentServiceImpl` combina ambos roles de manera
efectiva:

- Como `cliente`, decide qu√© estrategia aplicar, utilizando la clase `PaymentStrategyFactory` para obtener la
  implementaci√≥n adecuada en tiempo de ejecuci√≥n, bas√°ndose en el tipo de pago (`paymentType`).


- Como `contexto`, ejecuta los m√©todos `validatePayment(...)` y `pay(...)` de la estrategia seleccionada, encapsulando
  as√≠ el comportamiento variable.

Esta fusi√≥n de roles es completamente v√°lida y muy com√∫n en aplicaciones modernas. Se evita la creaci√≥n de una clase
adicional como `PaymentContext`, manteniendo el dise√±o m√°s simple, cohesionado y enfocado en la funcionalidad real.

üëâ Esta decisi√≥n de dise√±o respeta el `patr√≥n Strategy` y al mismo tiempo adapta su estructura a un contexto pragm√°tico,
donde el uso de gen√©ricos y la inyecci√≥n de dependencias de Spring permiten implementar el patr√≥n de forma m√°s fluida y
eficiente.

````java
public interface PaymentService {
    PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest);

    List<String> getSupportedPaymentTypes();
}
````

Define las operaciones p√∫blicas que el servicio expone:

- `processPayment(...)`: proceso principal para ejecutar un pago.
- `getSupportedPaymentTypes()`: obtiene todos los tipos de pago que el sistema soporta, a partir de las estrategias
  registradas.

Esta interfaz permite aplicar el principio de `Inversi√≥n de Dependencias (I de SOLID)`, desacoplando el controller
de la implementaci√≥n concreta (`PaymentServiceImpl`).

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class PaymentServiceImpl implements PaymentService {

    private final PaymentStrategyFactory strategyFactory;
    private final PaymentRequestConverter requestConverter;

    @Override
    public PaymentResponse processPayment(RawPaymentRequest rawPaymentRequest) {
        PaymentRequest paymentRequest = this.requestConverter.createPaymentRequest(rawPaymentRequest);
        return this.applyPaymentStrategy(rawPaymentRequest.paymentType(), paymentRequest);
    }

    @Override
    public List<String> getSupportedPaymentTypes() {
        return this.strategyFactory.getSupportedPaymentTypes();
    }

    private <T extends PaymentRequest> PaymentResponse applyPaymentStrategy(String paymentType, T request) {
        PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType);
        log.info("Estrategia obtenida {}", strategy.getClass().getSimpleName());

        if (!strategy.validatePayment(request)) {
            log.error("Error al validar el pago");
            throw new IllegalArgumentException("No se pudo procesar el pago");
        }

        return strategy.pay(request);
    }
}
````

- El objeto `strategyFactory` se encarga de resolver la estrategia adecuada en base al tipo de pago.
- El objeto `requestConverter` convierte el `RawPaymentRequest` (solicitud gen√©rica del cliente) en una implementaci√≥n
  concreta de `PaymentRequest` (como `PayPalPaymentRequest`, `CreditCardPaymentRequest`, etc.).
- El m√©todo `applyPaymentStrategy(String paymentType, T request)` es la clave del comportamiento din√°mico del
  `patr√≥n Strategy`. Explicamos por partes:
    - ‚úÖ Uso de `<T extends PaymentRequest>`
        - Permite que este m√©todo funcione con cualquier tipo de solicitud concreta (`T`) que implemente
          `PaymentRequest`.
        - Gracias a esto, se puede trabajar con tipos seguros como` PaymentStrategy<CreditCardPaymentRequest>`, sin
          necesidad de hacer cast expl√≠cito fuera de la f√°brica.
        - En el siguiente c√≥digo `PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType)`
          Se resuelve el bean correspondiente usando la clave `payPal`, `creditCard`, etc.
    - Este m√©todo encapsula la l√≥gica completa de aplicar una estrategia. Adem√°s, mantiene el c√≥digo polim√≥rfico y
      seguro en tiempo de compilaci√≥n.

### ‚úÖ Ventajas de este dise√±o

- `Desacoplamiento total`: el servicio no conoce las clases concretas como `CreditCardPaymentStrategy`. Solo trabaja
  con la interfaz `PaymentStrategy<T>`.
- `Extensibilidad`: agregar un nuevo m√©todo de pago no requiere modificar este servicio.
- `Centralizaci√≥n de la l√≥gica de validaci√≥n y pago`: se maneja todo a trav√©s de la estrategia concreta, permitiendo
  pruebas y mantenimiento m√°s sencillos.

### üåê PaymentController: Punto de entrada REST

Esta clase es un controlador REST que expone la funcionalidad del sistema de pagos al exterior. Utiliza la capa de
servicio (`PaymentService`) para delegar la l√≥gica de negocio, siguiendo el principio de responsabilidad √∫nica
(SRP de SOLID).

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/payments")
public class PaymentController {

    private final PaymentService paymentService;

    @GetMapping(path = "/supported-types")
    public ResponseEntity<List<String>> getSupportedPaymentTypes() {
        return ResponseEntity.ok(this.paymentService.getSupportedPaymentTypes());
    }

    @PostMapping
    public ResponseEntity<PaymentResponse> processPayment(@Valid @RequestBody RawPaymentRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(this.paymentService.processPayment(request));
    }
}
````

### üìã GET `/api/v1/payments/supported-types`: Tipos de pago disponibles

Este endpoint expone una lista de los tipos de pago actualmente habilitados en el sistema. Esta informaci√≥n es √∫til
para:

- Interfaces de usuario que deben listar los m√©todos disponibles.
- Validaciones previas en clientes externos.
- Pruebas de integraci√≥n automatizadas.

Se obtiene a trav√©s del m√©todo `getSupportedPaymentTypes()` de `PaymentService`, que a su vez lo delega a la f√°brica de
estrategias.

### üì• POST `/api/v1/payments`: Procesar un pago

Este endpoint permite recibir una solicitud de pago en formato JSON y procesarla utilizando la estrategia adecuada.

- `@RequestBody`: indica que el cuerpo de la solicitud se mapea autom√°ticamente a un objeto Java (`RawPaymentRequest`).
- `@Valid`: activa las validaciones declaradas en los campos del record, como `@NotBlank`, `@Positive`, etc.
- Retorna una respuesta `201 Created` con el cuerpo `PaymentResponse`, que indica el resultado del procesamiento.

### ‚úÖ Buenas pr√°cticas aplicadas

- `Delegaci√≥n total al servicio`: el controlador no contiene l√≥gica de negocio.
- `Validaci√≥n autom√°tica`: se aprovecha Bean Validation con `@Valid` en el DTO de entrada.
- `Uso de ResponseEntity`: permite controlar el c√≥digo HTTP de retorno y el cuerpo de la respuesta.
- `Cohesi√≥n`: todas las operaciones est√°n relacionadas con pagos y agrupadas bajo la misma URL base
  (`/api/v1/payments`).

### Realizando pruebas

Listamos los m√©todos de pago soportados.

````bash
$ curl -v http://localhost:8080/api/v1/payments/supported-types | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Wed, 16 Jul 2025 23:37:35 GMT
<
[
  "bankTransfer",
  "creditCard",
  "payPal"
]
````

Realizando pago con tarjeta de cr√©dito.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"creditCard\", \"paymentData\": {\"cardNumber\": \"1234567890123456\", \"expiryDate\": \"12/25\", \"cvv\": \"123\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 04:59:15 GMT
<
{
  "success": true,
  "transactionId": "CC-1752728355233",
  "message": "Pago procesado exitosamente con tarjeta"
}
````

Realizando pago con paypal.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martin@gmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:01:08 GMT
<
{
  "success": true,
  "transactionId": "PP-1752728468436",
  "message": "Pago procesado exitosamente con PayPal"
}
````

Realizando pago con transferencia bancaria.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"bankTransfer\", \"paymentData\": {\"accountHolder\": \"Milagros\", \"bankName\": \"BCP\", \"accountNumber\": \"789-256325632587\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:03:24 GMT
<
{
  "success": true,
  "transactionId": "BT-1752728604942",
  "message": "Pago procesado exitosamente con Transferencia Bancaria"
}
````

Verificando validaci√≥n de campos.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"orderId\": \"order-001\", \"amount\": 150.00, \"currency\": \"S/\", \"paymentType\": \"payPal\", \"paymentData\": {\"paypalEmail\": \"martingmail.com\", \"password\": \"123456\"}}" http://localhost:8080/api/v1/payments | jq
>
< HTTP/1.1 500
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Thu, 17 Jul 2025 05:07:49 GMT
< Connection: close
<

{
  "timestamp": "2025-07-17T05:07:49.512+00:00",
  "status": 500,
  "error": "Internal Server Error",
  "message": "No se pudo procesar el pago",
  "path": "/api/v1/payments"
} 
````

````bash
2025-07-17T00:07:49.498-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.c.PaymentRequestConverter  : Convirtiendo RawPaymentRequest a payPal
2025-07-17T00:07:49.500-05:00  INFO 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Estrategia obtenida PayPalPaymentStrategy
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PayPalPaymentStrategy    : Email de PayPal inv√°lido
2025-07-17T00:07:49.500-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] d.m.p.s.b.s.p.s.PaymentServiceImpl       : Error al validar el pago
2025-07-17T00:07:49.502-05:00 ERROR 6540 --- [design-patterns] [nio-8080-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.IllegalArgumentException: No se pudo procesar el pago] with root cause

java.lang.IllegalArgumentException: No se pudo procesar el pago
````

## üéØ Resumen de roles del patr√≥n Strategy en el proyecto: Estrategias de pago

| Rol del patr√≥n        | Clase que lo representa                                           |
|-----------------------|-------------------------------------------------------------------|
| **Strategy**          | `PaymentStrategy<T extends PaymentRequest>`                       |
| **ConcreteStrategy**  | `CreditCardPaymentStrategy`, `PayPalPaymentStrategy`, etc.        |
| **Context**           | `PaymentServiceImpl` (ejecuta la estrategia)                      |
| **Cliente**           | `PaymentServiceImpl` (decide qu√© estrategia usar)                 |
| **Invocador externo** | `PaymentController` (invoca el servicio, sin conocer estrategias) |

### ‚úÖ Observaci√≥n final

`PaymentServiceImpl` cumple con dos responsabilidades del patr√≥n Strategy, de forma intencional y v√°lida:

- `Cliente` ‚Üí decide qu√© estrategia usar (usando `PaymentStrategyFactory`).
- `Contexto` ‚Üí ejecuta la estrategia seleccionada.

Este enfoque es limpio, flexible y fiel al patr√≥n, con una adaptaci√≥n pragm√°tica para aplicaciones modernas usando
`Spring Boot`.

### üß© ¬øC√≥mo ser√≠a un contexto expl√≠cito (PaymentContext)?

Veamos c√≥mo ser√≠a una implementaci√≥n fiel al `patr√≥n Strategy cl√°sico` en `Spring Boot`, incluyendo un `Contexto`
expl√≠cito, es decir, una clase `PaymentContext` que separe claramente los roles de `cliente` y `contexto`.

````java
public class PaymentContext<T extends PaymentRequest> {
    private final PaymentStrategy<T> strategy;

    public PaymentContext(PaymentStrategy<T> strategy) {
        this.strategy = strategy;
    }

    public PaymentResponse execute(T request) {
        if (!strategy.validatePayment(request)) {
            throw new IllegalArgumentException("No se pudo validar el pago");
        }
        return strategy.pay(request);
    }
}
````

Donde la clase `PaymentContext`:

- Mantiene una referencia a una estrategia concreta (`PaymentStrategy<T>`).
- Expone un m√©todo gen√©rico para ejecutar la estrategia (`validatePayment(...)` y `pay(...)`).
- Es utilizada por el `PaymentServiceImpl` (`cliente`), que decide cu√°l estrategia usar y se la pasa al `contexto`.

> üëâ Importante: La clase `PaymentContext` no debe ser `@Component` ni singleton, ya que mantener la estrategia como
> estado interno (por `constructor` o `setter`) puede causar condiciones de carrera en entornos concurrentes.
>
> Si `PaymentContext` es singleton y la estrategia se establece por setter, un hilo podr√≠a cambiar la estrategia
> mientras otro la est√° usando, generando comportamiento incorrecto o inestable.

El servicio `PaymentServiceImpl` como cliente quedar√≠a m√°s o menos as√≠:

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class PaymentServiceImpl implements PaymentService {

    private final PaymentStrategyFactory strategyFactory;

    @Override
    public <T extends PaymentRequest> PaymentResponse processPayment(String paymentType, T request) {
        PaymentStrategy<T> strategy = this.strategyFactory.getPaymentStrategy(paymentType);

        //La clase PaymentContext no puede ser singleton, y por tanto, no debe tener @Component.
        PaymentContext<T> context = new PaymentContext<>(strategy);
        return context.execute(request);
    }
}
````

### üìå Nota final

> En aplicaciones reales con `Spring Boot`, evitar una clase `PaymentContext` (como contexto) expl√≠cita mejora la
> eficiencia, ya que de otro modo se requerir√≠a crear una nueva instancia por cada solicitud. Adem√°s, delegar la
> ejecuci√≥n directamente al servicio permite mantenerlo como un `@Service singleton` seguro y sin estado mutable.

---

# Template Method

## üéØ Ejemplo 01: Procesamiento gen√©rico de archivos estructurados en una API extensible

En muchas aplicaciones empresariales es com√∫n recibir archivos de distintos formatos que deben ser procesados
autom√°ticamente. Estos archivos suelen contener datos estructurados ‚Äîcomo transacciones, registros de clientes o
productos‚Äî que requieren una serie de pasos antes de ser persistidos: validaciones de formato, reglas de negocio,
transformaciones y finalmente almacenamiento en base de datos.

El objetivo de esta soluci√≥n es construir una API REST extensible y desacoplada que permita procesar distintos tipos de
archivos (.txt, .csv, .json, etc.) aplicando siempre el mismo flujo general, pero permitiendo personalizar los pasos
espec√≠ficos seg√∫n el tipo de archivo.

Para lograr esto, se utiliza el `patr√≥n de dise√±o Template Method`, que define una estructura fija para el
procesamiento, permitiendo que las subclases concreten sus propios pasos seg√∫n el formato del archivo. El resultado es
una arquitectura limpia, reutilizable y f√°cil de extender a nuevos tipos de archivos sin duplicar l√≥gica com√∫n.

### üì¶ DTOs y estructuras auxiliares del sistema

En este m√≥dulo se definen los objetos de transferencia de datos (DTOs) que encapsulan la informaci√≥n necesaria durante
todo el proceso de carga, validaci√≥n, conversi√≥n y resultado del procesamiento de archivos. Estas estructuras permiten
mantener una separaci√≥n clara entre la l√≥gica del negocio y los datos manejados.

El DTO `ProcessResult` representa el resultado final del procesamiento de un archivo. Encapsula tanto los casos
exitosos como los fallidos e incluye metadatos relevantes.

> üìå `Observaci√≥n`: El uso de `@JsonInclude.NON_NULL` permite omitir campos nulos durante la serializaci√≥n JSON,
> haciendo m√°s clara la respuesta del `API REST`.

````java

@JsonInclude(JsonInclude.Include.NON_NULL)
public record ProcessResult(String batchId,
                            boolean success,
                            String errorMessage,
                            int totalRecords,
                            int processedRecords,
                            int invalidRecords,
                            FileStorageInfo sourceInfo) {

    public static ProcessResult success(String batchId, int total, int processed, int invalid, FileStorageInfo sourceInfo) {
        return new ProcessResult(batchId, true, null, total, processed, invalid, sourceInfo);
    }

    public static ProcessResult failure(String batchId, String errorMessage, FileStorageInfo sourceInfo) {
        return new ProcessResult(batchId, false, errorMessage, 0, 0, 0, sourceInfo);
    }
}
````

El `FileStorageInfo` contiene informaci√≥n sobre la ubicaci√≥n y origen del archivo procesado. Este objeto permite
desacoplar la l√≥gica de procesamiento del mecanismo de carga de archivos.

````java
public record FileStorageInfo(String location,
                              String filename,
                              StorageType storageType) {

    public static FileStorageInfo create(String location, String filename, StorageType storageType) {
        return new FileStorageInfo(location, filename, storageType);
    }
}
````

El `BusinessValidationResult<T extends ParsedRecord>` agrupa los resultados de validaci√≥n a nivel de lote. Es decir,
representa el resultado de la validaci√≥n de todos los registros de un archivo:

````java
public record BusinessValidationResult<T extends ParsedRecord>(List<T> validRecords,
                                                               int invalidCount) {
}
````

El `ValidationResult` representa el resultado de la validaci√≥n individual de un registro.

````java
public record ValidationResult(boolean valid,
                               String errorMessage) {

    public static ValidationResult success() {
        return new ValidationResult(true, null);
    }

    public static ValidationResult failure(String errorMessage) {
        return new ValidationResult(false, errorMessage);
    }
}
````

El `TxtRecord` es una implementaci√≥n concreta de `ParsedRecord` para representar registros provenientes de archivos
`.txt` delimitados.

````java
public record TxtRecord(String id,
                        String accountNumber,
                        double amount,
                        LocalDateTime transactionDate,
                        String description) implements ParsedRecord {
}
````

### Detalle de la interfaz ParsedRecord

Es una `interfaz marcador` (marker interface), sin m√©todos, utilizada para establecer un contrato com√∫n entre todos los
tipos de registros parseados desde archivos.

Su uso permite que el sistema maneje gen√©ricamente registros de distintos formatos (`TxtRecord`, `CsvRecord`, etc.) sin
acoplarse a un tipo concreto.

````java
public interface ParsedRecord {
}
````

üìå En resumen

> Estos DTOs permiten mantener tipado fuerte, flexibilidad y claridad estructural en todo el flujo del patr√≥n
> `Template Method`. Separan claramente los datos, la l√≥gica de validaci√≥n, y el resultado final del procesamiento,
> aline√°ndose con los principios de dise√±o limpio y abierto para extensi√≥n, cerrado para modificaci√≥n (`OCP`).

### ‚öôÔ∏è Clases auxiliares y enums del sistema

Estas clases complementarias proporcionan la infraestructura necesaria para el manejo de excepciones, tipos de archivos
y mecanismos de almacenamiento. Aunque no forman parte directa del patr√≥n `Template Method`, habilitan su
funcionamiento ordenado y extensible.

La clase `FileProcessorException` es una excepci√≥n personalizada utilizada para representar errores internos en el
procesamiento de archivos. Hereda de `RuntimeException`, lo cual la hace `unchecked` (no requiere manejo obligatorio
con `try-catch`).

````java
public class FileProcessorException extends RuntimeException {
    public FileProcessorException(String message) {
        super(message);
    }
}
````

El `StorageType` es un enum que representa los diferentes tipos de almacenamiento de un archivo. Este valor se encapsula
dentro del DTO `FileStorageInfo` para tener trazabilidad del origen del archivo y aplicar l√≥gica especializada si se
necesitara.

````java
public enum StorageType {
    LOCAL,
    S3,
    AZURE_BLOB
}
````

El `FileType` es un enum que modela los tipos de archivo reconocidos por el sistema, junto con sus extensiones y MIME
types asociados.

````java

@Getter
public enum FileType {

    TXT("txt", "text/plain"),
    CSV("csv", "text/csv"),
    JSON("json", "application/json"),
    XML("xml", "application/xml");

    private final String extension;
    private final String mimeType;

    FileType(String extension, String mimeType) {
        this.extension = extension;
        this.mimeType = mimeType;
    }

    public static Optional<FileType> fromExtension(String extension) {
        return Arrays.stream(FileType.values())
                .filter(fileType -> fileType.getExtension().equalsIgnoreCase(extension))
                .findFirst();
    }

    public static Optional<FileType> fromMimeType(String mimeType) {
        return Arrays.stream(FileType.values())
                .filter(fileType -> fileType.getMimeType().equalsIgnoreCase(mimeType))
                .findFirst();
    }

}
````

üìò Resumen
> Aunque estas clases no son parte directa del patr√≥n `Template Method`, funcionan como soporte esencial para la
> robustez, extensibilidad y claridad del sistema. Separar conceptos como tipo de archivo, origen del almacenamiento y
> errores espec√≠ficos permite que el sistema sea mantenible, abierto a nuevos formatos y preparado para escenarios
> reales de uso.

### üß∞ FileUtils ‚Äì Utilidades para el manejo de archivos temporales

La clase `FileUtils` encapsula operaciones auxiliares relacionadas con el manejo de archivos durante el procesamiento.
No pertenece al patr√≥n `Template Method` en s√≠, pero ofrece funcionalidades de soporte necesarias para su implementaci√≥n
fluida.

````java

@Slf4j
@UtilityClass
public class FileUtils {

    public static Path retrieveAsTempFile(InputStream inputStream, String filename) {
        try (InputStream is = inputStream) {
            Path tempDir = Files.createTempDirectory("file_processor");
            Path fullPathTempFile = tempDir.resolve(filename);
            Files.copy(is, fullPathTempFile, StandardCopyOption.REPLACE_EXISTING);
            return fullPathTempFile;
        } catch (IOException e) {
            throw new FileProcessorException("Error al recuperar archivo temporal: " + e.getMessage());
        }
    }

    public static void deleteTempFile(Path path) {
        if (Objects.isNull(path)) {
            log.warn("El path es null. No hay archivo temporal qu√© eliminar");
            return;
        }

        Path parentTempDir = path.getParent();
        if (Objects.isNull(parentTempDir) || !Files.exists(parentTempDir)) {
            log.warn("El directorio temporal no existe: {}", parentTempDir);
            return;
        }

        try {
            Files.walk(parentTempDir)
                    .sorted(Comparator.reverseOrder()) // Elimina primero los archivos, luego los directorios
                    .forEach(pathTemp -> {
                        try {
                            Files.delete(pathTemp);
                            log.info("Eliminado: {}", pathTemp);
                        } catch (IOException e) {
                            log.warn("No se pudo eliminar: {}", pathTemp, e);
                        }
                    });
        } catch (IOException e) {
            log.warn("Error al recorrer/eliminar el directorio temporal: {}", parentTempDir, e);
        }
    }

    public static String generateFilename(String extension, String batchId) {
        return "%s_%d.%s".formatted(batchId, System.currentTimeMillis(), extension);
    }

    public static String getFileExtension(MultipartFile multipartFile) {
        String filename = multipartFile.getOriginalFilename();
        if (Objects.isNull(filename) || filename.isBlank() || hasNoExtension(filename)) {
            throw new FileProcessorException("El archivo no tiene un nombre o extensi√≥n v√°lida");
        }
        return filename.substring(filename.lastIndexOf(".") + 1);
    }

    public static boolean hasNoExtension(String filename) {
        return !Pattern.matches(".+\\.[a-zA-Z0-9]+", filename);
    }
}
````

üìò Resumen
> `FileUtils` es una clase auxiliar que abstrae la l√≥gica relacionada con la gesti√≥n de archivos temporales, generaci√≥n
> de nombres √∫nicos, y validaci√≥n de extensiones. Esta separaci√≥n refuerza el `principio de responsabilidad √∫nica`
> (`SRP`), mantiene limpio el flujo de procesamiento y favorece la reutilizaci√≥n.

### üóÉÔ∏è Servicio de almacenamiento de archivos: FileStorageService y LocalFileStorageService

Este componente encapsula la l√≥gica de almacenamiento y recuperaci√≥n de archivos antes de ser procesados. Aunque no
pertenece al n√∫cleo del patr√≥n `Template Method`, juega un rol esencial en su funcionamiento, ya que permite abstraer la
fuente y destino de los archivos, haciendo que el flujo de procesamiento se mantenga desacoplado del mecanismo f√≠sico de
almacenamiento.

````java
public interface FileStorageService {
    FileStorageInfo storeFile(MultipartFile multipartFile, String batchId);

    InputStream retrieveFileContent(FileStorageInfo info);
}
````

Esta interfaz define el contrato general para cualquier servicio de almacenamiento que permita:

1. `Guardar` un archivo recibido desde el cliente (`MultipartFile`) con un identificador de lote (`batchId`).
2. `Recuperar` su contenido como un `InputStream`, necesario para leer y procesar su contenido.

> üìå Ventaja de dise√±o: Permite seguir el `principio de inversi√≥n de dependencias (DIP)`. La clase `FileProcessor`
> depende de una abstracci√≥n (`FileStorageService`) y no de una implementaci√≥n concreta, facilitando pruebas,
> mantenimiento y extensibilidad (por ejemplo, para `S3` o `Azure Blob Storage`).

````java

@Slf4j
@Service
public class LocalFileStorageService implements FileStorageService {

    @Override
    public FileStorageInfo storeFile(MultipartFile multipartFile, String batchId) {
        try {
            Path storagePath = Path.of("M:", "temp_files");
            Files.createDirectories(storagePath);

            String extension = FileUtils.getFileExtension(multipartFile);
            String filename = FileUtils.generateFilename(extension, batchId);

            Path fullPath = storagePath.resolve(filename);
            Files.copy(multipartFile.getInputStream(), fullPath, StandardCopyOption.REPLACE_EXISTING);

            return FileStorageInfo.create(fullPath.toString(), filename, StorageType.LOCAL);
        } catch (IOException e) {
            log.error("Error al almacenar el archivo en local: {}", e.getMessage(), e);
            throw new FileProcessorException("Error al almacenar el archivo en local: %s".formatted(e.getMessage()));
        }
    }

    @Override
    public InputStream retrieveFileContent(FileStorageInfo info) {
        try {
            Path path = Path.of(info.location());
            return Files.newInputStream(path);
        } catch (IOException e) {
            log.error("No se pudo leer archivo local: {}", e.getMessage(), e);
            throw new FileProcessorException("No se pudo leer archivo local: " + e.getMessage());
        }
    }
}
````

Es la implementaci√≥n local del servicio de almacenamiento, basada en el sistema de archivos del servidor.

#### üîê M√©todo: storeFile(...)

Guarda f√≠sicamente el archivo en el disco dentro de un directorio temporal configurado (`M:/temp_files`). Utiliza
utilidades previamente definidas para:

- Obtener la extensi√≥n del archivo.
- Generar un nombre √∫nico usando el batchId.
- Copiar el contenido del MultipartFile al disco.

Devuelve un objeto `FileStorageInfo` con los metadatos del archivo (ubicaci√≥n, nombre, tipo de almacenamiento).

#### üîç M√©todo: retrieveFileContent(...)

Recibe un `FileStorageInfo` y abre un `InputStream` desde el path donde fue almacenado el archivo.

> üìå Importante: Este dise√±o desacopla completamente el lugar de almacenamiento del resto de la l√≥gica de
> procesamiento. Si ma√±ana decides usar `S3` o `Azure`, solo debes implementar otra clase que extienda
> `FileStorageService`.

üìò Resumen
> El servicio de almacenamiento act√∫a como una abstracci√≥n de la fuente de archivos, permitiendo que el sistema de
> procesamiento se mantenga independiente del origen f√≠sico. Este dise√±o sigue el
> `principio de Inversi√≥n de Dependencias` (`DIP`) y prepara al sistema para futuras extensiones sin necesidad de
> modificar la l√≥gica central.

### üß© Clase base abstracta: `FileProcessor<T extends ParsedRecord>`

La clase `FileProcessor<T>` es la plantilla base que implementa el patr√≥n de dise√±o `Template Method` en este sistema
de procesamiento de archivos. Su prop√≥sito es definir una secuencia fija de pasos que todos los procesadores de archivos
deben seguir, permitiendo a las subclases especializar solo aquellos pasos que var√≠an seg√∫n el tipo de archivo.

### üéØ Rol en el patr√≥n Template Method

Define el esqueleto del algoritmo de procesamiento de archivos en el m√©todo `processFile(...)`, delegando pasos
personalizables a m√©todos abstractos que deben ser implementados por subclases concretas (`TxtDelimitedProcessor`,
`CsvDelimitedProcessor`, etc.).

El m√©todo `processFile(...)` es el `template method` en s√≠. Es un m√©todo `final` (no se puede sobrescribir), que
implementa paso a paso el flujo completo de procesamiento de un archivo. Cada etapa se encuentra bien delimitada y est√°
acompa√±ada por registros de logs para trazabilidad.

````java

@Slf4j
@RequiredArgsConstructor
public abstract class FileProcessor<T extends ParsedRecord> {

    private final FileStorageService fileStorageService;

    public final ProcessResult processFile(MultipartFile multipartFile, String batchId) {
        log.info("=== Iniciando procesamiento de archivo ===");
        log.info("Archivo: {} - Batch ID: {} - Tama√±o: {}", multipartFile.getOriginalFilename(), batchId, multipartFile.getSize());
        Path pathTempFile = null;

        try {
            // Paso 1: Validar archivo a procesar (lanza excepci√≥n si falla)
            this.validateMultipartFile(multipartFile);
            log.info("Archivo {} validado correctamente", multipartFile.getOriginalFilename());

            // Paso 2: Almacenar el archivo y generar uno temporal
            FileStorageInfo fileStorageInfo = this.fileStorageService.storeFile(multipartFile, batchId);
            log.info("Archivo {} guardado con √©xito como {}", multipartFile.getOriginalFilename(), fileStorageInfo.filename());

            InputStream inputStream = this.fileStorageService.retrieveFileContent(fileStorageInfo);
            pathTempFile = FileUtils.retrieveAsTempFile(inputStream, fileStorageInfo.filename());
            log.info("Procesando archivo desde: {}", pathTempFile);

            // Paso 3: Validar estructura del archivo (ProcessResult si falla)
            ValidationResult structureValidation = this.validateFileStructure(pathTempFile);
            if (!structureValidation.valid()) {
                log.warn("Validaci√≥n de estructura fallida: {}", structureValidation.errorMessage());
                return ProcessResult.failure(batchId, "Validaci√≥n de estructura fallida: " + structureValidation.errorMessage(), fileStorageInfo);
            }

            // Paso 4: Procesar contenido l√≠nea por l√≠nea (ProcessResult si falla)
            List<T> parsedRecords = this.parseFileContent(pathTempFile);
            if (parsedRecords.isEmpty()) {
                log.warn("El archivo no contiene registros procesables");
                return ProcessResult.failure(batchId, "El archivo est√° vac√≠o o no contiene registros procesables", fileStorageInfo);
            }
            int totalRecords = parsedRecords.size();
            log.info("Se parsearon {} registros del archivo", totalRecords);

            // Paso 5: Validar datos del negocio (ProcessResult con advertencias)
            BusinessValidationResult<T> businessValidationResult = this.validateBusinessRules(parsedRecords);
            List<T> validRecords = businessValidationResult.validRecords();
            int invalidCount = businessValidationResult.invalidCount();

            if (invalidCount > 0) {
                log.warn("Se encontraron {} registros inv√°lidos de {}", invalidCount, totalRecords);
            }

            // Paso 6: Persistir en base de datos (ProcessResult si falla)
            ProcessResult result;
            if (!validRecords.isEmpty()) {
                log.info("Persistiendo {} registros v√°lidos en base de datos", validRecords.size());
                int processedRecords = this.storeRecords(validRecords, batchId);
                result = ProcessResult.success(batchId, totalRecords, processedRecords, invalidCount, fileStorageInfo);
                log.info("Se persistieron {} registros exitosamente", processedRecords);
            } else {
                log.warn("No se encontraron registros v√°lidos para almacenar");
                result = ProcessResult.failure(batchId, "No se encontraron registros v√°lidos para almacenar.", fileStorageInfo);
            }

            // Paso 7: Generar notificaci√≥n final
            this.generateProcessingReport(result, multipartFile);

            if (result.success()) {
                log.info("Procesamiento finalizado exitosamente. Registros procesados: {}", result.processedRecords());
            } else {
                log.warn("Procesamiento finalizado con errores. Motivo: {}", result.errorMessage());
            }
            return result;
        } finally {
            // Paso 8: Eliminar archivo temporal
            if (pathTempFile != null) {
                log.info("Limpiando archivo temporal: {}", pathTempFile);
                FileUtils.deleteTempFile(pathTempFile);
            }
        }
    }

    // ============== M√âTODOS CONCRETOS (comunes a todos los tipos) ==============
    protected void validateMultipartFile(MultipartFile multipartFile) {
        if (Objects.isNull(multipartFile) || multipartFile.isEmpty()) {
            throw new FileProcessorException("El archivo est√° vac√≠o o no fue enviado");
        }

        String filename = multipartFile.getOriginalFilename();
        if (Objects.isNull(filename) || filename.isBlank()) {
            throw new FileProcessorException("El nombre del archivo es inv√°lido");
        }

        if (FileUtils.hasNoExtension(filename)) {
            throw new FileProcessorException("El archivo no tiene una extensi√≥n v√°lida");
        }

        if (!this.expectedFileType().getExtension().equalsIgnoreCase(FileUtils.getFileExtension(multipartFile))) {
            throw new FileProcessorException("Se esperaba un archivo con extensi√≥n: " + this.expectedFileType().getExtension());
        }
    }

    protected void generateProcessingReport(ProcessResult result, MultipartFile multipartFile) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(formatter);

        String extension = FileUtils.getFileExtension(multipartFile);
        String status = this.determineProcessingStatus(result);

        StringBuilder report = new StringBuilder("=== REPORTE DE PROCESAMIENTO %s ===".formatted(extension));
        report.append("\n");
        report.append("Archivo Original: ").append(multipartFile.getOriginalFilename()).append("\n");
        report.append("Archivo Almacenado: ").append(result.sourceInfo().filename()).append("\n");
        report.append("Ubicaci√≥n: ").append(result.sourceInfo().location()).append("\n");
        report.append("Storage Type: ").append(result.sourceInfo().storageType()).append("\n");
        report.append("Batch ID: ").append(result.batchId()).append("\n");
        report.append("Fecha/Hora: ").append(timestamp).append("\n");
        report.append("Processor: ").append(this.getClass().getSimpleName()).append("\n");
        report.append("Total registros: ").append(result.totalRecords()).append("\n");
        report.append("Registros procesados: ").append(result.processedRecords()).append("\n");
        report.append("Registros inv√°lidos: ").append(result.invalidRecords()).append("\n");
        report.append("Estado: ").append(status);

        log.info("REPORTE {}:\n{}", extension, report);
    }

    // ============== M√âTODOS ABSTRACTOS (espec√≠ficos por tipo de archivo) ==============
    public abstract FileType expectedFileType();

    protected abstract ValidationResult validateFileStructure(Path path);

    protected abstract List<T> parseFileContent(Path path);

    protected abstract BusinessValidationResult<T> validateBusinessRules(List<T> parsedRecords);

    protected abstract int storeRecords(List<T> validRecords, String batchId);

    // ============== M√âTODOS PRIVADOS ==============
    private String determineProcessingStatus(ProcessResult result) {
        if (!result.success()) {
            return "Error";
        } else if (result.invalidRecords() > 0) {
            return "Exitoso con advertencias";
        } else {
            return "Exitoso";
        }
    }
}
````

üìò Resumen
> Esta clase base define el algoritmo gen√©rico para procesar cualquier tipo de archivo estructurado, desacoplando las
> partes invariantes de las variables. Gracias al patr√≥n `Template Method`, se garantiza un flujo uniforme y controlado,
> donde las diferencias de formato (`TXT`, `CSV`, `JSON`, etc.) se encapsulan en subclases concretas que implementan los
> m√©todos abstractos.

Adem√°s:

- Se promueve el `principio de Inversi√≥n de Dependencias (DIP)` al depender de la interfaz `FileStorageService`.
- Se favorece el `principio de Responsabilidad √önica (SRP)`: esta clase solo orquesta el proceso, mientras que el
  parseo, validaci√≥n y almacenamiento est√°n delegados.
- Es `abierta a extensi√≥n (para nuevos formatos) y cerrada a modificaci√≥n`, cumpliendo con el `principio OCP`.

### üß© Subclase concreta: `TxtDelimitedProcessor`

Esta clase concreta representa un procesador de archivos de texto plano delimitados por `|`, sin cabecera, con un total
esperado de 4 columnas por l√≠nea.

Es una `implementaci√≥n espec√≠fica` del `patr√≥n Template Method`, basada en la clase abstracta `FileProcessor<T>`,
donde `T` es `TxtRecord`. Define c√≥mo deben comportarse los pasos personalizables para este tipo de archivo.

Est√° anotada con `@Component`, por lo que Spring la registra como un bean disponible para ser inyectado autom√°ticamente
donde se necesite.

````java

@Slf4j
@Component
public class TxtDelimitedProcessor extends FileProcessor<TxtRecord> {

    private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    private final String delimiter = "|";
    private final boolean hasHeader = false;
    private final int expectedColumns = 4;

    public TxtDelimitedProcessor(FileStorageService fileStorageService) {
        super(fileStorageService);
    }

    @Override
    public FileType expectedFileType() {
        return FileType.TXT;
    }

    @Override
    protected ValidationResult validateFileStructure(Path path) {
        try (BufferedReader reader = Files.newBufferedReader(path)) {
            String firstLine = reader.readLine();

            if (Objects.isNull(firstLine) || firstLine.isBlank()) {
                return ValidationResult.failure("Archivo txt vac√≠o");
            }

            String[] columns = firstLine.split(Pattern.quote(this.delimiter));
            if (this.hasHeader) {
                if (columns.length < this.expectedColumns) {
                    return ValidationResult.failure("La cabecera txt debe tener al menos %d columnas separadas por '%s'"
                            .formatted(this.expectedColumns, this.delimiter));
                }
                log.info("Cabecera txt detectada. Columnas encontradas: {}", columns.length);
            } else {
                if (columns.length != this.expectedColumns) {
                    return ValidationResult.failure("La primera l√≠nea txt debe tener exactamente %d columnas separadas por '%s'"
                            .formatted(this.expectedColumns, this.delimiter));
                }
                log.info("Sin cabecera TXT. Validando estructura de la primera l√≠nea: {} columnas", columns.length);
            }

            return ValidationResult.success();
        } catch (IOException e) {
            return ValidationResult.failure("Error al leer el archivo: %s".formatted(e.getMessage()));
        }
    }

    @Override
    protected List<TxtRecord> parseFileContent(Path path) {
        List<TxtRecord> records = new ArrayList<>();

        try (BufferedReader reader = Files.newBufferedReader(path)) {
            int lineNumber = 0;

            if (this.hasHeader) {
                String headers = reader.readLine();
                log.info("headers txt: {}", headers);
                lineNumber++;
            }

            String line;
            while ((line = reader.readLine()) != null) {
                lineNumber++;

                if (line.trim().isEmpty()) {
                    log.warn("L√≠nea {} txt vac√≠a e ignorada", lineNumber);
                    continue;
                }

                try {
                    String[] fields = line.split(Pattern.quote(this.delimiter));
                    if (fields.length == this.expectedColumns) {
                        TxtRecord txtRecord = new TxtRecord(
                                "TXT_" + lineNumber,
                                fields[0].trim(),
                                Double.parseDouble(fields[1].trim()),
                                LocalDateTime.parse(fields[2].trim(), DATE_TIME_FORMATTER),
                                fields[3].trim()
                        );
                        records.add(txtRecord);
                    } else {
                        log.warn("L√≠nea {} txt ignorada: se esperaban {} columnas pero se encontraron {}", lineNumber, expectedColumns, fields.length);
                    }
                } catch (Exception e) {
                    log.warn("Error procesando l√≠nea {} txt: {}", lineNumber, e.getMessage());
                }
            }
        } catch (IOException e) {
            log.error("Error leyendo archivo TXT: {}", e.getMessage());
            throw new FileProcessorException("Error procesando archivo TXT: " + e.getMessage());
        }

        log.info("Parsing TXT completado: {} registros extra√≠dos", records.size());
        return records;
    }

    @Override
    protected BusinessValidationResult<TxtRecord> validateBusinessRules(List<TxtRecord> parsedRecords) {
        List<TxtRecord> validRecords = parsedRecords.stream()
                .filter(txtRecord -> {
                    boolean isValid = true;

                    if (txtRecord.accountNumber() == null || txtRecord.accountNumber().isBlank()) {
                        log.warn("Registro TXT inv√°lido {}: accountNumber vac√≠o", txtRecord.id());
                        isValid = false;
                    }

                    if (txtRecord.amount() <= 0) {
                        log.warn("Registro TXT inv√°lido {}: amount debe ser mayor que 0", txtRecord.id());
                        isValid = false;
                    }

                    return isValid;
                })
                .toList();

        int invalidCount = parsedRecords.size() - validRecords.size();
        log.info("Validaci√≥n TXT: {} registros v√°lidos, {} inv√°lidos", validRecords.size(), invalidCount);

        return new BusinessValidationResult<>(validRecords, invalidCount);
    }

    @Override
    protected int storeRecords(List<TxtRecord> validRecords, String batchId) {
        log.info("=== Simulaci√≥n Persistencia TXT ===");
        validRecords.forEach(txtRecord -> {
            String sql = """
                        INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
                        VALUES ('%s', '%s', %.2f, '%s', '%s', '%s')
                    """.formatted(
                    txtRecord.id(),
                    txtRecord.accountNumber(),
                    txtRecord.amount(),
                    txtRecord.transactionDate(),
                    txtRecord.description(),
                    batchId
            );

            log.info("SQL simulada TXT: {}", sql);
        });
        log.info("Se simularon {} inserciones en la tabla transactions_txt.", validRecords.size());
        return validRecords.size();
    }
}
````

üß† Resumen
> `TxtDelimitedProcessor` es una `implementaci√≥n concreta` del `patr√≥n Template Method` que define el comportamiento
> espec√≠fico para procesar archivos `.txt` delimitados. Encapsula toda la l√≥gica asociada con este tipo de archivo
> (formato, validaciones, parseo, simulaci√≥n de persistencia), permitiendo que el flujo general de procesamiento
> definido en `FileProcessor<T>` se mantenga inalterado. Esto facilita la extensi√≥n hacia nuevos tipos de archivos
> (por ejemplo, `.csv`, `.json`) sin modificar el flujo base.

### üè≠ FileProcessorFactory ‚Äì F√°brica de procesadores seg√∫n tipo de archivo

La clase `FileProcessorFactory` implementa una f√°brica din√°mica de procesadores de archivos, encargada de resolver qu√©
implementaci√≥n concreta de `FileProcessor` utilizar, en funci√≥n del tipo de archivo recibido (`FileType`). Su objetivo
es desacoplar la l√≥gica de selecci√≥n del procesador, delegando esta responsabilidad a un √∫nico punto del sistema.

Mediante Spring, todos los beans que extienden `FileProcessor` son inyectados autom√°ticamente como una lista. La f√°brica
los registra en un `Map<FileType, FileProcessor>` usando como clave el tipo de archivo que declara cada uno.

‚úÖ Se usa `EnumMap` por ser m√°s eficiente cuando la clave es un `enum`.

````java

@Slf4j
@Component
public class FileProcessorFactory {

    private final Map<FileType, FileProcessor<? extends ParsedRecord>> processors = new EnumMap<>(FileType.class);

    public FileProcessorFactory(List<FileProcessor<? extends ParsedRecord>> processorList) {
        processorList.forEach(processor -> {
            FileType fileType = processor.expectedFileType();
            this.processors.put(fileType, processor);
            log.info("Processor registrado: {} para tipo: {}", processor.getClass().getSimpleName(), fileType);
        });
        log.info("FileProcessorFactory inicializado con {} processors", processors.size());
    }

    public FileProcessor<? extends ParsedRecord> getProcessor(FileType fileType) {
        FileProcessor<? extends ParsedRecord> processor = this.processors.get(fileType);
        if (Objects.isNull(processor)) {
            throw new FileProcessorException("No hay processor disponible para: " + fileType);
        }
        log.debug("Obteniendo processor: {} para tipo: {}", processor.getClass().getSimpleName(), fileType);
        return processor;
    }

    public Set<FileType> getSupportedFileTypes() {
        return this.processors.keySet();
    }
}
````

### üéØ ¬øPor qu√© es necesaria esta clase?

En lugar de que un controller o servicio tenga que decidir manualmente qu√© subclase usar para procesar un archivo
`.txt`,
`.csv`, etc., esta clase encapsula esa l√≥gica y la resuelve autom√°ticamente a partir del enum `FileType`.

Este enfoque:

- Evita el uso de condicionales (if, switch) dispersos.
- Facilita la extensi√≥n futura del sistema (solo se agrega un nuevo `FileProcessor` y se registra autom√°ticamente).
- Cumple con el `principio de Abierto/Cerrado (OCP)`.

üìò Resumen
> `FileProcessorFactory` es una clase de infraestructura que act√∫a como selector din√°mico de estrategias, permitiendo
> obtener la implementaci√≥n concreta de `FileProcessor` adecuada para el tipo de archivo recibido. Este dise√±o respeta
> el `principio de responsabilidad √∫nica` y facilita la extensibilidad del sistema, ya que nuevas implementaciones se
> registran autom√°ticamente sin modificar esta clase.

### üß© Servicio de orquestaci√≥n: FileProcessingService y FileProcessingServiceImpl

La interfaz `FileProcessingService` define las operaciones de alto nivel para procesar un archivo y consultar los tipos
de archivo soportados por el sistema. Esta interfaz abstrae completamente los detalles de implementaci√≥n, permitiendo
desacoplar el controller o cualquier otro cliente del procesamiento concreto.

````java
public interface FileProcessingService {
    ProcessResult processFile(MultipartFile multipartFile, String batchId);

    Set<FileType> getSupportedFileTypes();
}
````

La clase `FileProcessingServiceImpl` representa el n√∫cleo coordinador del sistema. Orquesta el flujo completo de
procesamiento siguiendo estos pasos:

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class FileProcessingServiceImpl implements FileProcessingService {

    private final FileProcessorFactory fileProcessorFactory;

    @Override
    public ProcessResult processFile(MultipartFile multipartFile, String batchId) {
        // Paso 1: Detectar el tipo de archivo
        FileType fileType = this.detectFileType(multipartFile);
        log.info("Tipo de archivo detectado: {}", fileType);

        // Paso 2: Validar que el tipo sea soportado
        this.validateSupportedFileType(fileType);

        // Paso 3: Obtener el processor apropiado
        FileProcessor<? extends ParsedRecord> processor = this.fileProcessorFactory.getProcessor(fileType);
        log.info("Processor obtenido: {}", processor.getClass().getSimpleName());

        // Paso 4: Ejecutar procesamiento
        ProcessResult result = processor.processFile(multipartFile, batchId);
        log.info("Procesamiento completado. ¬ø√âxito?: {}, registros procesados: {}", result.success(), result.processedRecords());

        return result;
    }

    @Override
    public Set<FileType> getSupportedFileTypes() {
        return this.fileProcessorFactory.getSupportedFileTypes();
    }

    private FileType detectFileType(MultipartFile multipartFile) {
        String filename = multipartFile.getOriginalFilename();
        String mimeType = multipartFile.getContentType();

        log.debug("Detectando tipo - MIME: {}, Filename: {}", mimeType, filename);

        // Primero intentamos por el tipo mime
        if (Objects.nonNull(mimeType) && !mimeType.isBlank()) {
            Optional<FileType> fileTypeByMime = FileType.fromMimeType(mimeType);
            if (fileTypeByMime.isPresent()) {
                log.debug("Tipo detectado por MIME type: {}", fileTypeByMime.get());
                return fileTypeByMime.get();
            }
        }

        // Si no funciona MIME, intentamos por extensi√≥n
        if (Objects.nonNull(filename) && !filename.isBlank()) {
            String extension = FileUtils.getFileExtension(multipartFile);
            Optional<FileType> fileTypeByExtension = FileType.fromExtension(extension);
            if (fileTypeByExtension.isPresent()) {
                log.debug("Tipo detectado por extensi√≥n: {}", fileTypeByExtension.get());
                return fileTypeByExtension.get();
            }
        }

        throw new FileProcessorException(
                "Tipo de archivo no reconocido en el sistema. MIME: %s, Archivo: %s. Extensiones soportadas: %s"
                        .formatted(mimeType, filename, this.getSupportedFileTypes()));
    }

    private void validateSupportedFileType(FileType fileType) {
        Set<FileType> supportedFileTypes = this.getSupportedFileTypes();
        if (!supportedFileTypes.contains(fileType)) {
            throw new FileProcessorException("No se encontr√≥ un processor para procesar archivos %s. Tipos soportados: %s"
                    .formatted(fileType, supportedFileTypes));
        }
        log.debug("Tipo de archivo {} es soportado", fileType);
    }
}
````

üìò Resumen
> `FileProcessingServiceImpl` es el servicio orquestador que expone un √∫nico punto de entrada para procesar archivos de
> distintos formatos. Encapsula todo el proceso de detecci√≥n del tipo de archivo, validaci√≥n y delegaci√≥n del
> procesamiento a la clase concreta adecuada, manteni√©ndose completamente desacoplado de los detalles. Este dise√±o
> facilita la reutilizaci√≥n, pruebas unitarias y extensi√≥n del sistema a nuevos formatos sin necesidad de modificar esta
> clase.

### üåê FileProcessorController ‚Äì Exposici√≥n del procesamiento v√≠a REST

Esta clase representa la capa de presentaci√≥n del sistema. Expone una API REST para que clientes externos (como
interfaces web, servicios backend o herramientas automatizadas) puedan procesar archivos estructurados, sin conocer
detalles de su estructura o l√≥gica de validaci√≥n.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/files")
public class FileProcessorController {

    private final FileProcessingService fileProcessingService;

    @PostMapping(path = "/process")
    public ResponseEntity<ProcessResult> processFile(@RequestParam("file") MultipartFile multipartFile,
                                                     @RequestParam(required = false, defaultValue = "") String batchId) {
        if (batchId.isBlank()) {
            batchId = "BATCH_" + System.currentTimeMillis();
            log.info("BatchId generado autom√°ticamente: {}", batchId);
        }

        ProcessResult result = this.fileProcessingService.processFile(multipartFile, batchId);
        HttpStatus status = result.success() ? HttpStatus.OK : HttpStatus.UNPROCESSABLE_ENTITY;
        log.info("Procesamiento finalizado - Status: {}, ¬ø√âxito?: {}", status, result.success());
        return ResponseEntity.status(status).body(result);
    }

    @GetMapping(path = "/supported-types")
    public ResponseEntity<Set<FileType>> getSupportedFileTypes() {
        Set<FileType> supportedTypes = this.fileProcessingService.getSupportedFileTypes();
        log.debug("Tipos de archivos soportados: {}", supportedTypes);
        return ResponseEntity.ok(supportedTypes);
    }

}
````

üìò Resumen
> `FileProcessorController` es la capa expuesta v√≠a REST que permite iniciar el procesamiento de archivos en el sistema.
> Permite subir archivos desde clientes HTTP junto con un identificador de lote opcional. A trav√©s de este controlador,
> se invoca el servicio orquestador (`FileProcessingService`) que selecciona din√°micamente la estrategia adecuada de
> procesamiento seg√∫n el tipo de archivo. Tambi√©n ofrece un endpoint auxiliar para listar los tipos de archivo
> actualmente soportados por el sistema.

### üß™ Caso de prueba: Procesamiento exitoso de archivo .txt

Validar que el sistema puede procesar correctamente un archivo `.txt` delimitado por `|`, sin cabecera, con contenido
estructurado v√°lido y algunos registros inv√°lidos.

````bash
$ curl -v -X POST -H "Content-Type: multipart/form-data" -F "file=@D:\programming\spring\15.martin_diaz\design-patterns\src\main\resources\sample-files\sample_transactions.txt" -F "batchId=BATCH_001" http://localhost:8080/api/v1/files/process | jq
>
< HTTP/1.1 200
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Fri, 01 Aug 2025 22:33:22 GMT
<
{
  "batchId": "BATCH_001",
  "success": true,
  "totalRecords": 4,
  "processedRecords": 3,
  "invalidRecords": 1,
  "sourceInfo": {
    "location": "M:\\temp_files\\BATCH_001_1754087602750.txt",
    "filename": "BATCH_001_1754087602750.txt",
    "storageType": "LOCAL"
  }
}
````

üìã Interpretaci√≥n

- ‚úÖ Archivo reconocido como TXT gracias a su tipo MIME.
- üîÑ Procesador asignado autom√°ticamente: TxtDelimitedProcessor.
- üìÑ Validaci√≥n estructural: correcta (4 columnas sin cabecera).
- üßæ Registros le√≠dos: 4 en total.
- ‚ö†Ô∏è Registros inv√°lidos: 1 (campo amount <= 0).
- üóÉÔ∏è Simulaci√≥n de persistencia: se generaron y mostraron 3 sentencias SQL.
- üßπ Archivos temporales: eliminados exitosamente al finalizar.

````bash
$ 2025-08-01T17:33:22.746-05:00 DEBUG 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Detectando tipo - MIME: text/plain, Filename: sample_transactions.txt
2025-08-01T17:33:22.747-05:00 DEBUG 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Tipo detectado por MIME type: TXT
2025-08-01T17:33:22.747-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Tipo de archivo detectado: TXT
2025-08-01T17:33:22.747-05:00 DEBUG 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Tipo de archivo TXT es soportado
2025-08-01T17:33:22.747-05:00 DEBUG 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.f.FileProcessorFactory     : Obteniendo processor: TxtDelimitedProcessor para tipo: TXT
2025-08-01T17:33:22.748-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Processor obtenido: TxtDelimitedProcessor
2025-08-01T17:33:22.748-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : === Iniciando procesamiento de archivo ===
2025-08-01T17:33:22.748-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Archivo: sample_transactions.txt - Batch ID: BATCH_001 - Tama√±o: 219
2025-08-01T17:33:22.750-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Archivo sample_transactions.txt validado correctamente
2025-08-01T17:33:22.756-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Archivo sample_transactions.txt guardado con √©xito como BATCH_001_1754087602750.txt
2025-08-01T17:33:22.787-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Procesando archivo desde: C:\Users\MAGADI~1\AppData\Local\Temp\file_processor5927695816091046078\BATCH_001_1754087602750.txt
2025-08-01T17:33:22.788-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : Sin cabecera TXT. Validando estructura de la primera l√≠nea: 4 columnas
2025-08-01T17:33:22.791-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : Parsing TXT completado: 4 registros extra√≠dos
2025-08-01T17:33:22.791-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Se parsearon 4 registros del archivo
2025-08-01T17:33:22.791-05:00  WARN 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : Registro TXT inv√°lido TXT_4: amount debe ser mayor que 0
2025-08-01T17:33:22.791-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : Validaci√≥n TXT: 3 registros v√°lidos, 1 inv√°lidos
2025-08-01T17:33:22.791-05:00  WARN 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Se encontraron 1 registros inv√°lidos de 4
2025-08-01T17:33:22.791-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Persistiendo 3 registros v√°lidos en base de datos
2025-08-01T17:33:22.793-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : === Simulaci√≥n Persistencia TXT ===
2025-08-01T17:33:22.793-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : SQL simulada TXT:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_1', 'ACC001', 150.75, '2024-01-15T10:30', 'Transferencia entrante', 'BATCH_001')

2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : SQL simulada TXT:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_2', 'ACC002', 89.50, '2024-01-15T11:45', 'Pago servicios', 'BATCH_001')

2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : SQL simulada TXT:     INSERT INTO transactions_txt (id, account_number, amount, transaction_date, description, batch_id)
    VALUES ('TXT_3', 'ACC003', 200.00, '2024-01-15T14:20', 'Dep√≥sito efectivo', 'BATCH_001')

2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.p.TxtDelimitedProcessor    : Se simularon 3 inserciones en la tabla transactions_txt.
2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Se persistieron 3 registros exitosamente
2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : REPORTE txt:
=== REPORTE DE PROCESAMIENTO txt ===
Archivo Original: sample_transactions.txt
Archivo Almacenado: BATCH_001_1754087602750.txt
Ubicaci√≥n: M:\temp_files\BATCH_001_1754087602750.txt
Storage Type: LOCAL
Batch ID: BATCH_001
Fecha/Hora: 2025-08-01 17:33:22
Processor: TxtDelimitedProcessor
Total registros: 4
Registros procesados: 3
Registros inv√°lidos: 1
Estado: Exitoso con advertencias
2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Procesamiento finalizado exitosamente. Registros procesados: 3
2025-08-01T17:33:22.794-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.processor.FileProcessor    : Limpiando archivo temporal: C:\Users\MAGADI~1\AppData\Local\Temp\file_processor5927695816091046078\BATCH_001_1754087602750.txt
2025-08-01T17:33:22.795-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.util.FileUtils             : Eliminado: C:\Users\MAGADI~1\AppData\Local\Temp\file_processor5927695816091046078\BATCH_001_1754087602750.txt
2025-08-01T17:33:22.796-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.util.FileUtils             : Eliminado: C:\Users\MAGADI~1\AppData\Local\Temp\file_processor5927695816091046078
2025-08-01T17:33:22.796-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] .p.s.b.t.f.s.i.FileProcessingServiceImpl : Procesamiento completado. ¬ø√âxito?: true, registros procesados: 3
2025-08-01T17:33:22.797-05:00  INFO 12544 --- [design-patterns] [nio-8080-exec-3] d.m.p.s.b.t.f.c.FileProcessorController  : Procesamiento finalizado - Status: 200 OK, ¬ø√âxito?: true
````

### üìå Conclusi√≥n

Este caso demuestra que el sistema:

- Detecta y valida correctamente el tipo de archivo.
- Aplica el flujo definido en el Template Method con todos sus pasos.
- Genera un reporte de procesamiento completo.
- Se comporta de manera robusta frente a registros inv√°lidos sin detener el flujo.

---

# Chain of Responsibility

## üéØ Ejemplo 01: Validar una solicitud de orden antes de procesarla

CHATGPT ESTE P√ÅRRAFO ME LO DIR√ÅS AL √öLTIMO CUANTO TENGAS TODA LA IMPLEMENTACI√ìN Y EJECUCI√ìN DE ESTE EJEMPLO OK?

### Entidades

En este ejemplo, trabajaremos con dos clases que simulan nuestras entidades de dominio: `Product` y `Customer`.
En un escenario real con `Spring Data JPA`, estas clases estar√≠an anotadas con `@Entity`, `@Table`, `@Id`, etc.,
pero para este caso omitiremos dichas anotaciones, ya que no interactuaremos con una base de datos real.

El objetivo es mantener el enfoque en el patr√≥n de dise√±o `Chain of Responsibility` sin introducir complejidad extra
por la capa de persistencia. Sin embargo, conceptualmente, estas clases representan datos que podr√≠an provenir de una
base de datos.

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
//@Entity
//@Table(name = "products")
public class Product {
    //@Id
    private Long id;
    String name;
    BigDecimal price;
    Integer availableStock;
}
````

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
//@Entity
//@Table(name = "customers")
public class Customer {
    //@Id
    private Long id;
    String name;
    String email;
    Boolean active;
}
````

Notas clave:

- Se utilizan anotaciones de `Lombok` (`@AllArgsConstructor`, `@NoArgsConstructor`, `@Builder`, `@Data`) para reducir
  el c√≥digo repetitivo (constructores, getters, setters, etc.).
- Aunque aqu√≠ las tratamos como POJOs simples, en un proyecto real podr√≠an mapearse directamente a tablas de base de
  datos.
- `Product` representa un producto con precio y stock disponible.
- `Customer` representa un cliente con informaci√≥n de contacto y estado de actividad.

### DTOs (Data Transfer Objects)

En este apartado definimos los objetos que se utilizar√°n para recibir y enviar datos a trav√©s de la API REST.
Todos ellos est√°n dise√±ados como Java Records, lo que los hace inmutables, concisos y seguros para manejar en entornos
concurrentes.

- `ShippingAddress`. Representa la direcci√≥n de env√≠o de la orden, con validaciones para asegurar que la informaci√≥n sea
  correcta.
    - Las anotaciones de `Jakarta Validation` (`@NotBlank`, `@Size`, `@Pattern`) garantizan la calidad de los datos
      antes de procesarlos.
    - El c√≥digo postal se valida con una expresi√≥n regular que exige exactamente 5 d√≠gitos.

````java
public record ShippingAddress(@NotBlank
                              @Size(min = 5, max = 100)
                              String street,

                              @NotBlank
                              @Size(min = 5, max = 50)
                              String city,

                              @NotBlank
                              @Pattern(regexp = "\\d{5}")
                              String postalCode,

                              @NotBlank
                              String country) {
}
````

- `OrderItem`. Representa un producto incluido en la orden, con cantidad y precio unitario.
    - Incluye un m√©todo utilitario `getSubTotal()` para calcular el total por √≠tem (`cantidad √ó precio unitario`)
      redondeado a dos decimales.
    - Las validaciones aseguran que la cantidad y el precio sean positivos y mayores que cero.

````java
public record OrderItem(@NotNull
                        @Positive
                        Long productId,

                        @NotNull
                        @Positive
                        Integer quantity,

                        @NotNull
                        @DecimalMin(value = "0.01")
                        BigDecimal unitPrice) {

    public BigDecimal getSubTotal() {
        return this.unitPrice
                .multiply(BigDecimal.valueOf(this.quantity))
                .setScale(2, RoundingMode.HALF_UP);
    }
}
````

- `PurchaseOrder`. DTO principal para recibir una solicitud de compra.
    - El m√©todo `getTotalAmount()` calcula el monto total de la orden sumando los subtotales de cada √≠tem.
    - Se valida que la lista de √≠tems no est√© vac√≠a (`@NotEmpty`) y que cada elemento sea v√°lido (`@Valid`).
    - Por qu√© usar `@Valid` en colecciones:
        - Permite que las validaciones definidas en el tipo de elemento (`OrderItem`) se apliquen a cada objeto de la
          lista.
        - Sin `@Valid`, la validaci√≥n se detendr√≠a en el propio contenedor (la lista) y no se evaluar√≠a el contenido
          interno.
        - Es esencial cuando se tienen estructuras de datos anidadas y se quiere asegurar que toda la jerarqu√≠a de
          objetos cumpla las restricciones declaradas.
    - Este mismo comportamiento se aplica para el atributo del tipo `ShippingAddress` que tambi√©n est√° anotado con
      `@Valid`.

````java
public record PurchaseOrder(@NotNull
                            @Positive
                            Long customerId,

                            @NotEmpty
                            @Valid
                            List<OrderItem> items,

                            @NotNull
                            @Valid
                            ShippingAddress shippingAddress) {

    public BigDecimal getTotalAmount() {
        return this.items.stream()
                .map(OrderItem::getSubTotal)
                .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}
````

- `OrderResponse`. DTO para representar la respuesta exitosa de una orden procesada.
    - Ideal para confirmar al cliente el estado de la orden (ej. "ORDER_CREATED", "INSUFFICIENT_STOCK").
    - Incluye el monto total de la orden calculado.

````java
public record OrderResponse(String orderId,
                            String status,
                            String message,
                            BigDecimal totalAmount) {
}
````

### Servicios de soporte

En este ejemplo, definimos tres clases de servicio que no forman parte directa del patr√≥n `Chain of Responsibility`,
pero son necesarias para simular el escenario real de validaci√≥n de √≥rdenes.

En un entorno de producci√≥n, estos servicios podr√≠an interactuar con una base de datos, un API externo o sistemas de
negocio, pero aqu√≠ trabajaremos con datos en memoria para simplificar.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ProductService {
    private final Map<Long, Product> products = Map.of(
            101L, new Product(101L, "Dell Laptop", new BigDecimal("1200.00"), 5),
            102L, new Product(102L, "Wireless Mouse", new BigDecimal("25.50"), 0),
            103L, new Product(103L, "Mechanical Keyboard", new BigDecimal("89.99"), 10)
    );

    public Product findById(Long productId) {
        return this.products.get(productId);
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class CustomerService {
    private final Map<Long, Customer> customers = Map.of(
            1L, new Customer(1L, "John Doe", "john@email.com", true),
            2L, new Customer(2L, "Jane Smith", "jane@email.com", false),
            3L, new Customer(3L, "Mike Johnson", "mike@email.com", true)
    );

    public Customer findById(Long customerId) {
        return this.customers.get(customerId);
    }
}
````

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class AddressService {
    private final Set<String> validCountries = Set.of("USA", "CANADA", "MEXICO", "PERU", "COLOMBIA");

    public boolean isValidAddress(ShippingAddress address) {
        return Objects.nonNull(address.street()) && !address.street().isBlank() &&
               Objects.nonNull(address.city()) && !address.city().isBlank() &&
               Objects.nonNull(address.postalCode()) && !address.postalCode().isBlank() &&
               this.validCountries.contains(address.country().toUpperCase());
    }
}
````

üìå Observaci√≥n general:

- Todos estos servicios est√°n anotados con `@Service` para ser gestionados por el contenedor de Spring como
  `beans singleton`.
- Usan colecciones inmutables (Map.of, Set.of) para garantizar consistencia y evitar modificaciones accidentales.
- Se ha utilizado Lombok (`@RequiredArgsConstructor`, `@Slf4j`) para simplificar el c√≥digo, reduciendo constructores y
  boilerplate.

### Excepciones personalizadas

Para este ejemplo, se definen varias excepciones personalizadas que representan errores espec√≠ficos en el flujo de
validaci√≥n de la orden.

Todas heredan de `BusinessValidationException`, una clase base que extiende `RuntimeException`, lo que permite lanzar
errores sin necesidad de declararlos en la firma de los m√©todos (`unchecked exceptions`).

- `BusinessValidationException`
    - Clase base para todas las excepciones de validaci√≥n de negocio.
    - Permite centralizar la jerarqu√≠a de errores y manejar todos los casos de validaci√≥n bajo un mismo tipo padre.

- `CustomerNotFoundException`
    - Se lanza cuando el cliente con el ID especificado no existe en el sistema.

- `CustomerInactiveException`
    - Se lanza cuando el cliente existe, pero est√° marcado como inactivo y no puede realizar compras.

- `ProductNotFoundException`
    - Se lanza cuando el producto solicitado no est√° registrado en el sistema.

- `InsufficientStockException`
    - Se lanza cuando el stock disponible de un producto es menor que la cantidad solicitada en el pedido.

- `InvalidShippingAddressException`
    - Se lanza cuando la direcci√≥n de env√≠o no cumple con el formato esperado o el pa√≠s no est√° dentro de la lista
      permitida.

- `SystemMaintenanceException`
    - Se lanza cuando el sistema se encuentra en una ventana de mantenimiento y no se pueden procesar pedidos.
    - Formatea autom√°ticamente las horas de inicio y fin en un formato legible (HH:mm a).

> üí° Nota: Al heredar de una clase com√∫n (`BusinessValidationException`), se facilita el manejo centralizado de todas
> las validaciones de negocio en un `@ControllerAdvice` o en una capa de manejo global de excepciones.

````java
public class BusinessValidationException extends RuntimeException {
    public BusinessValidationException(String message) {
        super(message);
    }
}
````

````java
public class CustomerNotFoundException extends BusinessValidationException {
    public CustomerNotFoundException(Long customerId) {
        super("Cliente no encontrado con ID: %d".formatted(customerId));
    }
}
````

````java
public class CustomerInactiveException extends BusinessValidationException {
    public CustomerInactiveException(Long customerId) {
        super("Cliente con ID %d est√° inactivo".formatted(customerId));
    }
}
````

````java
public class ProductNotFoundException extends BusinessValidationException {
    public ProductNotFoundException(Long productId) {
        super("Producto no encontrado con ID: %d".formatted(productId));
    }
}
````

````java
public class InsufficientStockException extends BusinessValidationException {
    public InsufficientStockException(String productName, int available, int requested) {
        super("Stock insuficiente para %s. Disponible: %d, Solicitado: %d".formatted(productName, available, requested));
    }
}
````

````java
public class InvalidShippingAddressException extends BusinessValidationException {
    public InvalidShippingAddressException() {
        super("Direcci√≥n de env√≠o no v√°lida. Verifique el formato de los campos y el pa√≠s de destino.");
    }
}
````

````java
public class SystemMaintenanceException extends BusinessValidationException {
    public SystemMaintenanceException(LocalTime startTime, LocalTime endTime) {
        super("Sistema en mantenimiento. No se procesan pedidos desde la %s hasta las %s".
                formatted(formatTime(startTime), formatTime(endTime)));
    }

    private static String formatTime(LocalTime time) {
        return time.format(DateTimeFormatter.ofPattern("HH:mm a"));
    }
}
````

### Manejo global de excepciones (GlobalExceptionHandler)

La clase `GlobalExceptionHandler` centraliza el manejo de errores en la API mediante la anotaci√≥n
`@RestControllerAdvice`.

Esto permite capturar excepciones lanzadas en cualquier controlador y devolver respuestas estructuradas siguiendo el
est√°ndar `RFC 7807 ‚Äì Problem Details for HTTP APIs`.

````java

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(BusinessValidationException.class)
    public ResponseEntity<ProblemDetail> handleException(BusinessValidationException ex) {
        log.error("Error de validaci√≥n de negocio: {}", ex.getMessage());
        HttpStatus status = this.getStatus(ex);
        ProblemDetail problemDetail = this.build(status, ex, detail -> {
            detail.setTitle("Problemas en la validaci√≥n de l√≥gica de negocio");
        });
        return ResponseEntity.status(status).body(problemDetail);
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ProblemDetail> handleValidation(MethodArgumentNotValidException ex) {
        log.error("Error de validaci√≥n de datos: {}", ex.getMessage());
        Map<String, List<String>> errors = this.extractValidationErrors(ex);
        ProblemDetail problemDetail = this.build(HttpStatus.BAD_REQUEST, ex, detail -> {
            detail.setTitle("Datos de entrada inv√°lidos");
            detail.setProperty("errors", errors);
        });
        return ResponseEntity.badRequest().body(problemDetail);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ProblemDetail> handleGenericException(Exception ex) {
        log.error("Error gen√©rico: {}", ex.getMessage());
        ProblemDetail problemDetail = this.build(HttpStatus.INTERNAL_SERVER_ERROR, ex, detail -> {
            detail.setTitle("Se ha producido un error gen√©rico");
        });
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(problemDetail);
    }

    private Map<String, List<String>> extractValidationErrors(MethodArgumentNotValidException ex) {
        return ex.getBindingResult().getFieldErrors().stream()
                .collect(Collectors.groupingBy(
                        FieldError::getField,
                        Collectors.mapping(FieldError::getDefaultMessage, Collectors.toList())
                ));
    }

    private HttpStatus getStatus(BusinessValidationException ex) {
        return switch (ex) {
            case CustomerNotFoundException e -> HttpStatus.NOT_FOUND;
            case ProductNotFoundException e -> HttpStatus.NOT_FOUND;
            default -> HttpStatus.BAD_REQUEST;
        };
    }

    private ProblemDetail build(HttpStatus status, Exception ex, Consumer<ProblemDetail> detailConsumer) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(status, ex.getMessage());
        detailConsumer.accept(problemDetail);
        return problemDetail;
    }
}
````

### Estructura base del patr√≥n Chain of Responsibility

En este punto mostramos la columna vertebral del patr√≥n `Chain of Responsibility` para nuestro ejemplo.

`OrderValidationHandler`

````java
public interface OrderValidationHandler {
    OrderValidationHandler setNext(OrderValidationHandler handler);

    void handle(PurchaseOrder order);
}
````

Es la interfaz del manejador (`Handler`).

- Define:
    - `setNext(...)`: m√©todo para encadenar el siguiente validador.
    - `handle(...)`: m√©todo para procesar la petici√≥n (en este caso, la orden de compra).
- Gracias a esta interfaz, todos los validadores tendr√°n la misma forma y podr√°n conectarse entre s√≠ sin importar su
  implementaci√≥n concreta.

`BaseOrderValidationHandler`

````java
public abstract class BaseOrderValidationHandler implements OrderValidationHandler {

    protected OrderValidationHandler nextHandler;

    @Override
    public OrderValidationHandler setNext(OrderValidationHandler handler) {
        this.nextHandler = handler;
        return handler;
    }

    @Override
    public final void handle(PurchaseOrder order) {
        // Ejecuta validaci√≥n espec√≠fica, si falla, lanza excepci√≥n
        this.doHandle(order);

        // Si llegamos aqu√≠, la validaci√≥n fue exitosa, continuamos con la cadena
        if (Objects.nonNull(this.nextHandler)) {
            this.nextHandler.handle(order);
        }
    }

    protected abstract void doHandle(PurchaseOrder order);
}
````

Es una clase abstracta que implementa la interfaz y centraliza la l√≥gica com√∫n del patr√≥n.

- Aporta:
    - Referencia al siguiente handler: `protected OrderValidationHandler nextHandler`.
    - Implementaci√≥n est√°ndar de `setNext(...)` para encadenar validadores.
    - Implementaci√≥n `final` de `handle(...)` que:
        - Ejecuta la validaci√≥n concreta (`doHandle(order)`).
        - Si la validaci√≥n es exitosa y existe otro `handler`, lo llama en cascada.
    - M√©todo abstracto `protected abstract void doHandle(PurchaseOrder order)`:
        - Este es el `punto de extensi√≥n`: cada validador concreto define aqu√≠ su propia l√≥gica de validaci√≥n.

### Concrete Handlers (Validadores concretos)

Cada clase de esta secci√≥n extiende la clase base `BaseOrderValidationHandler` e implementa la validaci√≥n espec√≠fica
para una parte particular de la orden.

Estas clases son los eslabones de la cadena en el patr√≥n `Chain of Responsibility` y se ejecutan en orden para validar
la solicitud.

`CustomerValidationHandler`

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class CustomerValidationHandler extends BaseOrderValidationHandler {

    private final CustomerService customerService;

    @Override
    protected void doHandle(PurchaseOrder order) {
        log.info("[CustomerValidation] Verificando cliente con ID: {}", order.customerId());

        Long customerId = order.customerId();
        Customer customer = this.customerService.findById(customerId);
        if (Objects.isNull(customer)) {
            throw new CustomerNotFoundException(customerId);
        }

        if (Boolean.FALSE.equals(customer.getActive())) {
            throw new CustomerInactiveException(customerId);
        }

        log.info("[CustomerValidation] Cliente v√°lido: {}", customer.getName());
    }
}
````

Responsabilidades:

- Verificar que el cliente exista en el sistema.
- Verificar que el cliente est√© activo.
- Lanzar excepciones espec√≠ficas si alguna validaci√≥n falla para detener el flujo.
- Registrar informaci√≥n relevante con logs para facilitar el seguimiento.

`StockValidationHandler`

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class StockValidationHandler extends BaseOrderValidationHandler {

    private final ProductService productService;

    @Override
    protected void doHandle(PurchaseOrder order) {
        log.info("[StockValidation] Verificando disponibilidad de productos");
        order.items().forEach(orderItem -> {
            Product product = this.productService.findById(orderItem.productId());
            if (Objects.isNull(product)) {
                throw new ProductNotFoundException(orderItem.productId());
            }

            if (orderItem.quantity() > product.getAvailableStock()) {
                throw new InsufficientStockException(product.getName(), product.getAvailableStock(), orderItem.quantity());
            }
            log.info("[StockValidation] Stock OK para {} (Disponible: {}, Solicitado: {})",
                    product.getName(), product.getAvailableStock(), orderItem.quantity());
        });
    }
}
````

Responsabilidades:

- Validar que cada producto solicitado exista.
- Comprobar que el stock disponible sea suficiente para cubrir la cantidad solicitada.
- Detener la cadena lanzando excepciones espec√≠ficas ante cualquier inconsistencia.
- Loggear el estado de la validaci√≥n para trazabilidad.

`AddressValidationHandler`

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class AddressValidationHandler extends BaseOrderValidationHandler {

    private final AddressService addressService;

    @Override
    protected void doHandle(PurchaseOrder order) {
        log.info("[AddressValidation] Verificando: {}, {}", order.shippingAddress().city(), order.shippingAddress().country());
        if (!this.addressService.isValidAddress(order.shippingAddress())) {
            throw new InvalidShippingAddressException();
        }
        log.info("[AddressValidation] Direcci√≥n v√°lida para el env√≠o");
    }
}
````

Responsabilidades:

- Validar que la direcci√≥n de env√≠o cumpla con los criterios definidos (campos no vac√≠os, pa√≠s v√°lido).
- Lanzar excepci√≥n si la direcci√≥n no es v√°lida.
- Registrar informaci√≥n para auditor√≠a y diagn√≥stico.

`BusinessHoursValidationHandler`

````java

@Slf4j
@RequiredArgsConstructor
@Component
public class BusinessHoursValidationHandler extends BaseOrderValidationHandler {
    @Override
    protected void doHandle(PurchaseOrder order) {
        log.info("[BusinessHoursValidation] Verificando horario de procesamiento...");
        int hour = LocalTime.now().getHour();
        if (hour < 7 && hour >= 1) {
            LocalTime startTime = LocalTime.of(1, 0);
            LocalTime endTime = LocalTime.of(6, 59);
            throw new SystemMaintenanceException(startTime, endTime);
        }
        log.info("[BusinessHoursValidation] Horario v√°lido para el procesamiento");
    }
}
````

Responsabilidades:

- Verificar que la orden se procese solo dentro del horario permitido.
- Simular una ventana de mantenimiento que bloquea el procesamiento en determinadas horas.
- Detener la cadena con excepci√≥n si no est√° dentro del horario v√°lido.
- Loggear el proceso para facilitar el soporte y monitoreo.

### Notas generales sobre los validadores concretos

- Cada validador encapsula una √∫nica responsabilidad de validaci√≥n, siguiendo el principio SRP (Single Responsibility
  Principle).
- La cadena puede configurarse para ejecutar validaciones en un orden flexible, simplemente encadenando los handlers
  deseados.
- El patr√≥n facilita a√±adir o eliminar validaciones sin modificar c√≥digo existente, mejorando la mantenibilidad y
  extensibilidad del sistema.

### Configuraci√≥n de la cadena de validaci√≥n

La clase `OrderValidationConfig` se encarga de armar y configurar la cadena de validadores que implementan el
patr√≥n `Chain of Responsibility`.

````java

@Slf4j
@Configuration
public class OrderValidationConfig {
    @Bean(value = "orderValidationChain")
    public OrderValidationHandler orderValidationHandler(CustomerValidationHandler customerValidator,
                                                         StockValidationHandler stockValidator,
                                                         AddressValidationHandler addressValidator,
                                                         BusinessHoursValidationHandler hoursValidator) {
        log.info("Configurando cadena de validaci√≥n de √≥rdenes...");
        customerValidator
                .setNext(stockValidator)
                .setNext(addressValidator)
                .setNext(hoursValidator);

        return customerValidator;
    }
}
````

#### Detalles relevantes

- Se define un bean Spring llamado `orderValidationChain` que representa el `primer manejador de la cadena`.
- Cada validador se enlaza con el siguiente usando el m√©todo `setNext(...)` definido en la interfaz com√∫n, formando la
  secuencia: `CustomerValidationHandler` ‚Üí `StockValidationHandler` ‚Üí `AddressValidationHandler` ‚Üí
  `BusinessHoursValidationHandler`.
- Gracias a esta configuraci√≥n, al invocar el m√©todo `handle(...)` sobre el primer validador (`customerValidator`), la
  solicitud recorrer√° toda la cadena de validaciones en orden.
- La anotaci√≥n `@Configuration` permite que `Spring` gestione esta configuraci√≥n y que los validadores sean inyectados
  autom√°ticamente por el contenedor, aprovechando la inyecci√≥n de dependencias.
- El uso de logs permite registrar la configuraci√≥n para facilitar trazabilidad y debugging.

#### Beneficios de esta configuraci√≥n

- Centraliza la construcci√≥n de la cadena, desacoplando la l√≥gica de validaci√≥n de la creaci√≥n de la cadena.
- Facilita cambiar el orden o agregar/quitar validadores sin modificar las clases concretas, solo modificando esta
  configuraci√≥n.
- Permite que el patr√≥n `Chain of Responsibility` sea f√°cilmente testeable e inyectable en otros componentes `Spring`.

## Servicio de procesamiento de √≥rdenes

`OrderProcessingService`

````java
public interface OrderProcessingService {
    OrderResponse processOrder(PurchaseOrder order);
}
````

- Define el contrato para el procesamiento de √≥rdenes de compra.
- Expone el m√©todo `processOrder` que recibe un `PurchaseOrder` y devuelve un `OrderResponse`.

`OrderProcessingServiceImpl`

````java

@Slf4j
@Service
public class OrderProcessingServiceImpl implements OrderProcessingService {

    private final OrderValidationHandler orderValidationChain;

    public OrderProcessingServiceImpl(@Qualifier(value = "orderValidationChain")
                                      OrderValidationHandler orderValidationChain) {
        this.orderValidationChain = orderValidationChain;
        log.info("Cadena de validaci√≥n inyectada: {}", orderValidationChain.getClass().getSimpleName());
    }

    @Override
    public OrderResponse processOrder(PurchaseOrder order) {
        log.info("==== Procesando orden ====");
        log.info("Customer ID: {}", order.customerId());
        log.info("Items: {}", order.items().size());
        log.info("Total amount: $ {}", order.getTotalAmount());
        log.info("Destination: {}", order.shippingAddress().city());
        log.info("===========================");

        // Ejecutar cadena de validaci√≥n - las excepciones se propagan autom√°ticamente
        this.orderValidationChain.handle(order);

        // Si llegamos aqu√≠, todas las validaciones pasaron
        log.info("Orden procesada correctamente");
        log.info("El pedido ha sido registrado y est√° listo para su preparaci√≥n");

        // Aqu√≠ ir√≠a la l√≥gica de persistencia real
        // PurchaseOrderEntity entity = orderMapper.toEntity(order);
        // orderRepository.save(entity);
        // notificationService.sendOrderConfirmation(order);
        // inventoryService.reserveStock(order.items());
        return new OrderResponse(
                this.generateOrderId(),
                "ORDER_CREATED",
                "Orden creada exitosamente",
                order.getTotalAmount()
        );
    }

    private String generateOrderId() {
        return "ORD-" + System.currentTimeMillis();
    }
}
````

#### Descripci√≥n y aspectos clave:

- `Inyecci√≥n de la cadena de validaci√≥n`
    - Se inyecta el bean `orderValidationChain` configurado previamente con la cadena de validadores.
    - Esto garantiza que la validaci√≥n se ejecute en orden y de forma transparente.


- `M√©todo processOrder`
    - Recibe la orden de compra.
    - Registra datos relevantes para auditor√≠a mediante logs.
    - Ejecuta la cadena de validaci√≥n con `handle(order)`. Si alguna validaci√≥n falla, se lanza una excepci√≥n que puede
      ser manejada globalmente.
    - Si pasa todas las validaciones, simula el procesamiento exitoso y retorna un `OrderResponse` con informaci√≥n de
      confirmaci√≥n.


- `Extensibilidad`
    - La l√≥gica de persistencia, notificaci√≥n o reserva de stock est√° indicada para futuras implementaciones, separando
      responsabilidades.


- `Generaci√≥n simple de ID de orden`. Se crea un ID √∫nico basado en la marca de tiempo actual.
