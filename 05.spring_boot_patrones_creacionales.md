# Patrones creacionales aplicados en Spring Boot

---

# Factory Method

## üéØ Ejemplo 01: Sistema de Notificaciones Multi-canal usando Factory Method

Este ejemplo implementa el `patr√≥n Factory Method` en un contexto realista de `Spring Boot`, simulando un sistema de
notificaciones multi-canal. La idea principal es desacoplar la l√≥gica de negocio de la creaci√≥n de objetos concretos
(`correo`, `SMS`, `push`, `WhatsApp`), delegando dicha responsabilidad a una f√°brica central (`NotificationFactory`).

Cada tipo de notificaci√≥n se modela como un `Concrete Product` que implementa la interfaz com√∫n `Notification`. La
f√°brica utiliza el canal especificado en la solicitud (`NotificationChannel`) para devolver din√°micamente la
implementaci√≥n correcta.

El flujo completo se organiza as√≠:

1. El cliente (`NotificationController`) recibe una petici√≥n HTTP con los datos de la notificaci√≥n.
2. El servicio (`NotificationService`) valida la informaci√≥n y solicita a la f√°brica la implementaci√≥n adecuada seg√∫n el
   canal.
3. La f√°brica (`NotificationFactory`) resuelve y entrega la instancia concreta de `Notification`.
4. El producto concreto (`EmailNotification`, `SMSNotification`, `PushNotification`, `WhatsAppNotification`) ejecuta el
   env√≠o simulado.
5. Se retorna una respuesta uniforme (`NotificationResponse`) al cliente.

Con esta arquitectura, la aplicaci√≥n puede crecer f√°cilmente: para a√±adir un nuevo canal de notificaci√≥n, basta con
crear un nuevo `ConcreteProduct` que implemente la interfaz y anotarlo como `@Component`, sin necesidad de modificar
la l√≥gica central.

En un escenario productivo, este patr√≥n permite:

- `Escalabilidad`: a√±adir nuevos canales sin romper c√≥digo existente.
- `Mantenibilidad`: el c√≥digo queda m√°s limpio y orientado a responsabilidades espec√≠ficas.
- `Flexibilidad`: el servicio trabaja contra abstracciones, no contra implementaciones concretas.

### Creando DTOs y Model

üì¶ `NotificationRequest`

````java
public record NotificationRequest(@NotNull
                                  NotificationChannel channel,
                                  @NotBlank
                                  String message,
                                  @NotBlank
                                  String recipient) {
}
````

- Es el DTO de entrada que representa la petici√≥n del cliente cuando quiere enviar una notificaci√≥n.
- Incluye:
    - `channel`: el canal de notificaci√≥n elegido (`EMAIL`, `SMS`, etc.), obligatorio.
    - `message`: el contenido del mensaje, obligatorio y no vac√≠o.
    - `recipient`: destinatario del mensaje, obligatorio y no vac√≠o.

üì¶ `NotificationResponse`

````java
public record NotificationResponse(String message,
                                   NotificationChannel channel,
                                   String recipient,
                                   LocalDateTime timestamp) {
}
````

- Es el DTO de salida que devuelve el sistema despu√©s de procesar una notificaci√≥n.
- Incluye:
    - `message`: texto de confirmaci√≥n o estado.
    - `channel`: canal por el cual se envi√≥ la notificaci√≥n.
    - `recipient`: destinatario.
    - `timestamp`: fecha y hora de procesamiento.

üì¶ `NotificationChannel`

````java
public enum NotificationChannel {
    EMAIL,
    SMS,
    PUSH,
    WHATSAPP
}
````

- Representa los canales soportados para el env√≠o de notificaciones.
- Se usa en el Request para indicar cu√°l se desea y en el Response para informar cu√°l se utiliz√≥.

### üöÄ Product del Factory Method

En el patr√≥n `Factory Method`, el `Product` define la interfaz o clase abstracta que describe las operaciones que los
objetos creados por la f√°brica deben implementar. Todas las implementaciones concretas del producto seguir√°n este
contrato.

En nuestro caso:

````java
public interface Notification {
    void send(String message, String recipient);

    NotificationChannel getChannel();
}
````

### üöÄ Concrete Products del Factory Method

Los `Concrete Products` son las implementaciones concretas de la interfaz o clase abstracta `Product`, en nuestro caso
implementaciones concretas del `Notification`. En ese sentido, tenemos cuatro implementaciones concretas:
`EmailNotification`, `PushNotification`, `SMSNotification`, `WhatsAppNotification`. todos implementando la interfaz
`Notification`.

````java

@Slf4j
@Component
public class EmailNotification implements Notification {

    private final String smtpServer = "smtp.company.com";
    private final int port = 587;
    private final String username = "notifications@company.com";

    @Override
    public void send(String message, String recipient) {
        log.info("=== Email Notification ===");
        log.info("SMTP Server: {}:{}", this.smtpServer, this.port);
        log.info("From: {}", this.username);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);

        this.simulateEmailSending(message, recipient);
        log.info("Correo electr√≥nico enviado exitosamente a {}", recipient);
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.EMAIL;
    }

    private void simulateEmailSending(String message, String recipient) {
        try {
            log.info("Simulando el env√≠o de correo, [mensaje]: {}, [a]: {}", message, recipient);
            Thread.sleep(Duration.ofSeconds(2));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Env√≠o de correo electr√≥nico interrumpido", e);
        }
    }
}
````

````java

@Slf4j
@Component
public class SMSNotification implements Notification {

    private final String apiKey = "twilio_api_key_abc123xyz";
    private final String provider = "Twilio";

    @Override
    public void send(String message, String recipient) {
        log.info("=== SMS Notification ===");
        log.info("Provider: {}", this.provider);
        log.info("API Key: {}", this.apiKey.substring(0, 8) + "...");
        log.info("To: {}", recipient);
        log.info("Message: {}", message);

        this.simulateSMSSending(message, recipient);
        log.info("SMS enviado exitosamente a {}", recipient);
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.SMS;
    }

    private void simulateSMSSending(String message, String recipient) {
        try {
            log.info("Simulando el env√≠o SMS, [mensaje]: {}, [a]: {}", message, recipient);
            Thread.sleep(Duration.ofSeconds(1));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Env√≠o de SMS interrumpido", e);
        }
    }
}
````

````java

@Slf4j
@Component
public class PushNotification implements Notification {

    private final String firebaseKey = "firebase_server_key_def456";
    private final String appId = "com.company.app";

    @Override
    public void send(String message, String recipient) {
        log.info("=== Push Notification ===");
        log.info("Firebase Key: {}", this.firebaseKey.substring(0, 10) + "...");
        log.info("APP ID: {}", this.appId);
        log.info("Device Token: {}", recipient);
        log.info("Message: {}", message);

        this.simulatePushSending(message, recipient);
        log.info("Notificaci√≥n push enviada exitosamente a {}", recipient);
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.PUSH;
    }

    private void simulatePushSending(String message, String recipient) {
        try {
            log.info("Simulando env√≠o de notificaci√≥n push, [mensaje]: {}, [a]: {}", message, recipient);
            Thread.sleep(Duration.ofMillis(1500));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Env√≠o de notificaciones push interrumpido", e);
        }
    }
}
````

````java

@Slf4j
@Component
public class WhatsAppNotification implements Notification {

    private final String businessApiKey = "whatsapp_business_key_ghi789";
    private final String phoneNumberId = "1234567890";

    @Override
    public void send(String message, String recipient) {
        log.info("=== WhatsApp Notification ===");
        log.info("Business API KEY: {}", this.businessApiKey.substring(0, 12) + "...");
        log.info("Phone Number ID: {}", this.phoneNumberId);
        log.info("To: {}", recipient);
        log.info("Message: {}", message);

        this.simulateWhatsAppSending(message, recipient);
        log.info("Mensaje de WhatsApp enviado exitosamente a {}", recipient);
    }

    @Override
    public NotificationChannel getChannel() {
        return NotificationChannel.WHATSAPP;
    }

    private void simulateWhatsAppSending(String message, String recipient) {
        try {
            log.info("Simulando env√≠o de WhatsApp, [mensaje]: {}, [a]: {}", message, recipient);
            Thread.sleep(Duration.ofMillis(800));
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("El env√≠o de WhatsApp se interrumpi√≥", e);
        }
    }
}
````

### üöÄ Creator del Factory Method

En el patr√≥n `Factory Method` cl√°sico (puro Java, GoF) el `Creator` y los `Concrete Creators` existen para desacoplar
la creaci√≥n del objeto (`Product`) de su uso.

- El `Creator` define el `m√©todo f√°brica` abstracto (por ejemplo: `createNotification()`),
- Y cada `ConcreteCreator` devuelve un `ConcreteProduct`.

üëâ En `Spring Boot`, gran parte de esa responsabilidad se vuelve redundante porque:

- `Spring` ya se encarga de la `inyecci√≥n de dependencias` (`IoC)`.
- Con `@Component`, `@Service`, `@Bean`, etc., ya registras tus `ConcreteProducts` en el contexto.
- `Spring` puede inyectarte todos los `Notification` disponibles en un `Map<NotificationChannel, Notification>` o
  `List<Notification>` ‚Äî lo cual reemplaza el papel del `Factory Method` cl√°sico.

### üìå Entonces, ¬øqu√© pasa con Creator y ConcreteCreator en Spring Boot?

1. Si lo aplicas al pie de la letra (`GoF`):
    - Crear√≠as una clase abstracta `NotificationCreator` con un m√©todo abstracto `createNotification()` y probablemente
      implementes un m√©todo `processNotification()` que aplique cierta l√≥gica y que internamente llame al m√©todo
      abstracto.
    - Y tendr√≠as `EmailNotificationCreator`, `SMSNotificationCreator`, etc.
    - Pero en `Spring Boot` esto duplica trabajo, porque esos `beans` ya est√°n gestionados.


2. Lo que se hace en entornos productivos:
    - Se crea un `Factory central` que selecciona el `Notification` adecuado en base al `NotificationChannel`.

### Factory Central

Este `NotificationFactory` hace el papel de `Creator` (pero sin necesidad de m√∫ltiples `ConcreteCreators`).

````java

@Slf4j
@Component
public class NotificationFactory {

    private final Map<NotificationChannel, Notification> notificationMap;

    public NotificationFactory(List<Notification> notifications) {
        this.notificationMap = notifications.stream()
                .collect(Collectors.toMap(
                        Notification::getChannel,                       // La clave del mapa ser√° el canal
                        Function.identity(),                            // El valor del mapa ser√° la notificaci√≥n concreta
                        (existing, replacement) -> existing,            // Estrategia de fusi√≥n en caso de duplicados, se mantiene el existente
                        () -> new EnumMap<>(NotificationChannel.class)  // Proporciona el tipo de mapa a usar
                ));
        log.info("NotificationFactory inicializado con canales soportados: {}", this.notificationMap.keySet());
    }

    public Notification getNotification(NotificationChannel channel) {
        Notification notification = this.notificationMap.get(channel);
        if (Objects.isNull(notification)) {
            throw new IllegalArgumentException("Canal de notificaci√≥n no soportado: " + channel);
        }
        return notification;
    }
}
````

‚úÖ Puntos fuertes de tu implementaci√≥n

1. `Uso de EnumMap`
    - Muy bien elegido. `EnumMap` es mucho m√°s eficiente en memoria y velocidad que un `HashMap` cuando la clave es un
      `enum`.
    - En un sistema real donde `NotificationChannel` no va a crecer exponencialmente, esto es ideal.

2. Construcci√≥n del `Map` a partir de los beans inyectados (`List<Notification>`)
    - Aprovechas el `IoC de Spring`: Spring detecta todos los `@Component` que implementan `Notification`
      (`EmailNotification`, `SMSNotification`, etc.) y los inyecta.
    - Esto elimina la necesidad de `ConcreteCreators` uno a uno ‚Üí m√°s limpio, menos c√≥digo repetitivo.

3. Resoluci√≥n de conflictos con `mergeFunction` (`(existing, replacement) -> existing`)
    - Excelente detalle: evitas que Spring falle si hubiera dos beans con el mismo `NotificationChannel`.
    - Aunque normalmente no deber√≠as tener dos `EmailNotification`, es mejor que tu `Factory` se defienda.

4. `Validaci√≥n en getNotification`
    - El `IllegalArgumentException` es perfecto para evitar `NullPointerException` silencioso.
    - Esto en producci√≥n ayuda a detectar cuando un canal no est√° soportado.

‚úÖ Conclusi√≥n de mi opini√≥n:

- En `Spring Boot` no necesitamos replicar `1:1` el `Creator` y los `ConcreteCreators` de `GoF`.
- Lo m√°s cercano (y productivo) es un `Factory central` que act√∫a como `Creator`, y que se apoya en el `IoC` de `Spring`
  para `inyectar` los `ConcreteProducts`.
- As√≠ combinamos el patr√≥n `Factory Method` con la filosof√≠a `Spring (IoC/DI)` de manera elegante y realista.

### üéØ Servicio de Notificaciones con Factory Central

El servicio (`NotificationServiceImpl`) act√∫a como la capa de `orquestaci√≥n de negocio`. Su responsabilidad principal
no es implementar la l√≥gica espec√≠fica de cada canal (eso lo hacen los `Concrete Products`), sino:

- Recibir la petici√≥n de notificaci√≥n desde una capa superior (por ejemplo, un controlador REST).
- Validar los datos de entrada seg√∫n reglas de negocio.
- Delegar al Factory central (`NotificationFactory`) la obtenci√≥n de la implementaci√≥n correcta del `Notification` seg√∫n
  el canal (`EMAIL`, `SMS`, `PUSH`, `WHATSAPP`).
- Invocar la `operaci√≥n send(...)` del `Concrete Product` devuelto por la f√°brica.
- Realizar un posprocesamiento transversal (logging, encapsulaci√≥n de respuesta en NotificationResponse).

````java
public interface NotificationService {
    NotificationResponse sendNotification(NotificationRequest request);
}
````

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class NotificationServiceImpl implements NotificationService {

    private final NotificationFactory notificationFactory;

    @Override
    public NotificationResponse sendNotification(NotificationRequest request) {
        try {
            log.info("Procesando {} notificaci√≥n para el destinatario {}", request.channel(), request.recipient());

            // Validaci√≥n de l√≥gica de negocio
            this.validateInput(request.message(), request.recipient());

            // Obtenemos el notificador concreto y enviamos notificaci√≥n
            Notification notification = this.notificationFactory.getNotification(request.channel());
            notification.send(request.message(), request.recipient());

            // Pos-procesamiento
            log.info("Logged: {} notificaci√≥n enviado a {}", request.channel(), request.recipient());

            return new NotificationResponse("Notificaci√≥n enviada exitosamente", request.channel(), request.recipient(), LocalDateTime.now());
        } catch (Exception e) {
            final String message = "No se pudo enviar la notificaci√≥n";
            log.error(message.concat(" {} a {}: {}"), request.channel(), request.recipient(), e.getMessage());
            throw new IllegalArgumentException(message.concat(" %s a %s: %s").formatted(request.channel(), request.recipient(), e.getMessage()));
        }
    }

    private void validateInput(@NotBlank String message, @NotBlank String recipient) {
        if (Objects.isNull(message) || message.isBlank()) {
            log.error("El mensaje no puede estar vac√≠o");
            throw new IllegalArgumentException("El mensaje no puede ser vac√≠o.");
        }

        if (Objects.isNull(recipient) || recipient.isBlank()) {
            log.error("El destinatario no puede estar vac√≠o");
            throw new IllegalArgumentException("El destinatario no puede estar vac√≠o.");
        }
    }
}
````

De esta forma, el servicio no depende directamente de ninguna implementaci√≥n concreta (`EmailNotification`,
`SMSNotification`, etc.), sino √∫nicamente del contrato com√∫n (`Notification`) y de la abstracci√≥n de f√°brica
(`NotificationFactory`). Esto asegura:

- `Bajo acoplamiento`: no es necesario modificar el servicio si se agregan nuevos canales.
- `Escalabilidad`: basta con a√±adir un nuevo `@Component` que implemente `Notification`.
- `Cercan√≠a a entornos productivos`: la responsabilidad del servicio es clara (orquestaci√≥n y reglas de negocio),
  mientras que la f√°brica centraliza la resoluci√≥n de dependencias.

### üåê Controlador REST de Notificaciones

El `NotificationController` expone el punto de entrada HTTP para que clientes externos (aplicaciones web, m√≥viles,
servicios de terceros, etc.) puedan solicitar el env√≠o de notificaciones.

````java

@Slf4j
@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/notifications")
public class NotificationController {

    private final NotificationService notificationService;

    @PostMapping
    public ResponseEntity<NotificationResponse> sendNotification(@Valid @RequestBody NotificationRequest request) {
        log.info("Se recibi√≥ una solicitud para enviar {} notificaci√≥n a {}", request.channel(), request.recipient());
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(this.notificationService.sendNotification(request));
    }
}
````

De esta manera, el controlador cumple el rol de adaptador de entrada dentro de una arquitectura t√≠pica en Spring Boot:

- No contiene l√≥gica de negocio.
- Se limita a recibir, validar, loggear y delegar.
- Permite que el resto del sistema evolucione sin impactar la capa de exposici√≥n HTTP.

## üìù Descripci√≥n de la ejecuci√≥n

- El cliente env√≠a una solicitud `POST` al endpoint `/api/v1/notifications` con los datos del canal, mensaje y
  destinatario.
- El controller recibe la petici√≥n y delega al servicio, el cual usa el `Factory` para resolver el
  `Notification concreto`
  (en este caso `EmailNotification`).
- El notificador simula el env√≠o, se registra en logs el proceso completo y finalmente se responde con un `201 Created`
  junto a un `NotificationResponse` indicando √©xito.

````bash
$ curl -v -X POST -H "Content-Type: application/json" -d "{\"channel\": \"EMAIL\", \"message\": \"Bienvenido a nuestra plataforma\", \"recipient\": \"lesly@gmail.com\"}" http://localhost:8080/api/v1/notifications | jq
>
< HTTP/1.1 201
< Content-Type: application/json
< Transfer-Encoding: chunked
< Date: Mon, 18 Aug 2025 21:56:53 GMT
<
0:00:02 --:--:--
{
  "message": "Notificaci√≥n enviada exitosamente",
  "channel": "EMAIL",
  "recipient": "lesly@gmail.com",
  "timestamp": "2025-08-18T16:56:53.6791363"
}
````

````bash
d.m.p.s.c.f.n.c.NotificationController   : Se recibi√≥ una solicitud para enviar EMAIL notificaci√≥n a lesly@gmail.com
d.m.p.s.c.f.n.s.NotificationServiceImpl  : Procesando EMAIL notificaci√≥n para el destinatario lesly@gmail.com
d.m.p.s.c.f.n.n.EmailNotification        : === Email Notification ===
d.m.p.s.c.f.n.n.EmailNotification        : SMTP Server: smtp.company.com:587
d.m.p.s.c.f.n.n.EmailNotification        : From: notifications@company.com
d.m.p.s.c.f.n.n.EmailNotification        : To: lesly@gmail.com
d.m.p.s.c.f.n.n.EmailNotification        : Message: Bienvenido a nuestra plataforma
d.m.p.s.c.f.n.n.EmailNotification        : Simulando el env√≠o de correo, [mensaje]: Bienvenido a nuestra plataforma, [a]: lesly@gmail.com
d.m.p.s.c.f.n.n.EmailNotification        : Correo electr√≥nico enviado exitosamente a lesly@gmail.com
d.m.p.s.c.f.n.s.NotificationServiceImpl  : Logged: EMAIL notificaci√≥n enviado a lesly@gmail.com 
````
